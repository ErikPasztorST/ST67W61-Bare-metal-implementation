###############################################################################
#
# IAR ANSI C/C++ Compiler V9.20.1.318/W64 for ARM         20/Aug/2025  15:41:49
# Copyright 1999-2021 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\ST67W6X\Target\spi_port.c
#    Command line                 =
#        -f
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM\G0_minimal\Obj\ST67W6X\Target\spi_port.o.rsp
#        (C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\ST67W6X\Target\spi_port.c
#        -D USE_HAL_DRIVER -D STM32G0B1xx -lcN
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM\G0_minimal\List\ST67W6X\Target
#        -o
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM\G0_minimal\Obj\ST67W6X\Target
#        --debug --endian=little --cpu=Cortex-M0+ -e --fpu=None --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.0\arm\inc\c\DLib_Config_Full.h" -I
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM/../Core/Inc\ -I
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM/../ST67W6X/Target\
#        -I
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM/../ST67W6X/Drivers\
#        -I
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM/../Drivers/STM32G0xx_HAL_Driver/Inc\
#        -I
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM/../Drivers/STM32G0xx_HAL_Driver/Inc/Legacy\
#        -I
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM/../Drivers/CMSIS/Device/ST/STM32G0xx/Include\
#        -I
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM/../Drivers/CMSIS/Include\
#        -Ohz) --dependencies=n
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM\G0_minimal\Obj\ST67W6X\Target\spi_port.o.d
#    Locale                       =  C
#    List file                    =
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM\G0_minimal\List\ST67W6X\Target\spi_port.lst
#    Object file                  =
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM\G0_minimal\Obj\ST67W6X\Target\spi_port.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  1
#      __dlib_full_locale_support =  1
#      __dlib_version             =  6
#
###############################################################################

C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\ST67W6X\Target\spi_port.c
      1          /* USER CODE BEGIN Header */
      2          /**
      3            ******************************************************************************
      4            * @file    spi_port.c
      5            * @author  GPM Application Team
      6            * @brief   SPI bus interface porting layer implementation
      7            ******************************************************************************
      8            * @attention
      9            *
     10            * Copyright (c) 2025 STMicroelectronics.
     11            * All rights reserved.
     12            *
     13            * This software is licensed under terms that can be found in the LICENSE file
     14            * in the root directory of this software component.
     15            * If no LICENSE file comes with this software, it is provided AS-IS.
     16            *
     17            ******************************************************************************
     18            */
     19          /* USER CODE END Header */
     20          
     21          /**
     22            * This file is based on QCC74xSDK provided by Qualcomm.
     23            * See https://git.codelinaro.org/clo/qcc7xx/QCCSDK-QCC74x for more information.
     24            *
     25            * Reference source: examples/stm32_spi_host/QCC743_SPI_HOST/Core/Src/spi_iface.c
     26            */
     27          
     28          /* Includes ------------------------------------------------------------------*/
     29          #include <stdio.h>
     30          #include <stdint.h>
     31          #include <string.h>
     32          #include <stdlib.h>
     33          
     34          #include "spi_port.h"
     35          #include "main.h"
     36          
     37          /* USER CODE BEGIN Includes */
     38          
     39          /* USER CODE END Includes */
     40          
     41          /* Global variables ----------------------------------------------------------*/
     42          extern SPI_HandleTypeDef NCP_SPI_HANDLE;
     43          
     44          /* USER CODE BEGIN GV */
     45          
     46          /* USER CODE END GV */
     47          
     48          /* Private typedef -----------------------------------------------------------*/
     49          /* USER CODE BEGIN PTD */
     50          
     51          /* USER CODE END PTD */
     52          
     53          /* Private defines -----------------------------------------------------------*/
     54          /* USER CODE BEGIN PD */
     55          
     56          /* USER CODE END PD */
     57          
     58          /* Private macros ------------------------------------------------------------*/
     59          /* USER CODE BEGIN PM */
     60          
     61          /* USER CODE END PM */
     62          
     63          /* Private variables ---------------------------------------------------------*/
     64          
     65          /* USER CODE BEGIN PV */
     66          
     67          /* USER CODE END PV */
     68          
     69          /* Private function prototypes -----------------------------------------------*/
     70          /* USER CODE BEGIN PFP */
     71          
     72          /* USER CODE END PFP */
     73          
     74          /* Functions Definition ------------------------------------------------------*/
     75          #ifdef __ICCARM__
     76          void *spi_port_memcpy(void *dest, const void *src, unsigned int len)
     77          #endif /* __ICCARM__ */
     78          #ifdef __GNUC__
     79          void *memcpy(void *dest, const void *src, unsigned int len)
     80          #endif /* __ICCARM__ */
     81          {
     82            /* USER CODE BEGIN memcpy_1 */
     83          
     84            /* USER CODE END memcpy_1 */
     85            uint8_t *d = (uint8_t *)dest;
     86            const uint8_t *s = (const uint8_t *)src;
     87          
     88            /* Copy bytes until the destination address is aligned to 4 bytes */
     89            while (((uint32_t) d % 4 != 0) && len > 0)
     90            {
     91              *d++ = *s++;
     92              len--;
     93            }
     94          
     95            if ((uint32_t) s % 4 != 0)
     96            {
     97          	while (len > 0)
     98          	{
     99          		*d++ = *s++;
    100          		len--;
    101          	}
    102          	return dest;
    103            }
    104          
    105            /* Copy 4-byte blocks */
    106            uint32_t *d32 = (uint32_t *)d;
    107            const uint32_t *s32 = (const uint32_t *)s;
    108            while (len >= 4)
    109            {
    110              *d32++ = *s32++;
    111              len -= 4;
    112            }
    113          
    114            /* Copy remaining bytes */
    115            d = (uint8_t *)d32;
    116            s = (const uint8_t *)s32;
    117            while (len > 0)
    118            {
    119              *d++ = *s++;
    120              len--;
    121            }
    122          
    123            return dest;
    124            /* USER CODE BEGIN memcpy_End */
    125          
    126            /* USER CODE END memcpy_End */
    127          }
    128          
    129          void buffer_to_hexstr(const uint8_t *in, uint16_t len, char *out) {
    130              int pos = 0;
    131              for (uint8_t i = 0; i < len && pos < SPI_PHY_LOG_CHARS-1; i++) {
    132                  if (i > 0 && pos < SPI_PHY_LOG_CHARS-1) out[pos++] = ' ';
    133                  if (pos < SPI_PHY_LOG_CHARS-2) pos += snprintf(&out[pos], SPI_PHY_LOG_CHARS - pos, "%02X", in[i]);
    134                  if (pos >= SPI_PHY_LOG_CHARS) break;
    135              }
    136              out[pos < SPI_PHY_LOG_CHARS ? pos : SPI_PHY_LOG_CHARS-1] = '\0';
    137          }
    138          
    139          void spi_log_buffer(void *in, uint16_t len, uint8_t is_txrx, uint8_t dma)
    140          {
    141          #if (SPI_PHY_LOG_CHARS > 0)
    142          	char log_buffer[SPI_PHY_LOG_CHARS] = {0};
    143          	if (in != NULL) buffer_to_hexstr(in, len, log_buffer);
    144          
    145          	if (dma)
    146          	{
    147          		if (is_txrx == 0) printf("\nDMA RX   : ");
    148          		else if (is_txrx == 1) printf("\nDMA TX/rx: ");
    149          		else if (is_txrx == 2) printf("\nDMA tx/RX: ");
    150          	}
    151          	else
    152          	{
    153          		if (is_txrx == 0) printf("\nSPI RX   : ");
    154          		else if (is_txrx == 1) printf("\nSPI TX/rx: ");
    155          		else if (is_txrx == 2) printf("\nSPI tx/RX: ");
    156          	}
    157          
    158          	printf("%s\n", log_buffer);
    159          #endif
    160          }
    161          
    162          int32_t spi_port_init()
    163          {
    164            /* USER CODE BEGIN spi_port_init_1 */
    165          
    166            /* USER CODE END spi_port_init_1 */
    167            /* Powering up the NCP using GPIO CHIP_EN */
    168            HAL_GPIO_WritePin(CHIP_EN_GPIO_Port, CHIP_EN_Pin, GPIO_PIN_SET);
    169          
    170            return 0;
    171            /* USER CODE BEGIN spi_port_init_End */
    172          
    173            /* USER CODE END spi_port_init_End */
    174          }
    175          
    176          int32_t spi_port_deinit(void)
    177          {
    178            /* USER CODE BEGIN spi_port_deinit_1 */
    179          
    180            /* USER CODE END spi_port_deinit_1 */
    181            /* Switch off the NCP using GPIO CHIP_EN */
    182            HAL_GPIO_WritePin(CHIP_EN_GPIO_Port, CHIP_EN_Pin, GPIO_PIN_RESET);
    183          
    184            return 0;
    185            /* USER CODE BEGIN spi_port_deinit_End */
    186          
    187            /* USER CODE END spi_port_deinit_End */
    188          }
    189          
    190          int32_t spi_port_transfer(void *tx_buf, void *rx_buf, uint16_t len)
    191          {
    192            /* USER CODE BEGIN spi_port_transfer_1 */
    193          
    194            /* USER CODE END spi_port_transfer_1 */
    195            HAL_StatusTypeDef status;
    196          
    197          #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    198            SCB_CleanInvalidateDCache_by_Addr(rx_buf, len);
    199          #endif /* __DCACHE_PRESENT */
    200          
    201            /* Check whether host data is to be transmitted to the NCP, otherwise read only data from the NCP */
    202            if (tx_buf != NULL)
    203            {
    204          #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    205              SCB_CleanDCache_by_Addr(tx_buf, len);
    206          #endif /* __DCACHE_PRESENT */
    207              status = HAL_SPI_TransmitReceive(&NCP_SPI_HANDLE, tx_buf, rx_buf, len, SPI_TRANSMIT_TIMEOUT_MS);
    208          #if (SPI_PHY_LOG_CHARS > 0)
    209              spi_log_buffer(tx_buf, len, 1, 0);
    210              spi_log_buffer(rx_buf, len, 2, 0);
    211          #endif
    212            }
    213            else
    214            {
    215              status = HAL_SPI_Receive(&NCP_SPI_HANDLE, rx_buf, len, SPI_TRANSMIT_TIMEOUT_MS);
    216          #if (SPI_PHY_LOG_CHARS > 0)
    217              spi_log_buffer(rx_buf, len, 0, 0);
    218          #endif
    219            }
    220          #if (SPI_PHY_LOG_CHARS > 0)
    221            printf("-----------\n");
    222          #endif
    223          
    224            return (status == HAL_OK ? 0 : -1);
    225            /* USER CODE BEGIN spi_port_transfer_End */
    226          
    227            /* USER CODE END spi_port_transfer_End */
    228          }
    229          
    230          int32_t spi_port_is_ready(void)
    231          {
    232            /* USER CODE BEGIN spi_port_is_ready_1 */
    233          
    234            /* USER CODE END spi_port_is_ready_1 */
    235            /* Check whether NCP data are available on the SPI bus */
    236            return (int32_t)HAL_GPIO_ReadPin(SPI_RDY_GPIO_Port, SPI_RDY_Pin);
    237            /* USER CODE BEGIN spi_port_is_ready_End */
    238          
    239            /* USER CODE END spi_port_is_ready_End */
    240          }
    241          
    242          int32_t spi_port_set_cs(int32_t state)
    243          {
    244            /* USER CODE BEGIN spi_port_set_cs_1 */
    245          
    246            /* USER CODE END spi_port_set_cs_1 */
    247            if (state)
    248            {
    249              /* Activate Chip Select before starting transfer */
    250              HAL_GPIO_WritePin(SPI_CS_GPIO_Port, SPI_CS_Pin, GPIO_PIN_SET);
    251            }
    252            else
    253            {
    254              /* Disable Chip Select when transfer is complete */
    255              HAL_GPIO_WritePin(SPI_CS_GPIO_Port, SPI_CS_Pin, GPIO_PIN_RESET);
    256            }
    257          
    258            return 0;
    259            /* USER CODE BEGIN spi_port_set_cs_End */
    260          
    261            /* USER CODE END spi_port_set_cs_End */
    262          }
    263          
    264          uint32_t spi_port_itm(uint32_t ch)
    265          {
    266            /* USER CODE BEGIN spi_port_itm_1 */
    267          
    268            /* USER CODE END spi_port_itm_1 */
    269          #if 0
    270            return ITM_SendChar(ch);
    271          #endif /* 0 */
    272            return 0;
    273            /* USER CODE BEGIN spi_port_itm_End */
    274          
    275            /* USER CODE END spi_port_itm_End */
    276          }
    277          
    278          /* USER CODE BEGIN FD */
    279          
    280          /* USER CODE END FD */
    281          
    282          /* Weak functions redefinition -----------------------------------------------*/
    283          
    284          /* USER CODE BEGIN WFR */
    285          
    286          /* USER CODE END WFR */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   buffer_to_hexstr
       0   spi_log_buffer
       8   spi_port_deinit
         8   -> HAL_GPIO_WritePin
       8   spi_port_init
         8   -> HAL_GPIO_WritePin
       8   spi_port_is_ready
         8   -> HAL_GPIO_ReadPin
       0   spi_port_itm
      12   spi_port_memcpy
       8   spi_port_set_cs
         8   -> HAL_GPIO_WritePin
      16   spi_port_transfer
        16   -> HAL_SPI_Receive
        16   -> HAL_SPI_TransmitReceive


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
      12  ?Subroutine0
       8  ?_0
       8  buffer_to_hexstr
       2  spi_log_buffer
       4  spi_port_deinit
       6  spi_port_init
      12  spi_port_is_ready
       4  spi_port_itm
      78  spi_port_memcpy
      20  spi_port_set_cs
      40  spi_port_transfer

 
   8 bytes in section .rodata
 198 bytes in section .text
 
 198 bytes of CODE  memory
   8 bytes of CONST memory

Errors: none
Warnings: none
