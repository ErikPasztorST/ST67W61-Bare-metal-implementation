###############################################################################
#
# IAR ANSI C/C++ Compiler V9.20.1.318/W64 for ARM         20/Aug/2025  15:41:46
# Copyright 1999-2021 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\Drivers\STM32G0xx_HAL_Driver\Src\stm32g0xx_hal_gpio.c
#    Command line      =
#        -f
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM\G0_minimal\Obj\Drivers\STM32G0xx_HAL_Driver\stm32g0xx_hal_gpio.o.rsp
#        (C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\Drivers\STM32G0xx_HAL_Driver\Src\stm32g0xx_hal_gpio.c
#        -D USE_HAL_DRIVER -D STM32G0B1xx -lcN
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM\G0_minimal\List\Drivers\STM32G0xx_HAL_Driver
#        -o
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM\G0_minimal\Obj\Drivers\STM32G0xx_HAL_Driver
#        --debug --endian=little --cpu=Cortex-M0+ -e --fpu=None --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.0\arm\inc\c\DLib_Config_Full.h" -I
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM/../Core/Inc\ -I
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM/../ST67W6X/Target\
#        -I
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM/../ST67W6X/Drivers\
#        -I
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM/../Drivers/STM32G0xx_HAL_Driver/Inc\
#        -I
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM/../Drivers/STM32G0xx_HAL_Driver/Inc/Legacy\
#        -I
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM/../Drivers/CMSIS/Device/ST/STM32G0xx/Include\
#        -I
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM/../Drivers/CMSIS/Include\
#        -Ohz) --dependencies=n
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM\G0_minimal\Obj\Drivers\STM32G0xx_HAL_Driver\stm32g0xx_hal_gpio.o.d
#    Locale            =  C
#    List file         =
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM\G0_minimal\List\Drivers\STM32G0xx_HAL_Driver\stm32g0xx_hal_gpio.lst
#    Object file       =
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM\G0_minimal\Obj\Drivers\STM32G0xx_HAL_Driver\stm32g0xx_hal_gpio.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\Drivers\STM32G0xx_HAL_Driver\Src\stm32g0xx_hal_gpio.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32g0xx_hal_gpio.c
      4            * @author  MCD Application Team
      5            * @brief   GPIO HAL module driver.
      6            *          This file provides firmware functions to manage the following
      7            *          functionalities of the General Purpose Input/Output (GPIO) peripheral:
      8            *           + Initialization and de-initialization functions
      9            *           + IO operation functions
     10            *
     11            ******************************************************************************
     12            * @attention
     13            *
     14            * Copyright (c) 2018 STMicroelectronics.
     15            * All rights reserved.
     16            *
     17            * This software is licensed under terms that can be found in the LICENSE file
     18            * in the root directory of this software component.
     19            * If no LICENSE file comes with this software, it is provided AS-IS.
     20            *
     21            ******************************************************************************
     22            @verbatim
     23            ==============================================================================
     24                              ##### GPIO Peripheral features #####
     25            ==============================================================================
     26            [..]
     27              (+) Each port bit of the general-purpose I/O (GPIO) ports can be individually
     28                  configured by software in several modes:
     29                  (++) Input mode
     30                  (++) Analog mode
     31                  (++) Output mode
     32                  (++) Alternate function mode
     33                  (++) External interrupt/event lines
     34          
     35              (+) During and just after reset, the alternate functions and external interrupt
     36                  lines are not active and the I/O ports are configured in input floating mode.
     37          
     38              (+) All GPIO pins have weak internal pull-up and pull-down resistors, which can be
     39                  activated or not.
     40          
     41              (+) In Output or Alternate mode, each IO can be configured on open-drain or push-pull
     42                  type and the IO speed can be selected depending on the VDD value.
     43          
     44              (+) The microcontroller IO pins are connected to onboard peripherals/modules through a
     45                  multiplexer that allows only one peripheral alternate function (AF) connected
     46                 to an IO pin at a time. In this way, there can be no conflict between peripherals
     47                 sharing the same IO pin.
     48          
     49              (+) All ports have external interrupt/event capability. To use external interrupt
     50                  lines, the port must be configured in input mode. All available GPIO pins are
     51                  connected to the 16 external interrupt/event lines from EXTI0 to EXTI15.
     52          
     53              (+) The external interrupt/event controller consists of up to 28 edge detectors
     54                  (16 lines are connected to GPIO) for generating event/interrupt requests (each
     55                  input line can be independently configured to select the type (interrupt or event)
     56                  and the corresponding trigger event (rising or falling or both). Each line can
     57                  also be masked independently.
     58          
     59                               ##### How to use this driver #####
     60            ==============================================================================
     61            [..]
     62              (#) Enable the GPIO AHB clock using the following function: __HAL_RCC_GPIOx_CLK_ENABLE().
     63          
     64              (#) Configure the GPIO pin(s) using HAL_GPIO_Init().
     65                  (++) Configure the IO mode using "Mode" member from GPIO_InitTypeDef structure
     66                  (++) Activate Pull-up, Pull-down resistor using "Pull" member from GPIO_InitTypeDef
     67                       structure.
     68                  (++) In case of Output or alternate function mode selection: the speed is
     69                       configured through "Speed" member from GPIO_InitTypeDef structure.
     70                  (++) In alternate mode is selection, the alternate function connected to the IO
     71                       is configured through "Alternate" member from GPIO_InitTypeDef structure.
     72                  (++) Analog mode is required when a pin is to be used as ADC channel
     73                       or DAC output.
     74                  (++) In case of external interrupt/event selection the "Mode" member from
     75                       GPIO_InitTypeDef structure select the type (interrupt or event) and
     76                       the corresponding trigger event (rising or falling or both).
     77          
     78              (#) In case of external interrupt/event mode selection, configure NVIC IRQ priority
     79                  mapped to the EXTI line using HAL_NVIC_SetPriority() and enable it using
     80                  HAL_NVIC_EnableIRQ().
     81          
     82              (#) To get the level of a pin configured in input mode use HAL_GPIO_ReadPin().
     83          
     84              (#) To set/reset the level of a pin configured in output mode use
     85                  HAL_GPIO_WritePin()/HAL_GPIO_TogglePin().
     86          
     87             (#) To lock pin configuration until next reset use HAL_GPIO_LockPin().
     88          
     89              (#) During and just after reset, the alternate functions are not
     90                  active and the GPIO pins are configured in input floating mode (except JTAG
     91                  pins).
     92          
     93              (#) The LSE oscillator pins OSC32_IN and OSC32_OUT can be used as general purpose
     94                  (PC14 and PC15, respectively) when the LSE oscillator is off. The LSE has
     95                  priority over the GPIO function.
     96          
     97              (#) The HSE oscillator pins OSC_IN/OSC_OUT can be used as
     98                  general purpose PF0 and PF1, respectively, when the HSE oscillator is off.
     99                  The HSE has priority over the GPIO function.
    100          
    101            @endverbatim
    102            ******************************************************************************
    103            */
    104          
    105          /* Includes ------------------------------------------------------------------*/
    106          #include "stm32g0xx_hal.h"
    107          
    108          /** @addtogroup STM32G0xx_HAL_Driver
    109            * @{
    110            */
    111          
    112          /** @addtogroup GPIO
    113            * @{
    114            */
    115          /** MISRA C:2012 deviation rule has been granted for following rules:
    116            * Rule-12.2 - Medium: RHS argument is in interval [0,INF] which is out of
    117            * range of the shift operator in following API :
    118            * HAL_GPIO_Init
    119            * HAL_GPIO_DeInit
    120            */
    121          
    122          #ifdef HAL_GPIO_MODULE_ENABLED
    123          
    124          /* Private typedef -----------------------------------------------------------*/
    125          /* Private defines ------------------------------------------------------------*/
    126          /** @addtogroup GPIO_Private_Constants
    127            * @{
    128            */
    129          #define GPIO_NUMBER           (16u)
    130          /**
    131            * @}
    132            */
    133          
    134          /* Private macros ------------------------------------------------------------*/
    135          /* Private variables ---------------------------------------------------------*/
    136          /* Private function prototypes -----------------------------------------------*/
    137          /* Exported functions --------------------------------------------------------*/
    138          
    139          /** @addtogroup GPIO_Exported_Functions
    140            * @{
    141            */
    142          
    143          /** @addtogroup GPIO_Exported_Functions_Group1
    144           *  @brief    Initialization and Configuration functions
    145           *
    146          @verbatim
    147           ===============================================================================
    148                        ##### Initialization and de-initialization functions #####
    149           ===============================================================================
    150          
    151          @endverbatim
    152            * @{
    153            */
    154          
    155          /**
    156            * @brief  Initialize the GPIOx peripheral according to the specified parameters in the GPIO_Init.
    157            * @param  GPIOx where x can be (A..F) to select the GPIO peripheral for STM32G0xx family
    158            * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
    159            *         the configuration information for the specified GPIO peripheral.
    160            * @retval None
    161            */
    162          void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
    163          {
    164            uint32_t position = 0x00u;
    165            uint32_t iocurrent;
    166            uint32_t temp;
    167          
    168            /* Check the parameters */
    169            assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
    170            assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
    171            assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
    172          
    173            /* Configure the port pins */
    174            while (((GPIO_Init->Pin) >> position) != 0x00u)
    175            {
    176              /* Get current io position */
    177              iocurrent = (GPIO_Init->Pin) & (1uL << position);
    178          
    179              if (iocurrent != 0x00u)
    180              {
    181                /*--------------------- GPIO Mode Configuration ------------------------*/
    182                /* In case of Output or Alternate function mode selection */
    183                if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
    184                {
    185                  /* Check the Speed parameter */
    186                  assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
    187          
    188                  /* Configure the IO Speed */
    189                  temp = GPIOx->OSPEEDR;
    190                  temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2u));
    191                  temp |= (GPIO_Init->Speed << (position * 2u));
    192                  GPIOx->OSPEEDR = temp;
    193          
    194                  /* Configure the IO Output Type */
    195                  temp = GPIOx->OTYPER;
    196                  temp &= ~(GPIO_OTYPER_OT0 << position) ;
    197                  temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
    198                  GPIOx->OTYPER = temp;
    199                }
    200          
    201                if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
    202                {
    203                  /* Check the Pull parameter */
    204                  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
    205          
    206                  /* Activate the Pull-up or Pull down resistor for the current IO */
    207                  temp = GPIOx->PUPDR;
    208                  temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2u));
    209                  temp |= ((GPIO_Init->Pull) << (position * 2u));
    210                  GPIOx->PUPDR = temp;
    211                }
    212          
    213                /* In case of Alternate function mode selection */
    214                if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
    215                {
    216                  /* Check the Alternate function parameters */
    217                  assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
    218                  assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
    219          
    220                  /* Configure Alternate function mapped with the current IO */
    221                  temp = GPIOx->AFR[position >> 3u];
    222                  temp &= ~(0xFu << ((position & 0x07u) * 4u));
    223                  temp |= ((GPIO_Init->Alternate) << ((position & 0x07u) * 4u));
    224                  GPIOx->AFR[position >> 3u] = temp;
    225                }
    226          
    227                /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
    228                temp = GPIOx->MODER;
    229                temp &= ~(GPIO_MODER_MODE0 << (position * 2u));
    230                temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2u));
    231                GPIOx->MODER = temp;
    232          
    233                /*--------------------- EXTI Mode Configuration ------------------------*/
    234                /* Configure the External Interrupt or event for the current IO */
    235                if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
    236                {
    237                  temp = EXTI->EXTICR[position >> 2u];
    238                  temp &= ~(0x0FuL << (8u * (position & 0x03u)));
    239                  temp |= (GPIO_GET_INDEX(GPIOx) << (8u * (position & 0x03u)));
    240                  EXTI->EXTICR[position >> 2u] = temp;
    241          
    242                  /* Clear Rising Falling edge configuration */
    243                  temp = EXTI->RTSR1;
    244                  temp &= ~(iocurrent);
    245                  if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00u)
    246                  {
    247                    temp |= iocurrent;
    248                  }
    249                  EXTI->RTSR1 = temp;
    250          
    251                  temp = EXTI->FTSR1;
    252                  temp &= ~(iocurrent);
    253                  if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00u)
    254                  {
    255                    temp |= iocurrent;
    256                  }
    257                  EXTI->FTSR1 = temp;
    258          
    259                  /* Clear EXTI line configuration */
    260                  temp = EXTI->EMR1;
    261                  temp &= ~(iocurrent);
    262                  if ((GPIO_Init->Mode & EXTI_EVT) != 0x00u)
    263                  {
    264                    temp |= iocurrent;
    265                  }
    266                  EXTI->EMR1 = temp;
    267          
    268                  temp = EXTI->IMR1;
    269                  temp &= ~(iocurrent);
    270                  if ((GPIO_Init->Mode & EXTI_IT) != 0x00u)
    271                  {
    272                    temp |= iocurrent;
    273                  }
    274                  EXTI->IMR1 = temp;
    275                }
    276              }
    277          
    278              position++;
    279            }
    280          }
    281          
    282          /**
    283            * @brief  De-initialize the GPIOx peripheral registers to their default reset values.
    284            * @param  GPIOx where x can be (A..F) to select the GPIO peripheral for STM32G0xx family
    285            * @param  GPIO_Pin specifies the port bit to be written.
    286            *         This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
    287            * @retval None
    288            */
    289          void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
    290          {
    291            uint32_t position = 0x00u;
    292            uint32_t iocurrent;
    293            uint32_t tmp;
    294          
    295            /* Check the parameters */
    296            assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
    297            assert_param(IS_GPIO_PIN(GPIO_Pin));
    298          
    299            /* Configure the port pins */
    300            while ((GPIO_Pin >> position) != 0x00u)
    301            {
    302              /* Get current io position */
    303              iocurrent = (GPIO_Pin) & (1uL << position);
    304          
    305              if (iocurrent != 0x00u)
    306              {
    307                /*------------------------- EXTI Mode Configuration --------------------*/
    308                /* Clear the External Interrupt or Event for the current IO */
    309          
    310                tmp = EXTI->EXTICR[position >> 2u];
    311                tmp &= (0x0FuL << (8u * (position & 0x03u)));
    312                if (tmp == (GPIO_GET_INDEX(GPIOx) << (8u * (position & 0x03u))))
    313                {
    314                  /* Clear EXTI line configuration */
    315                  EXTI->IMR1 &= ~(iocurrent);
    316                  EXTI->EMR1 &= ~(iocurrent);
    317          
    318                  /* Clear Rising Falling edge configuration */
    319                  EXTI->FTSR1 &= ~(iocurrent);
    320                  EXTI->RTSR1 &= ~(iocurrent);
    321          
    322                  tmp = 0x0FuL << (8u * (position & 0x03u));
    323                  EXTI->EXTICR[position >> 2u] &= ~tmp;
    324                }
    325          
    326                /*------------------------- GPIO Mode Configuration --------------------*/
    327                /* Configure IO in Analog Mode */
    328                GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2u));
    329          
    330                /* Configure the default Alternate Function in current IO */
    331                GPIOx->AFR[position >> 3u] &= ~(0xFu << ((position & 0x07u) * 4u)) ;
    332          
    333                /* Configure the default value for IO Speed */
    334                GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2u));
    335          
    336                /* Configure the default value IO Output Type */
    337                GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT0 << position) ;
    338          
    339                /* Deactivate the Pull-up and Pull-down resistor for the current IO */
    340                GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * 2u));
    341              }
    342          
    343              position++;
    344            }
    345          }
    346          
    347          /**
    348            * @}
    349            */
    350          
    351          /** @addtogroup GPIO_Exported_Functions_Group2
    352           *  @brief GPIO Read, Write, Toggle, Lock and EXTI management functions.
    353           *
    354          @verbatim
    355           ===============================================================================
    356                                 ##### IO operation functions #####
    357           ===============================================================================
    358          
    359          @endverbatim
    360            * @{
    361            */
    362          
    363          /**
    364            * @brief  Read the specified input port pin.
    365            * @param  GPIOx where x can be (A..F) to select the GPIO peripheral for STM32G0xx family
    366            * @param  GPIO_Pin specifies the port bit to read.
    367            *         This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
    368            * @retval The input port pin value.
    369            */
    370          GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
    371          {
    372            GPIO_PinState bitstatus;
    373          
    374            /* Check the parameters */
    375            assert_param(IS_GPIO_PIN(GPIO_Pin));
    376          
    377            if ((GPIOx->IDR & GPIO_Pin) != 0x00u)
    378            {
    379              bitstatus = GPIO_PIN_SET;
    380            }
    381            else
    382            {
    383              bitstatus = GPIO_PIN_RESET;
    384            }
    385            return bitstatus;
    386          }
    387          
    388          /**
    389            * @brief  Set or clear the selected data port bit.
    390            *
    391            * @note   This function uses GPIOx_BSRR and GPIOx_BRR registers to allow atomic read/modify
    392            *         accesses. In this way, there is no risk of an IRQ occurring between
    393            *         the read and the modify access.
    394            *
    395            * @param  GPIOx where x can be (A..F) to select the GPIO peripheral for STM32G0xx family
    396            * @param  GPIO_Pin specifies the port bit to be written.
    397            *         This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
    398            * @param  PinState specifies the value to be written to the selected bit.
    399            *         This parameter can be one of the GPIO_PinState enum values:
    400            *            @arg GPIO_PIN_RESET: to clear the port pin
    401            *            @arg GPIO_PIN_SET: to set the port pin
    402            * @retval None
    403            */
    404          void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
    405          {
    406            /* Check the parameters */
    407            assert_param(IS_GPIO_PIN(GPIO_Pin));
    408            assert_param(IS_GPIO_PIN_ACTION(PinState));
    409          
    410            if (PinState != GPIO_PIN_RESET)
    411            {
    412              GPIOx->BSRR = (uint32_t)GPIO_Pin;
    413            }
    414            else
    415            {
    416              GPIOx->BRR = (uint32_t)GPIO_Pin;
    417            }
    418          }
    419          
    420          /**
    421            * @brief  Toggle the specified GPIO pin.
    422            * @param  GPIOx where x can be (A..F) to select the GPIO peripheral for STM32G0xx family
    423            * @param  GPIO_Pin specifies the pin to be toggled.
    424            *         This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
    425            * @retval None
    426            */
    427          void HAL_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
    428          {
    429            uint32_t odr;
    430          
    431            /* Check the parameters */
    432            assert_param(IS_GPIO_PIN(GPIO_Pin));
    433          
    434            /* get current Output Data Register value */
    435            odr = GPIOx->ODR;
    436          
    437            /* Set selected pins that were at low level, and reset ones that were high */
    438            GPIOx->BSRR = ((odr & GPIO_Pin) << GPIO_NUMBER) | (~odr & GPIO_Pin);
    439          }
    440          
    441          /**
    442          * @brief  Lock GPIO Pins configuration registers.
    443            * @note   The locked registers are GPIOx_MODER, GPIOx_OTYPER, GPIOx_OSPEEDR,
    444            *         GPIOx_PUPDR, GPIOx_AFRL and GPIOx_AFRH.
    445            * @note   The configuration of the locked GPIO pins can no longer be modified
    446            *         until the next reset.
    447            * @param  GPIOx where x can be (A..F) to select the GPIO peripheral for STM32G0xx family
    448            * @param  GPIO_Pin specifies the port bits to be locked.
    449            *         This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
    450            * @retval None
    451            */
    452          HAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
    453          {
    454            __IO uint32_t tmp = GPIO_LCKR_LCKK;
    455          
    456            /* Check the parameters */
    457            assert_param(IS_GPIO_LOCK_INSTANCE(GPIOx));
    458            assert_param(IS_GPIO_PIN(GPIO_Pin));
    459          
    460            /* Apply lock key write sequence */
    461            tmp |= GPIO_Pin;
    462            /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
    463            GPIOx->LCKR = tmp;
    464            /* Reset LCKx bit(s): LCKK='0' + LCK[15-0] */
    465            GPIOx->LCKR = GPIO_Pin;
    466            /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
    467            GPIOx->LCKR = tmp;
    468            /* Read LCKK register. This read is mandatory to complete key lock sequence */
    469            tmp = GPIOx->LCKR;
    470          
    471            /* read again in order to confirm lock is active */
    472            if ((GPIOx->LCKR & GPIO_LCKR_LCKK) != 0x00u)
    473            {
    474              return HAL_OK;
    475            }
    476            else
    477            {
    478              return HAL_ERROR;
    479            }
    480          }
    481          
    482          /**
    483            * @brief  Handle EXTI interrupt request.
    484            * @param  GPIO_Pin Specifies the port pin connected to corresponding EXTI line.
    485            * @retval None
    486            */
    487          void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
    488          {
    489            /* EXTI line interrupt detected */
    490            if (__HAL_GPIO_EXTI_GET_RISING_IT(GPIO_Pin) != 0x00u)
    491            {
    492              __HAL_GPIO_EXTI_CLEAR_RISING_IT(GPIO_Pin);
    493              HAL_GPIO_EXTI_Rising_Callback(GPIO_Pin);
    494            }
    495          
    496            if (__HAL_GPIO_EXTI_GET_FALLING_IT(GPIO_Pin) != 0x00u)
    497            {
    498              __HAL_GPIO_EXTI_CLEAR_FALLING_IT(GPIO_Pin);
    499              HAL_GPIO_EXTI_Falling_Callback(GPIO_Pin);
    500            }
    501          }
    502          
    503          /**
    504            * @brief  EXTI line detection callback.
    505            * @param  GPIO_Pin Specifies the port pin connected to corresponding EXTI line.
    506            * @retval None
    507            */
    508          __weak void HAL_GPIO_EXTI_Rising_Callback(uint16_t GPIO_Pin)
    509          {
    510            /* Prevent unused argument(s) compilation warning */
    511            UNUSED(GPIO_Pin);
    512          
    513            /* NOTE: This function should not be modified, when the callback is needed,
    514                     the HAL_GPIO_EXTI_Rising_Callback could be implemented in the user file
    515             */
    516          }
    517          
    518          /**
    519            * @brief  EXTI line detection callback.
    520            * @param  GPIO_Pin Specifies the port pin connected to corresponding EXTI line.
    521            * @retval None
    522            */
    523          __weak void HAL_GPIO_EXTI_Falling_Callback(uint16_t GPIO_Pin)
    524          {
    525            /* Prevent unused argument(s) compilation warning */
    526            UNUSED(GPIO_Pin);
    527          
    528            /* NOTE: This function should not be modified, when the callback is needed,
    529                     the HAL_GPIO_EXTI_Falling_Callback could be implemented in the user file
    530             */
    531          }
    532          
    533          /**
    534            * @}
    535            */
    536          
    537          
    538          /**
    539            * @}
    540            */
    541          
    542          #endif /* HAL_GPIO_MODULE_ENABLED */
    543          /**
    544            * @}
    545            */
    546          
    547          /**
    548            * @}
    549            */
    550          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   HAL_GPIO_DeInit
       0   HAL_GPIO_EXTI_Falling_Callback
      16   HAL_GPIO_EXTI_IRQHandler
        16   -> HAL_GPIO_EXTI_Falling_Callback
        16   -> HAL_GPIO_EXTI_Rising_Callback
       0   HAL_GPIO_EXTI_Rising_Callback
      36   HAL_GPIO_Init
       4   HAL_GPIO_LockPin
       0   HAL_GPIO_ReadPin
       0   HAL_GPIO_TogglePin
       0   HAL_GPIO_WritePin


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
     260  HAL_GPIO_DeInit
       2  HAL_GPIO_EXTI_Falling_Callback
      38  HAL_GPIO_EXTI_IRQHandler
       2  HAL_GPIO_EXTI_Rising_Callback
     364  HAL_GPIO_Init
      42  HAL_GPIO_LockPin
      12  HAL_GPIO_ReadPin
      16  HAL_GPIO_TogglePin
      12  HAL_GPIO_WritePin

 
 780 bytes in section .text
 
 776 bytes of CODE memory (+ 4 bytes shared)

Errors: none
Warnings: none
