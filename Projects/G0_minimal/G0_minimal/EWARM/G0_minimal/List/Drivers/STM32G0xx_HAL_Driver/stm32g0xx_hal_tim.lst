###############################################################################
#
# IAR ANSI C/C++ Compiler V9.20.1.318/W64 for ARM         20/Aug/2025  11:20:08
# Copyright 1999-2021 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\Drivers\STM32G0xx_HAL_Driver\Src\stm32g0xx_hal_tim.c
#    Command line      =
#        -f
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM\G0_minimal\Obj\Drivers\STM32G0xx_HAL_Driver\stm32g0xx_hal_tim.o.rsp
#        (C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\Drivers\STM32G0xx_HAL_Driver\Src\stm32g0xx_hal_tim.c
#        -D USE_HAL_DRIVER -D STM32G0B1xx -lcN
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM\G0_minimal\List\Drivers\STM32G0xx_HAL_Driver
#        -o
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM\G0_minimal\Obj\Drivers\STM32G0xx_HAL_Driver
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ -e --fpu=None --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.0\arm\inc\c\DLib_Config_Full.h" -I
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM/../Core/Inc\ -I
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM/../ST67W6X/Target\
#        -I
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM/../ST67W6X/Drivers\
#        -I
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM/../Drivers/STM32G0xx_HAL_Driver/Inc\
#        -I
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM/../Drivers/STM32G0xx_HAL_Driver/Inc/Legacy\
#        -I
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM/../Drivers/CMSIS/Device/ST/STM32G0xx/Include\
#        -I
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM/../Drivers/CMSIS/Include\
#        -On) --dependencies=n
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM\G0_minimal\Obj\Drivers\STM32G0xx_HAL_Driver\stm32g0xx_hal_tim.o.d
#    Locale            =  C
#    List file         =
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM\G0_minimal\List\Drivers\STM32G0xx_HAL_Driver\stm32g0xx_hal_tim.lst
#    Object file       =
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM\G0_minimal\Obj\Drivers\STM32G0xx_HAL_Driver\stm32g0xx_hal_tim.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\Drivers\STM32G0xx_HAL_Driver\Src\stm32g0xx_hal_tim.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32g0xx_hal_tim.c
      4            * @author  MCD Application Team
      5            * @brief   TIM HAL module driver.
      6            *          This file provides firmware functions to manage the following
      7            *          functionalities of the Timer (TIM) peripheral:
      8            *           + TIM Time Base Initialization
      9            *           + TIM Time Base Start
     10            *           + TIM Time Base Start Interruption
     11            *           + TIM Time Base Start DMA
     12            *           + TIM Output Compare/PWM Initialization
     13            *           + TIM Output Compare/PWM Channel Configuration
     14            *           + TIM Output Compare/PWM  Start
     15            *           + TIM Output Compare/PWM  Start Interruption
     16            *           + TIM Output Compare/PWM Start DMA
     17            *           + TIM Input Capture Initialization
     18            *           + TIM Input Capture Channel Configuration
     19            *           + TIM Input Capture Start
     20            *           + TIM Input Capture Start Interruption
     21            *           + TIM Input Capture Start DMA
     22            *           + TIM One Pulse Initialization
     23            *           + TIM One Pulse Channel Configuration
     24            *           + TIM One Pulse Start
     25            *           + TIM Encoder Interface Initialization
     26            *           + TIM Encoder Interface Start
     27            *           + TIM Encoder Interface Start Interruption
     28            *           + TIM Encoder Interface Start DMA
     29            *           + Commutation Event configuration with Interruption and DMA
     30            *           + TIM OCRef clear configuration
     31            *           + TIM External Clock configuration
     32            ******************************************************************************
     33            * @attention
     34            *
     35            * Copyright (c) 2018 STMicroelectronics.
     36            * All rights reserved.
     37            *
     38            * This software is licensed under terms that can be found in the LICENSE file
     39            * in the root directory of this software component.
     40            * If no LICENSE file comes with this software, it is provided AS-IS.
     41            *
     42            ******************************************************************************
     43            @verbatim
     44            ==============================================================================
     45                                ##### TIMER Generic features #####
     46            ==============================================================================
     47            [..] The Timer features include:
     48                 (#) 16-bit up, down, up/down auto-reload counter.
     49                 (#) 16-bit programmable prescaler allowing dividing (also on the fly) the
     50                     counter clock frequency either by any factor between 1 and 65536.
     51                 (#) Up to 4 independent channels for:
     52                     (++) Input Capture
     53                     (++) Output Compare
     54                     (++) PWM generation (Edge and Center-aligned Mode)
     55                     (++) One-pulse mode output
     56                 (#) Synchronization circuit to control the timer with external signals and to interconnect
     57                      several timers together.
     58                 (#) Supports incremental encoder for positioning purposes
     59          
     60                      ##### How to use this driver #####
     61            ==============================================================================
     62              [..]
     63               (#) Initialize the TIM low level resources by implementing the following functions
     64                   depending on the selected feature:
     65                     (++) Time Base : HAL_TIM_Base_MspInit()
     66                     (++) Input Capture : HAL_TIM_IC_MspInit()
     67                     (++) Output Compare : HAL_TIM_OC_MspInit()
     68                     (++) PWM generation : HAL_TIM_PWM_MspInit()
     69                     (++) One-pulse mode output : HAL_TIM_OnePulse_MspInit()
     70                     (++) Encoder mode output : HAL_TIM_Encoder_MspInit()
     71          
     72               (#) Initialize the TIM low level resources :
     73                  (##) Enable the TIM interface clock using __HAL_RCC_TIMx_CLK_ENABLE();
     74                  (##) TIM pins configuration
     75                      (+++) Enable the clock for the TIM GPIOs using the following function:
     76                       __HAL_RCC_GPIOx_CLK_ENABLE();
     77                      (+++) Configure these TIM pins in Alternate function mode using HAL_GPIO_Init();
     78          
     79               (#) The external Clock can be configured, if needed (the default clock is the
     80                   internal clock from the APBx), using the following function:
     81                   HAL_TIM_ConfigClockSource, the clock configuration should be done before
     82                   any start function.
     83          
     84               (#) Configure the TIM in the desired functioning mode using one of the
     85                 Initialization function of this driver:
     86                 (++) HAL_TIM_Base_Init: to use the Timer to generate a simple time base
     87                 (++) HAL_TIM_OC_Init and HAL_TIM_OC_ConfigChannel: to use the Timer to generate an
     88                      Output Compare signal.
     89                 (++) HAL_TIM_PWM_Init and HAL_TIM_PWM_ConfigChannel: to use the Timer to generate a
     90                      PWM signal.
     91                 (++) HAL_TIM_IC_Init and HAL_TIM_IC_ConfigChannel: to use the Timer to measure an
     92                      external signal.
     93                 (++) HAL_TIM_OnePulse_Init and HAL_TIM_OnePulse_ConfigChannel: to use the Timer
     94                      in One Pulse Mode.
     95                 (++) HAL_TIM_Encoder_Init: to use the Timer Encoder Interface.
     96          
     97               (#) Activate the TIM peripheral using one of the start functions depending from the feature used:
     98                     (++) Time Base : HAL_TIM_Base_Start(), HAL_TIM_Base_Start_DMA(), HAL_TIM_Base_Start_IT()
     99                     (++) Input Capture :  HAL_TIM_IC_Start(), HAL_TIM_IC_Start_DMA(), HAL_TIM_IC_Start_IT()
    100                     (++) Output Compare : HAL_TIM_OC_Start(), HAL_TIM_OC_Start_DMA(), HAL_TIM_OC_Start_IT()
    101                     (++) PWM generation : HAL_TIM_PWM_Start(), HAL_TIM_PWM_Start_DMA(), HAL_TIM_PWM_Start_IT()
    102                     (++) One-pulse mode output : HAL_TIM_OnePulse_Start(), HAL_TIM_OnePulse_Start_IT()
    103                     (++) Encoder mode output : HAL_TIM_Encoder_Start(), HAL_TIM_Encoder_Start_DMA(), HAL_TIM_Encoder_Start_IT().
    104          
    105               (#) The DMA Burst is managed with the two following functions:
    106                   HAL_TIM_DMABurst_WriteStart()
    107                   HAL_TIM_DMABurst_ReadStart()
    108          
    109              *** Callback registration ***
    110            =============================================
    111          
    112            [..]
    113            The compilation define  USE_HAL_TIM_REGISTER_CALLBACKS when set to 1
    114            allows the user to configure dynamically the driver callbacks.
    115          
    116            [..]
    117            Use Function HAL_TIM_RegisterCallback() to register a callback.
    118            HAL_TIM_RegisterCallback() takes as parameters the HAL peripheral handle,
    119            the Callback ID and a pointer to the user callback function.
    120          
    121            [..]
    122            Use function HAL_TIM_UnRegisterCallback() to reset a callback to the default
    123            weak function.
    124            HAL_TIM_UnRegisterCallback takes as parameters the HAL peripheral handle,
    125            and the Callback ID.
    126          
    127            [..]
    128            These functions allow to register/unregister following callbacks:
    129              (+) Base_MspInitCallback              : TIM Base Msp Init Callback.
    130              (+) Base_MspDeInitCallback            : TIM Base Msp DeInit Callback.
    131              (+) IC_MspInitCallback                : TIM IC Msp Init Callback.
    132              (+) IC_MspDeInitCallback              : TIM IC Msp DeInit Callback.
    133              (+) OC_MspInitCallback                : TIM OC Msp Init Callback.
    134              (+) OC_MspDeInitCallback              : TIM OC Msp DeInit Callback.
    135              (+) PWM_MspInitCallback               : TIM PWM Msp Init Callback.
    136              (+) PWM_MspDeInitCallback             : TIM PWM Msp DeInit Callback.
    137              (+) OnePulse_MspInitCallback          : TIM One Pulse Msp Init Callback.
    138              (+) OnePulse_MspDeInitCallback        : TIM One Pulse Msp DeInit Callback.
    139              (+) Encoder_MspInitCallback           : TIM Encoder Msp Init Callback.
    140              (+) Encoder_MspDeInitCallback         : TIM Encoder Msp DeInit Callback.
    141              (+) HallSensor_MspInitCallback        : TIM Hall Sensor Msp Init Callback.
    142              (+) HallSensor_MspDeInitCallback      : TIM Hall Sensor Msp DeInit Callback.
    143              (+) PeriodElapsedCallback             : TIM Period Elapsed Callback.
    144              (+) PeriodElapsedHalfCpltCallback     : TIM Period Elapsed half complete Callback.
    145              (+) TriggerCallback                   : TIM Trigger Callback.
    146              (+) TriggerHalfCpltCallback           : TIM Trigger half complete Callback.
    147              (+) IC_CaptureCallback                : TIM Input Capture Callback.
    148              (+) IC_CaptureHalfCpltCallback        : TIM Input Capture half complete Callback.
    149              (+) OC_DelayElapsedCallback           : TIM Output Compare Delay Elapsed Callback.
    150              (+) PWM_PulseFinishedCallback         : TIM PWM Pulse Finished Callback.
    151              (+) PWM_PulseFinishedHalfCpltCallback : TIM PWM Pulse Finished half complete Callback.
    152              (+) ErrorCallback                     : TIM Error Callback.
    153              (+) CommutationCallback               : TIM Commutation Callback.
    154              (+) CommutationHalfCpltCallback       : TIM Commutation half complete Callback.
    155              (+) BreakCallback                     : TIM Break Callback.
    156              (+) Break2Callback                    : TIM Break2 Callback.
    157          
    158            [..]
    159          By default, after the Init and when the state is HAL_TIM_STATE_RESET
    160          all interrupt callbacks are set to the corresponding weak functions:
    161            examples HAL_TIM_TriggerCallback(), HAL_TIM_ErrorCallback().
    162          
    163            [..]
    164            Exception done for MspInit and MspDeInit functions that are reset to the legacy weak
    165            functionalities in the Init / DeInit only when these callbacks are null
    166            (not registered beforehand). If not, MspInit or MspDeInit are not null, the Init / DeInit
    167              keep and use the user MspInit / MspDeInit callbacks(registered beforehand)
    168          
    169            [..]
    170              Callbacks can be registered / unregistered in HAL_TIM_STATE_READY state only.
    171              Exception done MspInit / MspDeInit that can be registered / unregistered
    172              in HAL_TIM_STATE_READY or HAL_TIM_STATE_RESET state,
    173              thus registered(user) MspInit / DeInit callbacks can be used during the Init / DeInit.
    174            In that case first register the MspInit/MspDeInit user callbacks
    175                using HAL_TIM_RegisterCallback() before calling DeInit or Init function.
    176          
    177            [..]
    178                When The compilation define USE_HAL_TIM_REGISTER_CALLBACKS is set to 0 or
    179                not defined, the callback registration feature is not available and all callbacks
    180                are set to the corresponding weak functions.
    181          
    182            @endverbatim
    183            ******************************************************************************
    184            */
    185          
    186          /* Includes ------------------------------------------------------------------*/
    187          #include "stm32g0xx_hal.h"
    188          
    189          /** @addtogroup STM32G0xx_HAL_Driver
    190            * @{
    191            */
    192          
    193          /** @defgroup TIM TIM
    194            * @brief TIM HAL module driver
    195            * @{
    196            */
    197          
    198          #ifdef HAL_TIM_MODULE_ENABLED
    199          
    200          /* Private typedef -----------------------------------------------------------*/
    201          /* Private define ------------------------------------------------------------*/
    202          /** @addtogroup TIM_Private_Constants
    203            * @{
    204            */
    205          #define TIMx_OR1_OCREF_CLR 0x00000001U
    206          /**
    207            * @}
    208            */
    209          
    210          /* Private macros ------------------------------------------------------------*/
    211          /* Private variables ---------------------------------------------------------*/
    212          /* Private function prototypes -----------------------------------------------*/
    213          /** @addtogroup TIM_Private_Functions
    214            * @{
    215            */
    216          static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, const TIM_OC_InitTypeDef *OC_Config);
    217          static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, const TIM_OC_InitTypeDef *OC_Config);
    218          static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, const TIM_OC_InitTypeDef *OC_Config);
    219          static void TIM_OC5_SetConfig(TIM_TypeDef *TIMx, const TIM_OC_InitTypeDef *OC_Config);
    220          static void TIM_OC6_SetConfig(TIM_TypeDef *TIMx, const TIM_OC_InitTypeDef *OC_Config);
    221          static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter);
    222          static void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
    223                                        uint32_t TIM_ICFilter);
    224          static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter);
    225          static void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
    226                                        uint32_t TIM_ICFilter);
    227          static void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
    228                                        uint32_t TIM_ICFilter);
    229          static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint32_t InputTriggerSource);
    230          static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma);
    231          static void TIM_DMAPeriodElapsedHalfCplt(DMA_HandleTypeDef *hdma);
    232          static void TIM_DMADelayPulseCplt(DMA_HandleTypeDef *hdma);
    233          static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma);
    234          static void TIM_DMATriggerHalfCplt(DMA_HandleTypeDef *hdma);
    235          static HAL_StatusTypeDef TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,
    236                                                            const TIM_SlaveConfigTypeDef *sSlaveConfig);
    237          /**
    238            * @}
    239            */
    240          /* Exported functions --------------------------------------------------------*/
    241          
    242          /** @defgroup TIM_Exported_Functions TIM Exported Functions
    243            * @{
    244            */
    245          
    246          /** @defgroup TIM_Exported_Functions_Group1 TIM Time Base functions
    247            *  @brief    Time Base functions
    248            *
    249          @verbatim
    250            ==============================================================================
    251                        ##### Time Base functions #####
    252            ==============================================================================
    253            [..]
    254              This section provides functions allowing to:
    255              (+) Initialize and configure the TIM base.
    256              (+) De-initialize the TIM base.
    257              (+) Start the Time Base.
    258              (+) Stop the Time Base.
    259              (+) Start the Time Base and enable interrupt.
    260              (+) Stop the Time Base and disable interrupt.
    261              (+) Start the Time Base and enable DMA transfer.
    262              (+) Stop the Time Base and disable DMA transfer.
    263          
    264          @endverbatim
    265            * @{
    266            */
    267          /**
    268            * @brief  Initializes the TIM Time base Unit according to the specified
    269            *         parameters in the TIM_HandleTypeDef and initialize the associated handle.
    270            * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
    271            *         requires a timer reset to avoid unexpected direction
    272            *         due to DIR bit readonly in center aligned mode.
    273            *         Ex: call @ref HAL_TIM_Base_DeInit() before HAL_TIM_Base_Init()
    274            * @param  htim TIM Base handle
    275            * @retval HAL status
    276            */
    277          HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
    278          {
    279            /* Check the TIM handle allocation */
    280            if (htim == NULL)
    281            {
    282              return HAL_ERROR;
    283            }
    284          
    285            /* Check the parameters */
    286            assert_param(IS_TIM_INSTANCE(htim->Instance));
    287            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
    288            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
    289            assert_param(IS_TIM_PERIOD(htim, htim->Init.Period));
    290            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
    291          
    292            if (htim->State == HAL_TIM_STATE_RESET)
    293            {
    294              /* Allocate lock resource and initialize it */
    295              htim->Lock = HAL_UNLOCKED;
    296          
    297          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
    298              /* Reset interrupt callbacks to legacy weak callbacks */
    299              TIM_ResetCallback(htim);
    300          
    301              if (htim->Base_MspInitCallback == NULL)
    302              {
    303                htim->Base_MspInitCallback = HAL_TIM_Base_MspInit;
    304              }
    305              /* Init the low level hardware : GPIO, CLOCK, NVIC */
    306              htim->Base_MspInitCallback(htim);
    307          #else
    308              /* Init the low level hardware : GPIO, CLOCK, NVIC */
    309              HAL_TIM_Base_MspInit(htim);
    310          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    311            }
    312          
    313            /* Set the TIM state */
    314            htim->State = HAL_TIM_STATE_BUSY;
    315          
    316            /* Set the Time Base configuration */
    317            TIM_Base_SetConfig(htim->Instance, &htim->Init);
    318          
    319            /* Initialize the DMA burst operation state */
    320            htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
    321          
    322            /* Initialize the TIM channels state */
    323            TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
    324            TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
    325          
    326            /* Initialize the TIM state*/
    327            htim->State = HAL_TIM_STATE_READY;
    328          
    329            return HAL_OK;
    330          }
    331          
    332          /**
    333            * @brief  DeInitializes the TIM Base peripheral
    334            * @param  htim TIM Base handle
    335            * @retval HAL status
    336            */
    337          HAL_StatusTypeDef HAL_TIM_Base_DeInit(TIM_HandleTypeDef *htim)
    338          {
    339            /* Check the parameters */
    340            assert_param(IS_TIM_INSTANCE(htim->Instance));
    341          
    342            htim->State = HAL_TIM_STATE_BUSY;
    343          
    344            /* Disable the TIM Peripheral Clock */
    345            __HAL_TIM_DISABLE(htim);
    346          
    347          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
    348            if (htim->Base_MspDeInitCallback == NULL)
    349            {
    350              htim->Base_MspDeInitCallback = HAL_TIM_Base_MspDeInit;
    351            }
    352            /* DeInit the low level hardware */
    353            htim->Base_MspDeInitCallback(htim);
    354          #else
    355            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
    356            HAL_TIM_Base_MspDeInit(htim);
    357          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    358          
    359            /* Change the DMA burst operation state */
    360            htim->DMABurstState = HAL_DMA_BURST_STATE_RESET;
    361          
    362            /* Change the TIM channels state */
    363            TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);
    364            TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);
    365          
    366            /* Change TIM state */
    367            htim->State = HAL_TIM_STATE_RESET;
    368          
    369            /* Release Lock */
    370            __HAL_UNLOCK(htim);
    371          
    372            return HAL_OK;
    373          }
    374          
    375          /**
    376            * @brief  Initializes the TIM Base MSP.
    377            * @param  htim TIM Base handle
    378            * @retval None
    379            */
    380          __weak void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)
    381          {
    382            /* Prevent unused argument(s) compilation warning */
    383            UNUSED(htim);
    384          
    385            /* NOTE : This function should not be modified, when the callback is needed,
    386                      the HAL_TIM_Base_MspInit could be implemented in the user file
    387             */
    388          }
    389          
    390          /**
    391            * @brief  DeInitializes TIM Base MSP.
    392            * @param  htim TIM Base handle
    393            * @retval None
    394            */
    395          __weak void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef *htim)
    396          {
    397            /* Prevent unused argument(s) compilation warning */
    398            UNUSED(htim);
    399          
    400            /* NOTE : This function should not be modified, when the callback is needed,
    401                      the HAL_TIM_Base_MspDeInit could be implemented in the user file
    402             */
    403          }
    404          
    405          
    406          /**
    407            * @brief  Starts the TIM Base generation.
    408            * @param  htim TIM Base handle
    409            * @retval HAL status
    410            */
    411          HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim)
    412          {
    413            uint32_t tmpsmcr;
    414          
    415            /* Check the parameters */
    416            assert_param(IS_TIM_INSTANCE(htim->Instance));
    417          
    418            /* Check the TIM state */
    419            if (htim->State != HAL_TIM_STATE_READY)
    420            {
    421              return HAL_ERROR;
    422            }
    423          
    424            /* Set the TIM state */
    425            htim->State = HAL_TIM_STATE_BUSY;
    426          
    427            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    428            if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
    429            {
    430              tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
    431              if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
    432              {
    433                __HAL_TIM_ENABLE(htim);
    434              }
    435            }
    436            else
    437            {
    438              __HAL_TIM_ENABLE(htim);
    439            }
    440          
    441            /* Return function status */
    442            return HAL_OK;
    443          }
    444          
    445          /**
    446            * @brief  Stops the TIM Base generation.
    447            * @param  htim TIM Base handle
    448            * @retval HAL status
    449            */
    450          HAL_StatusTypeDef HAL_TIM_Base_Stop(TIM_HandleTypeDef *htim)
    451          {
    452            /* Check the parameters */
    453            assert_param(IS_TIM_INSTANCE(htim->Instance));
    454          
    455            /* Disable the Peripheral */
    456            __HAL_TIM_DISABLE(htim);
    457          
    458            /* Set the TIM state */
    459            htim->State = HAL_TIM_STATE_READY;
    460          
    461            /* Return function status */
    462            return HAL_OK;
    463          }
    464          
    465          /**
    466            * @brief  Starts the TIM Base generation in interrupt mode.
    467            * @param  htim TIM Base handle
    468            * @retval HAL status
    469            */
    470          HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
    471          {
    472            uint32_t tmpsmcr;
    473          
    474            /* Check the parameters */
    475            assert_param(IS_TIM_INSTANCE(htim->Instance));
    476          
    477            /* Check the TIM state */
    478            if (htim->State != HAL_TIM_STATE_READY)
    479            {
    480              return HAL_ERROR;
    481            }
    482          
    483            /* Set the TIM state */
    484            htim->State = HAL_TIM_STATE_BUSY;
    485          
    486            /* Enable the TIM Update interrupt */
    487            __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
    488          
    489            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    490            if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
    491            {
    492              tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
    493              if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
    494              {
    495                __HAL_TIM_ENABLE(htim);
    496              }
    497            }
    498            else
    499            {
    500              __HAL_TIM_ENABLE(htim);
    501            }
    502          
    503            /* Return function status */
    504            return HAL_OK;
    505          }
    506          
    507          /**
    508            * @brief  Stops the TIM Base generation in interrupt mode.
    509            * @param  htim TIM Base handle
    510            * @retval HAL status
    511            */
    512          HAL_StatusTypeDef HAL_TIM_Base_Stop_IT(TIM_HandleTypeDef *htim)
    513          {
    514            /* Check the parameters */
    515            assert_param(IS_TIM_INSTANCE(htim->Instance));
    516          
    517            /* Disable the TIM Update interrupt */
    518            __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
    519          
    520            /* Disable the Peripheral */
    521            __HAL_TIM_DISABLE(htim);
    522          
    523            /* Set the TIM state */
    524            htim->State = HAL_TIM_STATE_READY;
    525          
    526            /* Return function status */
    527            return HAL_OK;
    528          }
    529          
    530          /**
    531            * @brief  Starts the TIM Base generation in DMA mode.
    532            * @param  htim TIM Base handle
    533            * @param  pData The source Buffer address.
    534            * @param  Length The length of data to be transferred from memory to peripheral.
    535            * @retval HAL status
    536            */
    537          HAL_StatusTypeDef HAL_TIM_Base_Start_DMA(TIM_HandleTypeDef *htim, const uint32_t *pData, uint16_t Length)
    538          {
    539            uint32_t tmpsmcr;
    540          
    541            /* Check the parameters */
    542            assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
    543          
    544            /* Set the TIM state */
    545            if (htim->State == HAL_TIM_STATE_BUSY)
    546            {
    547              return HAL_BUSY;
    548            }
    549            else if (htim->State == HAL_TIM_STATE_READY)
    550            {
    551              if ((pData == NULL) || (Length == 0U))
    552              {
    553                return HAL_ERROR;
    554              }
    555              else
    556              {
    557                htim->State = HAL_TIM_STATE_BUSY;
    558              }
    559            }
    560            else
    561            {
    562              return HAL_ERROR;
    563            }
    564          
    565            /* Set the DMA Period elapsed callbacks */
    566            htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
    567            htim->hdma[TIM_DMA_ID_UPDATE]->XferHalfCpltCallback = TIM_DMAPeriodElapsedHalfCplt;
    568          
    569            /* Set the DMA error callback */
    570            htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
    571          
    572            /* Enable the DMA channel */
    573            if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)pData, (uint32_t)&htim->Instance->ARR,
    574                                 Length) != HAL_OK)
    575            {
    576              /* Return error status */
    577              return HAL_ERROR;
    578            }
    579          
    580            /* Enable the TIM Update DMA request */
    581            __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_UPDATE);
    582          
    583            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    584            if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
    585            {
    586              tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
    587              if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
    588              {
    589                __HAL_TIM_ENABLE(htim);
    590              }
    591            }
    592            else
    593            {
    594              __HAL_TIM_ENABLE(htim);
    595            }
    596          
    597            /* Return function status */
    598            return HAL_OK;
    599          }
    600          
    601          /**
    602            * @brief  Stops the TIM Base generation in DMA mode.
    603            * @param  htim TIM Base handle
    604            * @retval HAL status
    605            */
    606          HAL_StatusTypeDef HAL_TIM_Base_Stop_DMA(TIM_HandleTypeDef *htim)
    607          {
    608            /* Check the parameters */
    609            assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
    610          
    611            /* Disable the TIM Update DMA request */
    612            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_UPDATE);
    613          
    614            (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_UPDATE]);
    615          
    616            /* Disable the Peripheral */
    617            __HAL_TIM_DISABLE(htim);
    618          
    619            /* Set the TIM state */
    620            htim->State = HAL_TIM_STATE_READY;
    621          
    622            /* Return function status */
    623            return HAL_OK;
    624          }
    625          
    626          /**
    627            * @}
    628            */
    629          
    630          /** @defgroup TIM_Exported_Functions_Group2 TIM Output Compare functions
    631            *  @brief    TIM Output Compare functions
    632            *
    633          @verbatim
    634            ==============================================================================
    635                            ##### TIM Output Compare functions #####
    636            ==============================================================================
    637            [..]
    638              This section provides functions allowing to:
    639              (+) Initialize and configure the TIM Output Compare.
    640              (+) De-initialize the TIM Output Compare.
    641              (+) Start the TIM Output Compare.
    642              (+) Stop the TIM Output Compare.
    643              (+) Start the TIM Output Compare and enable interrupt.
    644              (+) Stop the TIM Output Compare and disable interrupt.
    645              (+) Start the TIM Output Compare and enable DMA transfer.
    646              (+) Stop the TIM Output Compare and disable DMA transfer.
    647          
    648          @endverbatim
    649            * @{
    650            */
    651          /**
    652            * @brief  Initializes the TIM Output Compare according to the specified
    653            *         parameters in the TIM_HandleTypeDef and initializes the associated handle.
    654            * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
    655            *         requires a timer reset to avoid unexpected direction
    656            *         due to DIR bit readonly in center aligned mode.
    657            *         Ex: call @ref HAL_TIM_OC_DeInit() before HAL_TIM_OC_Init()
    658            * @param  htim TIM Output Compare handle
    659            * @retval HAL status
    660            */
    661          HAL_StatusTypeDef HAL_TIM_OC_Init(TIM_HandleTypeDef *htim)
    662          {
    663            /* Check the TIM handle allocation */
    664            if (htim == NULL)
    665            {
    666              return HAL_ERROR;
    667            }
    668          
    669            /* Check the parameters */
    670            assert_param(IS_TIM_INSTANCE(htim->Instance));
    671            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
    672            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
    673            assert_param(IS_TIM_PERIOD(htim, htim->Init.Period));
    674            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
    675          
    676            if (htim->State == HAL_TIM_STATE_RESET)
    677            {
    678              /* Allocate lock resource and initialize it */
    679              htim->Lock = HAL_UNLOCKED;
    680          
    681          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
    682              /* Reset interrupt callbacks to legacy weak callbacks */
    683              TIM_ResetCallback(htim);
    684          
    685              if (htim->OC_MspInitCallback == NULL)
    686              {
    687                htim->OC_MspInitCallback = HAL_TIM_OC_MspInit;
    688              }
    689              /* Init the low level hardware : GPIO, CLOCK, NVIC */
    690              htim->OC_MspInitCallback(htim);
    691          #else
    692              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    693              HAL_TIM_OC_MspInit(htim);
    694          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    695            }
    696          
    697            /* Set the TIM state */
    698            htim->State = HAL_TIM_STATE_BUSY;
    699          
    700            /* Init the base time for the Output Compare */
    701            TIM_Base_SetConfig(htim->Instance,  &htim->Init);
    702          
    703            /* Initialize the DMA burst operation state */
    704            htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
    705          
    706            /* Initialize the TIM channels state */
    707            TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
    708            TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
    709          
    710            /* Initialize the TIM state*/
    711            htim->State = HAL_TIM_STATE_READY;
    712          
    713            return HAL_OK;
    714          }
    715          
    716          /**
    717            * @brief  DeInitializes the TIM peripheral
    718            * @param  htim TIM Output Compare handle
    719            * @retval HAL status
    720            */
    721          HAL_StatusTypeDef HAL_TIM_OC_DeInit(TIM_HandleTypeDef *htim)
    722          {
    723            /* Check the parameters */
    724            assert_param(IS_TIM_INSTANCE(htim->Instance));
    725          
    726            htim->State = HAL_TIM_STATE_BUSY;
    727          
    728            /* Disable the TIM Peripheral Clock */
    729            __HAL_TIM_DISABLE(htim);
    730          
    731          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
    732            if (htim->OC_MspDeInitCallback == NULL)
    733            {
    734              htim->OC_MspDeInitCallback = HAL_TIM_OC_MspDeInit;
    735            }
    736            /* DeInit the low level hardware */
    737            htim->OC_MspDeInitCallback(htim);
    738          #else
    739            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
    740            HAL_TIM_OC_MspDeInit(htim);
    741          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    742          
    743            /* Change the DMA burst operation state */
    744            htim->DMABurstState = HAL_DMA_BURST_STATE_RESET;
    745          
    746            /* Change the TIM channels state */
    747            TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);
    748            TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);
    749          
    750            /* Change TIM state */
    751            htim->State = HAL_TIM_STATE_RESET;
    752          
    753            /* Release Lock */
    754            __HAL_UNLOCK(htim);
    755          
    756            return HAL_OK;
    757          }
    758          
    759          /**
    760            * @brief  Initializes the TIM Output Compare MSP.
    761            * @param  htim TIM Output Compare handle
    762            * @retval None
    763            */
    764          __weak void HAL_TIM_OC_MspInit(TIM_HandleTypeDef *htim)
    765          {
    766            /* Prevent unused argument(s) compilation warning */
    767            UNUSED(htim);
    768          
    769            /* NOTE : This function should not be modified, when the callback is needed,
    770                      the HAL_TIM_OC_MspInit could be implemented in the user file
    771             */
    772          }
    773          
    774          /**
    775            * @brief  DeInitializes TIM Output Compare MSP.
    776            * @param  htim TIM Output Compare handle
    777            * @retval None
    778            */
    779          __weak void HAL_TIM_OC_MspDeInit(TIM_HandleTypeDef *htim)
    780          {
    781            /* Prevent unused argument(s) compilation warning */
    782            UNUSED(htim);
    783          
    784            /* NOTE : This function should not be modified, when the callback is needed,
    785                      the HAL_TIM_OC_MspDeInit could be implemented in the user file
    786             */
    787          }
    788          
    789          /**
    790            * @brief  Starts the TIM Output Compare signal generation.
    791            * @param  htim TIM Output Compare handle
    792            * @param  Channel TIM Channel to be enabled
    793            *          This parameter can be one of the following values:
    794            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    795            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    796            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    797            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    798            *            @arg TIM_CHANNEL_5: TIM Channel 5 selected
    799            *            @arg TIM_CHANNEL_6: TIM Channel 6 selected
    800            * @retval HAL status
    801            */
    802          HAL_StatusTypeDef HAL_TIM_OC_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
    803          {
    804            uint32_t tmpsmcr;
    805          
    806            /* Check the parameters */
    807            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    808          
    809            /* Check the TIM channel state */
    810            if (TIM_CHANNEL_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)
    811            {
    812              return HAL_ERROR;
    813            }
    814          
    815            /* Set the TIM channel state */
    816            TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
    817          
    818            /* Enable the Output compare channel */
    819            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
    820          
    821            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
    822            {
    823              /* Enable the main output */
    824              __HAL_TIM_MOE_ENABLE(htim);
    825            }
    826          
    827            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    828            if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
    829            {
    830              tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
    831              if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
    832              {
    833                __HAL_TIM_ENABLE(htim);
    834              }
    835            }
    836            else
    837            {
    838              __HAL_TIM_ENABLE(htim);
    839            }
    840          
    841            /* Return function status */
    842            return HAL_OK;
    843          }
    844          
    845          /**
    846            * @brief  Stops the TIM Output Compare signal generation.
    847            * @param  htim TIM Output Compare handle
    848            * @param  Channel TIM Channel to be disabled
    849            *          This parameter can be one of the following values:
    850            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    851            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    852            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    853            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    854            *            @arg TIM_CHANNEL_5: TIM Channel 5 selected
    855            *            @arg TIM_CHANNEL_6: TIM Channel 6 selected
    856            * @retval HAL status
    857            */
    858          HAL_StatusTypeDef HAL_TIM_OC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
    859          {
    860            /* Check the parameters */
    861            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    862          
    863            /* Disable the Output compare channel */
    864            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
    865          
    866            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
    867            {
    868              /* Disable the Main Output */
    869              __HAL_TIM_MOE_DISABLE(htim);
    870            }
    871          
    872            /* Disable the Peripheral */
    873            __HAL_TIM_DISABLE(htim);
    874          
    875            /* Set the TIM channel state */
    876            TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
    877          
    878            /* Return function status */
    879            return HAL_OK;
    880          }
    881          
    882          /**
    883            * @brief  Starts the TIM Output Compare signal generation in interrupt mode.
    884            * @param  htim TIM Output Compare handle
    885            * @param  Channel TIM Channel to be enabled
    886            *          This parameter can be one of the following values:
    887            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    888            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    889            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    890            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    891            * @retval HAL status
    892            */
    893          HAL_StatusTypeDef HAL_TIM_OC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    894          {
    895            HAL_StatusTypeDef status = HAL_OK;
    896            uint32_t tmpsmcr;
    897          
    898            /* Check the parameters */
    899            assert_param(IS_TIM_CCX_CHANNEL(htim->Instance, Channel));
    900          
    901            /* Check the TIM channel state */
    902            if (TIM_CHANNEL_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)
    903            {
    904              return HAL_ERROR;
    905            }
    906          
    907            /* Set the TIM channel state */
    908            TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
    909          
    910            switch (Channel)
    911            {
    912              case TIM_CHANNEL_1:
    913              {
    914                /* Enable the TIM Capture/Compare 1 interrupt */
    915                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
    916                break;
    917              }
    918          
    919              case TIM_CHANNEL_2:
    920              {
    921                /* Enable the TIM Capture/Compare 2 interrupt */
    922                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
    923                break;
    924              }
    925          
    926              case TIM_CHANNEL_3:
    927              {
    928                /* Enable the TIM Capture/Compare 3 interrupt */
    929                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
    930                break;
    931              }
    932          
    933              case TIM_CHANNEL_4:
    934              {
    935                /* Enable the TIM Capture/Compare 4 interrupt */
    936                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
    937                break;
    938              }
    939          
    940              default:
    941                status = HAL_ERROR;
    942                break;
    943            }
    944          
    945            if (status == HAL_OK)
    946            {
    947              /* Enable the Output compare channel */
    948              TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
    949          
    950              if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
    951              {
    952                /* Enable the main output */
    953                __HAL_TIM_MOE_ENABLE(htim);
    954              }
    955          
    956              /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    957              if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
    958              {
    959                tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
    960                if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
    961                {
    962                  __HAL_TIM_ENABLE(htim);
    963                }
    964              }
    965              else
    966              {
    967                __HAL_TIM_ENABLE(htim);
    968              }
    969            }
    970          
    971            /* Return function status */
    972            return status;
    973          }
    974          
    975          /**
    976            * @brief  Stops the TIM Output Compare signal generation in interrupt mode.
    977            * @param  htim TIM Output Compare handle
    978            * @param  Channel TIM Channel to be disabled
    979            *          This parameter can be one of the following values:
    980            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    981            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    982            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    983            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    984            * @retval HAL status
    985            */
    986          HAL_StatusTypeDef HAL_TIM_OC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    987          {
    988            HAL_StatusTypeDef status = HAL_OK;
    989          
    990            /* Check the parameters */
    991            assert_param(IS_TIM_CCX_CHANNEL(htim->Instance, Channel));
    992          
    993            switch (Channel)
    994            {
    995              case TIM_CHANNEL_1:
    996              {
    997                /* Disable the TIM Capture/Compare 1 interrupt */
    998                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
    999                break;
   1000              }
   1001          
   1002              case TIM_CHANNEL_2:
   1003              {
   1004                /* Disable the TIM Capture/Compare 2 interrupt */
   1005                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   1006                break;
   1007              }
   1008          
   1009              case TIM_CHANNEL_3:
   1010              {
   1011                /* Disable the TIM Capture/Compare 3 interrupt */
   1012                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   1013                break;
   1014              }
   1015          
   1016              case TIM_CHANNEL_4:
   1017              {
   1018                /* Disable the TIM Capture/Compare 4 interrupt */
   1019                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   1020                break;
   1021              }
   1022          
   1023              default:
   1024                status = HAL_ERROR;
   1025                break;
   1026            }
   1027          
   1028            if (status == HAL_OK)
   1029            {
   1030              /* Disable the Output compare channel */
   1031              TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   1032          
   1033              if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   1034              {
   1035                /* Disable the Main Output */
   1036                __HAL_TIM_MOE_DISABLE(htim);
   1037              }
   1038          
   1039              /* Disable the Peripheral */
   1040              __HAL_TIM_DISABLE(htim);
   1041          
   1042              /* Set the TIM channel state */
   1043              TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
   1044            }
   1045          
   1046            /* Return function status */
   1047            return status;
   1048          }
   1049          
   1050          /**
   1051            * @brief  Starts the TIM Output Compare signal generation in DMA mode.
   1052            * @param  htim TIM Output Compare handle
   1053            * @param  Channel TIM Channel to be enabled
   1054            *          This parameter can be one of the following values:
   1055            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1056            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1057            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1058            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1059            * @param  pData The source Buffer address.
   1060            * @param  Length The length of data to be transferred from memory to TIM peripheral
   1061            * @retval HAL status
   1062            */
   1063          HAL_StatusTypeDef HAL_TIM_OC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, const uint32_t *pData,
   1064                                                 uint16_t Length)
   1065          {
   1066            HAL_StatusTypeDef status = HAL_OK;
   1067            uint32_t tmpsmcr;
   1068          
   1069            /* Check the parameters */
   1070            assert_param(IS_TIM_CCX_CHANNEL(htim->Instance, Channel));
   1071          
   1072            /* Set the TIM channel state */
   1073            if (TIM_CHANNEL_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_BUSY)
   1074            {
   1075              return HAL_BUSY;
   1076            }
   1077            else if (TIM_CHANNEL_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_READY)
   1078            {
   1079              if ((pData == NULL) || (Length == 0U))
   1080              {
   1081                return HAL_ERROR;
   1082              }
   1083              else
   1084              {
   1085                TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
   1086              }
   1087            }
   1088            else
   1089            {
   1090              return HAL_ERROR;
   1091            }
   1092          
   1093            switch (Channel)
   1094            {
   1095              case TIM_CHANNEL_1:
   1096              {
   1097                /* Set the DMA compare callbacks */
   1098                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
   1099                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   1100          
   1101                /* Set the DMA error callback */
   1102                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   1103          
   1104                /* Enable the DMA channel */
   1105                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1,
   1106                                     Length) != HAL_OK)
   1107                {
   1108                  /* Return error status */
   1109                  return HAL_ERROR;
   1110                }
   1111          
   1112                /* Enable the TIM Capture/Compare 1 DMA request */
   1113                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   1114                break;
   1115              }
   1116          
   1117              case TIM_CHANNEL_2:
   1118              {
   1119                /* Set the DMA compare callbacks */
   1120                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
   1121                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   1122          
   1123                /* Set the DMA error callback */
   1124                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   1125          
   1126                /* Enable the DMA channel */
   1127                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2,
   1128                                     Length) != HAL_OK)
   1129                {
   1130                  /* Return error status */
   1131                  return HAL_ERROR;
   1132                }
   1133          
   1134                /* Enable the TIM Capture/Compare 2 DMA request */
   1135                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   1136                break;
   1137              }
   1138          
   1139              case TIM_CHANNEL_3:
   1140              {
   1141                /* Set the DMA compare callbacks */
   1142                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
   1143                htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   1144          
   1145                /* Set the DMA error callback */
   1146                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   1147          
   1148                /* Enable the DMA channel */
   1149                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,
   1150                                     Length) != HAL_OK)
   1151                {
   1152                  /* Return error status */
   1153                  return HAL_ERROR;
   1154                }
   1155                /* Enable the TIM Capture/Compare 3 DMA request */
   1156                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   1157                break;
   1158              }
   1159          
   1160              case TIM_CHANNEL_4:
   1161              {
   1162                /* Set the DMA compare callbacks */
   1163                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
   1164                htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   1165          
   1166                /* Set the DMA error callback */
   1167                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   1168          
   1169                /* Enable the DMA channel */
   1170                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4,
   1171                                     Length) != HAL_OK)
   1172                {
   1173                  /* Return error status */
   1174                  return HAL_ERROR;
   1175                }
   1176                /* Enable the TIM Capture/Compare 4 DMA request */
   1177                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   1178                break;
   1179              }
   1180          
   1181              default:
   1182                status = HAL_ERROR;
   1183                break;
   1184            }
   1185          
   1186            if (status == HAL_OK)
   1187            {
   1188              /* Enable the Output compare channel */
   1189              TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   1190          
   1191              if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   1192              {
   1193                /* Enable the main output */
   1194                __HAL_TIM_MOE_ENABLE(htim);
   1195              }
   1196          
   1197              /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   1198              if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
   1199              {
   1200                tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   1201                if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   1202                {
   1203                  __HAL_TIM_ENABLE(htim);
   1204                }
   1205              }
   1206              else
   1207              {
   1208                __HAL_TIM_ENABLE(htim);
   1209              }
   1210            }
   1211          
   1212            /* Return function status */
   1213            return status;
   1214          }
   1215          
   1216          /**
   1217            * @brief  Stops the TIM Output Compare signal generation in DMA mode.
   1218            * @param  htim TIM Output Compare handle
   1219            * @param  Channel TIM Channel to be disabled
   1220            *          This parameter can be one of the following values:
   1221            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1222            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1223            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1224            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1225            * @retval HAL status
   1226            */
   1227          HAL_StatusTypeDef HAL_TIM_OC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   1228          {
   1229            HAL_StatusTypeDef status = HAL_OK;
   1230          
   1231            /* Check the parameters */
   1232            assert_param(IS_TIM_CCX_CHANNEL(htim->Instance, Channel));
   1233          
   1234            switch (Channel)
   1235            {
   1236              case TIM_CHANNEL_1:
   1237              {
   1238                /* Disable the TIM Capture/Compare 1 DMA request */
   1239                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   1240                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   1241                break;
   1242              }
   1243          
   1244              case TIM_CHANNEL_2:
   1245              {
   1246                /* Disable the TIM Capture/Compare 2 DMA request */
   1247                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   1248                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   1249                break;
   1250              }
   1251          
   1252              case TIM_CHANNEL_3:
   1253              {
   1254                /* Disable the TIM Capture/Compare 3 DMA request */
   1255                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   1256                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
   1257                break;
   1258              }
   1259          
   1260              case TIM_CHANNEL_4:
   1261              {
   1262                /* Disable the TIM Capture/Compare 4 interrupt */
   1263                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   1264                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
   1265                break;
   1266              }
   1267          
   1268              default:
   1269                status = HAL_ERROR;
   1270                break;
   1271            }
   1272          
   1273            if (status == HAL_OK)
   1274            {
   1275              /* Disable the Output compare channel */
   1276              TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   1277          
   1278              if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   1279              {
   1280                /* Disable the Main Output */
   1281                __HAL_TIM_MOE_DISABLE(htim);
   1282              }
   1283          
   1284              /* Disable the Peripheral */
   1285              __HAL_TIM_DISABLE(htim);
   1286          
   1287              /* Set the TIM channel state */
   1288              TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
   1289            }
   1290          
   1291            /* Return function status */
   1292            return status;
   1293          }
   1294          
   1295          /**
   1296            * @}
   1297            */
   1298          
   1299          /** @defgroup TIM_Exported_Functions_Group3 TIM PWM functions
   1300            *  @brief    TIM PWM functions
   1301            *
   1302          @verbatim
   1303            ==============================================================================
   1304                                    ##### TIM PWM functions #####
   1305            ==============================================================================
   1306            [..]
   1307              This section provides functions allowing to:
   1308              (+) Initialize and configure the TIM PWM.
   1309              (+) De-initialize the TIM PWM.
   1310              (+) Start the TIM PWM.
   1311              (+) Stop the TIM PWM.
   1312              (+) Start the TIM PWM and enable interrupt.
   1313              (+) Stop the TIM PWM and disable interrupt.
   1314              (+) Start the TIM PWM and enable DMA transfer.
   1315              (+) Stop the TIM PWM and disable DMA transfer.
   1316          
   1317          @endverbatim
   1318            * @{
   1319            */
   1320          /**
   1321            * @brief  Initializes the TIM PWM Time Base according to the specified
   1322            *         parameters in the TIM_HandleTypeDef and initializes the associated handle.
   1323            * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
   1324            *         requires a timer reset to avoid unexpected direction
   1325            *         due to DIR bit readonly in center aligned mode.
   1326            *         Ex: call @ref HAL_TIM_PWM_DeInit() before HAL_TIM_PWM_Init()
   1327            * @param  htim TIM PWM handle
   1328            * @retval HAL status
   1329            */
   1330          HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
   1331          {
   1332            /* Check the TIM handle allocation */
   1333            if (htim == NULL)
   1334            {
   1335              return HAL_ERROR;
   1336            }
   1337          
   1338            /* Check the parameters */
   1339            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1340            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   1341            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   1342            assert_param(IS_TIM_PERIOD(htim, htim->Init.Period));
   1343            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
   1344          
   1345            if (htim->State == HAL_TIM_STATE_RESET)
   1346            {
   1347              /* Allocate lock resource and initialize it */
   1348              htim->Lock = HAL_UNLOCKED;
   1349          
   1350          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   1351              /* Reset interrupt callbacks to legacy weak callbacks */
   1352              TIM_ResetCallback(htim);
   1353          
   1354              if (htim->PWM_MspInitCallback == NULL)
   1355              {
   1356                htim->PWM_MspInitCallback = HAL_TIM_PWM_MspInit;
   1357              }
   1358              /* Init the low level hardware : GPIO, CLOCK, NVIC */
   1359              htim->PWM_MspInitCallback(htim);
   1360          #else
   1361              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   1362              HAL_TIM_PWM_MspInit(htim);
   1363          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   1364            }
   1365          
   1366            /* Set the TIM state */
   1367            htim->State = HAL_TIM_STATE_BUSY;
   1368          
   1369            /* Init the base time for the PWM */
   1370            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   1371          
   1372            /* Initialize the DMA burst operation state */
   1373            htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
   1374          
   1375            /* Initialize the TIM channels state */
   1376            TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
   1377            TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
   1378          
   1379            /* Initialize the TIM state*/
   1380            htim->State = HAL_TIM_STATE_READY;
   1381          
   1382            return HAL_OK;
   1383          }
   1384          
   1385          /**
   1386            * @brief  DeInitializes the TIM peripheral
   1387            * @param  htim TIM PWM handle
   1388            * @retval HAL status
   1389            */
   1390          HAL_StatusTypeDef HAL_TIM_PWM_DeInit(TIM_HandleTypeDef *htim)
   1391          {
   1392            /* Check the parameters */
   1393            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1394          
   1395            htim->State = HAL_TIM_STATE_BUSY;
   1396          
   1397            /* Disable the TIM Peripheral Clock */
   1398            __HAL_TIM_DISABLE(htim);
   1399          
   1400          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   1401            if (htim->PWM_MspDeInitCallback == NULL)
   1402            {
   1403              htim->PWM_MspDeInitCallback = HAL_TIM_PWM_MspDeInit;
   1404            }
   1405            /* DeInit the low level hardware */
   1406            htim->PWM_MspDeInitCallback(htim);
   1407          #else
   1408            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
   1409            HAL_TIM_PWM_MspDeInit(htim);
   1410          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   1411          
   1412            /* Change the DMA burst operation state */
   1413            htim->DMABurstState = HAL_DMA_BURST_STATE_RESET;
   1414          
   1415            /* Change the TIM channels state */
   1416            TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);
   1417            TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);
   1418          
   1419            /* Change TIM state */
   1420            htim->State = HAL_TIM_STATE_RESET;
   1421          
   1422            /* Release Lock */
   1423            __HAL_UNLOCK(htim);
   1424          
   1425            return HAL_OK;
   1426          }
   1427          
   1428          /**
   1429            * @brief  Initializes the TIM PWM MSP.
   1430            * @param  htim TIM PWM handle
   1431            * @retval None
   1432            */
   1433          __weak void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)
   1434          {
   1435            /* Prevent unused argument(s) compilation warning */
   1436            UNUSED(htim);
   1437          
   1438            /* NOTE : This function should not be modified, when the callback is needed,
   1439                      the HAL_TIM_PWM_MspInit could be implemented in the user file
   1440             */
   1441          }
   1442          
   1443          /**
   1444            * @brief  DeInitializes TIM PWM MSP.
   1445            * @param  htim TIM PWM handle
   1446            * @retval None
   1447            */
   1448          __weak void HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef *htim)
   1449          {
   1450            /* Prevent unused argument(s) compilation warning */
   1451            UNUSED(htim);
   1452          
   1453            /* NOTE : This function should not be modified, when the callback is needed,
   1454                      the HAL_TIM_PWM_MspDeInit could be implemented in the user file
   1455             */
   1456          }
   1457          
   1458          /**
   1459            * @brief  Starts the PWM signal generation.
   1460            * @param  htim TIM handle
   1461            * @param  Channel TIM Channels to be enabled
   1462            *          This parameter can be one of the following values:
   1463            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1464            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1465            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1466            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1467            *            @arg TIM_CHANNEL_5: TIM Channel 5 selected
   1468            *            @arg TIM_CHANNEL_6: TIM Channel 6 selected
   1469            * @retval HAL status
   1470            */
   1471          HAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
   1472          {
   1473            uint32_t tmpsmcr;
   1474          
   1475            /* Check the parameters */
   1476            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1477          
   1478            /* Check the TIM channel state */
   1479            if (TIM_CHANNEL_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)
   1480            {
   1481              return HAL_ERROR;
   1482            }
   1483          
   1484            /* Set the TIM channel state */
   1485            TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
   1486          
   1487            /* Enable the Capture compare channel */
   1488            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   1489          
   1490            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   1491            {
   1492              /* Enable the main output */
   1493              __HAL_TIM_MOE_ENABLE(htim);
   1494            }
   1495          
   1496            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   1497            if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
   1498            {
   1499              tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   1500              if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   1501              {
   1502                __HAL_TIM_ENABLE(htim);
   1503              }
   1504            }
   1505            else
   1506            {
   1507              __HAL_TIM_ENABLE(htim);
   1508            }
   1509          
   1510            /* Return function status */
   1511            return HAL_OK;
   1512          }
   1513          
   1514          /**
   1515            * @brief  Stops the PWM signal generation.
   1516            * @param  htim TIM PWM handle
   1517            * @param  Channel TIM Channels to be disabled
   1518            *          This parameter can be one of the following values:
   1519            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1520            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1521            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1522            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1523            *            @arg TIM_CHANNEL_5: TIM Channel 5 selected
   1524            *            @arg TIM_CHANNEL_6: TIM Channel 6 selected
   1525            * @retval HAL status
   1526            */
   1527          HAL_StatusTypeDef HAL_TIM_PWM_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   1528          {
   1529            /* Check the parameters */
   1530            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1531          
   1532            /* Disable the Capture compare channel */
   1533            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   1534          
   1535            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   1536            {
   1537              /* Disable the Main Output */
   1538              __HAL_TIM_MOE_DISABLE(htim);
   1539            }
   1540          
   1541            /* Disable the Peripheral */
   1542            __HAL_TIM_DISABLE(htim);
   1543          
   1544            /* Set the TIM channel state */
   1545            TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
   1546          
   1547            /* Return function status */
   1548            return HAL_OK;
   1549          }
   1550          
   1551          /**
   1552            * @brief  Starts the PWM signal generation in interrupt mode.
   1553            * @param  htim TIM PWM handle
   1554            * @param  Channel TIM Channel to be enabled
   1555            *          This parameter can be one of the following values:
   1556            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1557            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1558            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1559            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1560            * @retval HAL status
   1561            */
   1562          HAL_StatusTypeDef HAL_TIM_PWM_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   1563          {
   1564            HAL_StatusTypeDef status = HAL_OK;
   1565            uint32_t tmpsmcr;
   1566          
   1567            /* Check the parameters */
   1568            assert_param(IS_TIM_CCX_CHANNEL(htim->Instance, Channel));
   1569          
   1570            /* Check the TIM channel state */
   1571            if (TIM_CHANNEL_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)
   1572            {
   1573              return HAL_ERROR;
   1574            }
   1575          
   1576            /* Set the TIM channel state */
   1577            TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
   1578          
   1579            switch (Channel)
   1580            {
   1581              case TIM_CHANNEL_1:
   1582              {
   1583                /* Enable the TIM Capture/Compare 1 interrupt */
   1584                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   1585                break;
   1586              }
   1587          
   1588              case TIM_CHANNEL_2:
   1589              {
   1590                /* Enable the TIM Capture/Compare 2 interrupt */
   1591                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   1592                break;
   1593              }
   1594          
   1595              case TIM_CHANNEL_3:
   1596              {
   1597                /* Enable the TIM Capture/Compare 3 interrupt */
   1598                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   1599                break;
   1600              }
   1601          
   1602              case TIM_CHANNEL_4:
   1603              {
   1604                /* Enable the TIM Capture/Compare 4 interrupt */
   1605                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
   1606                break;
   1607              }
   1608          
   1609              default:
   1610                status = HAL_ERROR;
   1611                break;
   1612            }
   1613          
   1614            if (status == HAL_OK)
   1615            {
   1616              /* Enable the Capture compare channel */
   1617              TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   1618          
   1619              if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   1620              {
   1621                /* Enable the main output */
   1622                __HAL_TIM_MOE_ENABLE(htim);
   1623              }
   1624          
   1625              /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   1626              if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
   1627              {
   1628                tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   1629                if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   1630                {
   1631                  __HAL_TIM_ENABLE(htim);
   1632                }
   1633              }
   1634              else
   1635              {
   1636                __HAL_TIM_ENABLE(htim);
   1637              }
   1638            }
   1639          
   1640            /* Return function status */
   1641            return status;
   1642          }
   1643          
   1644          /**
   1645            * @brief  Stops the PWM signal generation in interrupt mode.
   1646            * @param  htim TIM PWM handle
   1647            * @param  Channel TIM Channels to be disabled
   1648            *          This parameter can be one of the following values:
   1649            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1650            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1651            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1652            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1653            * @retval HAL status
   1654            */
   1655          HAL_StatusTypeDef HAL_TIM_PWM_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   1656          {
   1657            HAL_StatusTypeDef status = HAL_OK;
   1658          
   1659            /* Check the parameters */
   1660            assert_param(IS_TIM_CCX_CHANNEL(htim->Instance, Channel));
   1661          
   1662            switch (Channel)
   1663            {
   1664              case TIM_CHANNEL_1:
   1665              {
   1666                /* Disable the TIM Capture/Compare 1 interrupt */
   1667                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   1668                break;
   1669              }
   1670          
   1671              case TIM_CHANNEL_2:
   1672              {
   1673                /* Disable the TIM Capture/Compare 2 interrupt */
   1674                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   1675                break;
   1676              }
   1677          
   1678              case TIM_CHANNEL_3:
   1679              {
   1680                /* Disable the TIM Capture/Compare 3 interrupt */
   1681                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   1682                break;
   1683              }
   1684          
   1685              case TIM_CHANNEL_4:
   1686              {
   1687                /* Disable the TIM Capture/Compare 4 interrupt */
   1688                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   1689                break;
   1690              }
   1691          
   1692              default:
   1693                status = HAL_ERROR;
   1694                break;
   1695            }
   1696          
   1697            if (status == HAL_OK)
   1698            {
   1699              /* Disable the Capture compare channel */
   1700              TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   1701          
   1702              if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   1703              {
   1704                /* Disable the Main Output */
   1705                __HAL_TIM_MOE_DISABLE(htim);
   1706              }
   1707          
   1708              /* Disable the Peripheral */
   1709              __HAL_TIM_DISABLE(htim);
   1710          
   1711              /* Set the TIM channel state */
   1712              TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
   1713            }
   1714          
   1715            /* Return function status */
   1716            return status;
   1717          }
   1718          
   1719          /**
   1720            * @brief  Starts the TIM PWM signal generation in DMA mode.
   1721            * @param  htim TIM PWM handle
   1722            * @param  Channel TIM Channels to be enabled
   1723            *          This parameter can be one of the following values:
   1724            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1725            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1726            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1727            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1728            * @param  pData The source Buffer address.
   1729            * @param  Length The length of data to be transferred from memory to TIM peripheral
   1730            * @retval HAL status
   1731            */
   1732          HAL_StatusTypeDef HAL_TIM_PWM_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, const uint32_t *pData,
   1733                                                  uint16_t Length)
   1734          {
   1735            HAL_StatusTypeDef status = HAL_OK;
   1736            uint32_t tmpsmcr;
   1737          
   1738            /* Check the parameters */
   1739            assert_param(IS_TIM_CCX_CHANNEL(htim->Instance, Channel));
   1740          
   1741            /* Set the TIM channel state */
   1742            if (TIM_CHANNEL_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_BUSY)
   1743            {
   1744              return HAL_BUSY;
   1745            }
   1746            else if (TIM_CHANNEL_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_READY)
   1747            {
   1748              if ((pData == NULL) || (Length == 0U))
   1749              {
   1750                return HAL_ERROR;
   1751              }
   1752              else
   1753              {
   1754                TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
   1755              }
   1756            }
   1757            else
   1758            {
   1759              return HAL_ERROR;
   1760            }
   1761          
   1762            switch (Channel)
   1763            {
   1764              case TIM_CHANNEL_1:
   1765              {
   1766                /* Set the DMA compare callbacks */
   1767                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
   1768                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   1769          
   1770                /* Set the DMA error callback */
   1771                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   1772          
   1773                /* Enable the DMA channel */
   1774                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1,
   1775                                     Length) != HAL_OK)
   1776                {
   1777                  /* Return error status */
   1778                  return HAL_ERROR;
   1779                }
   1780          
   1781                /* Enable the TIM Capture/Compare 1 DMA request */
   1782                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   1783                break;
   1784              }
   1785          
   1786              case TIM_CHANNEL_2:
   1787              {
   1788                /* Set the DMA compare callbacks */
   1789                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
   1790                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   1791          
   1792                /* Set the DMA error callback */
   1793                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   1794          
   1795                /* Enable the DMA channel */
   1796                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2,
   1797                                     Length) != HAL_OK)
   1798                {
   1799                  /* Return error status */
   1800                  return HAL_ERROR;
   1801                }
   1802                /* Enable the TIM Capture/Compare 2 DMA request */
   1803                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   1804                break;
   1805              }
   1806          
   1807              case TIM_CHANNEL_3:
   1808              {
   1809                /* Set the DMA compare callbacks */
   1810                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
   1811                htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   1812          
   1813                /* Set the DMA error callback */
   1814                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   1815          
   1816                /* Enable the DMA channel */
   1817                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,
   1818                                     Length) != HAL_OK)
   1819                {
   1820                  /* Return error status */
   1821                  return HAL_ERROR;
   1822                }
   1823                /* Enable the TIM Output Capture/Compare 3 request */
   1824                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   1825                break;
   1826              }
   1827          
   1828              case TIM_CHANNEL_4:
   1829              {
   1830                /* Set the DMA compare callbacks */
   1831                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
   1832                htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   1833          
   1834                /* Set the DMA error callback */
   1835                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   1836          
   1837                /* Enable the DMA channel */
   1838                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4,
   1839                                     Length) != HAL_OK)
   1840                {
   1841                  /* Return error status */
   1842                  return HAL_ERROR;
   1843                }
   1844                /* Enable the TIM Capture/Compare 4 DMA request */
   1845                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   1846                break;
   1847              }
   1848          
   1849              default:
   1850                status = HAL_ERROR;
   1851                break;
   1852            }
   1853          
   1854            if (status == HAL_OK)
   1855            {
   1856              /* Enable the Capture compare channel */
   1857              TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   1858          
   1859              if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   1860              {
   1861                /* Enable the main output */
   1862                __HAL_TIM_MOE_ENABLE(htim);
   1863              }
   1864          
   1865              /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   1866              if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
   1867              {
   1868                tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   1869                if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   1870                {
   1871                  __HAL_TIM_ENABLE(htim);
   1872                }
   1873              }
   1874              else
   1875              {
   1876                __HAL_TIM_ENABLE(htim);
   1877              }
   1878            }
   1879          
   1880            /* Return function status */
   1881            return status;
   1882          }
   1883          
   1884          /**
   1885            * @brief  Stops the TIM PWM signal generation in DMA mode.
   1886            * @param  htim TIM PWM handle
   1887            * @param  Channel TIM Channels to be disabled
   1888            *          This parameter can be one of the following values:
   1889            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1890            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1891            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1892            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1893            * @retval HAL status
   1894            */
   1895          HAL_StatusTypeDef HAL_TIM_PWM_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   1896          {
   1897            HAL_StatusTypeDef status = HAL_OK;
   1898          
   1899            /* Check the parameters */
   1900            assert_param(IS_TIM_CCX_CHANNEL(htim->Instance, Channel));
   1901          
   1902            switch (Channel)
   1903            {
   1904              case TIM_CHANNEL_1:
   1905              {
   1906                /* Disable the TIM Capture/Compare 1 DMA request */
   1907                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   1908                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   1909                break;
   1910              }
   1911          
   1912              case TIM_CHANNEL_2:
   1913              {
   1914                /* Disable the TIM Capture/Compare 2 DMA request */
   1915                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   1916                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   1917                break;
   1918              }
   1919          
   1920              case TIM_CHANNEL_3:
   1921              {
   1922                /* Disable the TIM Capture/Compare 3 DMA request */
   1923                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   1924                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
   1925                break;
   1926              }
   1927          
   1928              case TIM_CHANNEL_4:
   1929              {
   1930                /* Disable the TIM Capture/Compare 4 interrupt */
   1931                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   1932                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
   1933                break;
   1934              }
   1935          
   1936              default:
   1937                status = HAL_ERROR;
   1938                break;
   1939            }
   1940          
   1941            if (status == HAL_OK)
   1942            {
   1943              /* Disable the Capture compare channel */
   1944              TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   1945          
   1946              if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   1947              {
   1948                /* Disable the Main Output */
   1949                __HAL_TIM_MOE_DISABLE(htim);
   1950              }
   1951          
   1952              /* Disable the Peripheral */
   1953              __HAL_TIM_DISABLE(htim);
   1954          
   1955              /* Set the TIM channel state */
   1956              TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
   1957            }
   1958          
   1959            /* Return function status */
   1960            return status;
   1961          }
   1962          
   1963          /**
   1964            * @}
   1965            */
   1966          
   1967          /** @defgroup TIM_Exported_Functions_Group4 TIM Input Capture functions
   1968            *  @brief    TIM Input Capture functions
   1969            *
   1970          @verbatim
   1971            ==============================================================================
   1972                        ##### TIM Input Capture functions #####
   1973            ==============================================================================
   1974           [..]
   1975             This section provides functions allowing to:
   1976             (+) Initialize and configure the TIM Input Capture.
   1977             (+) De-initialize the TIM Input Capture.
   1978             (+) Start the TIM Input Capture.
   1979             (+) Stop the TIM Input Capture.
   1980             (+) Start the TIM Input Capture and enable interrupt.
   1981             (+) Stop the TIM Input Capture and disable interrupt.
   1982             (+) Start the TIM Input Capture and enable DMA transfer.
   1983             (+) Stop the TIM Input Capture and disable DMA transfer.
   1984          
   1985          @endverbatim
   1986            * @{
   1987            */
   1988          /**
   1989            * @brief  Initializes the TIM Input Capture Time base according to the specified
   1990            *         parameters in the TIM_HandleTypeDef and initializes the associated handle.
   1991            * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
   1992            *         requires a timer reset to avoid unexpected direction
   1993            *         due to DIR bit readonly in center aligned mode.
   1994            *         Ex: call @ref HAL_TIM_IC_DeInit() before HAL_TIM_IC_Init()
   1995            * @param  htim TIM Input Capture handle
   1996            * @retval HAL status
   1997            */
   1998          HAL_StatusTypeDef HAL_TIM_IC_Init(TIM_HandleTypeDef *htim)
   1999          {
   2000            /* Check the TIM handle allocation */
   2001            if (htim == NULL)
   2002            {
   2003              return HAL_ERROR;
   2004            }
   2005          
   2006            /* Check the parameters */
   2007            assert_param(IS_TIM_INSTANCE(htim->Instance));
   2008            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   2009            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   2010            assert_param(IS_TIM_PERIOD(htim, htim->Init.Period));
   2011            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
   2012          
   2013            if (htim->State == HAL_TIM_STATE_RESET)
   2014            {
   2015              /* Allocate lock resource and initialize it */
   2016              htim->Lock = HAL_UNLOCKED;
   2017          
   2018          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   2019              /* Reset interrupt callbacks to legacy weak callbacks */
   2020              TIM_ResetCallback(htim);
   2021          
   2022              if (htim->IC_MspInitCallback == NULL)
   2023              {
   2024                htim->IC_MspInitCallback = HAL_TIM_IC_MspInit;
   2025              }
   2026              /* Init the low level hardware : GPIO, CLOCK, NVIC */
   2027              htim->IC_MspInitCallback(htim);
   2028          #else
   2029              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   2030              HAL_TIM_IC_MspInit(htim);
   2031          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   2032            }
   2033          
   2034            /* Set the TIM state */
   2035            htim->State = HAL_TIM_STATE_BUSY;
   2036          
   2037            /* Init the base time for the input capture */
   2038            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   2039          
   2040            /* Initialize the DMA burst operation state */
   2041            htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
   2042          
   2043            /* Initialize the TIM channels state */
   2044            TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
   2045            TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
   2046          
   2047            /* Initialize the TIM state*/
   2048            htim->State = HAL_TIM_STATE_READY;
   2049          
   2050            return HAL_OK;
   2051          }
   2052          
   2053          /**
   2054            * @brief  DeInitializes the TIM peripheral
   2055            * @param  htim TIM Input Capture handle
   2056            * @retval HAL status
   2057            */
   2058          HAL_StatusTypeDef HAL_TIM_IC_DeInit(TIM_HandleTypeDef *htim)
   2059          {
   2060            /* Check the parameters */
   2061            assert_param(IS_TIM_INSTANCE(htim->Instance));
   2062          
   2063            htim->State = HAL_TIM_STATE_BUSY;
   2064          
   2065            /* Disable the TIM Peripheral Clock */
   2066            __HAL_TIM_DISABLE(htim);
   2067          
   2068          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   2069            if (htim->IC_MspDeInitCallback == NULL)
   2070            {
   2071              htim->IC_MspDeInitCallback = HAL_TIM_IC_MspDeInit;
   2072            }
   2073            /* DeInit the low level hardware */
   2074            htim->IC_MspDeInitCallback(htim);
   2075          #else
   2076            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
   2077            HAL_TIM_IC_MspDeInit(htim);
   2078          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   2079          
   2080            /* Change the DMA burst operation state */
   2081            htim->DMABurstState = HAL_DMA_BURST_STATE_RESET;
   2082          
   2083            /* Change the TIM channels state */
   2084            TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);
   2085            TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);
   2086          
   2087            /* Change TIM state */
   2088            htim->State = HAL_TIM_STATE_RESET;
   2089          
   2090            /* Release Lock */
   2091            __HAL_UNLOCK(htim);
   2092          
   2093            return HAL_OK;
   2094          }
   2095          
   2096          /**
   2097            * @brief  Initializes the TIM Input Capture MSP.
   2098            * @param  htim TIM Input Capture handle
   2099            * @retval None
   2100            */
   2101          __weak void HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim)
   2102          {
   2103            /* Prevent unused argument(s) compilation warning */
   2104            UNUSED(htim);
   2105          
   2106            /* NOTE : This function should not be modified, when the callback is needed,
   2107                      the HAL_TIM_IC_MspInit could be implemented in the user file
   2108             */
   2109          }
   2110          
   2111          /**
   2112            * @brief  DeInitializes TIM Input Capture MSP.
   2113            * @param  htim TIM handle
   2114            * @retval None
   2115            */
   2116          __weak void HAL_TIM_IC_MspDeInit(TIM_HandleTypeDef *htim)
   2117          {
   2118            /* Prevent unused argument(s) compilation warning */
   2119            UNUSED(htim);
   2120          
   2121            /* NOTE : This function should not be modified, when the callback is needed,
   2122                      the HAL_TIM_IC_MspDeInit could be implemented in the user file
   2123             */
   2124          }
   2125          
   2126          /**
   2127            * @brief  Starts the TIM Input Capture measurement.
   2128            * @param  htim TIM Input Capture handle
   2129            * @param  Channel TIM Channels to be enabled
   2130            *          This parameter can be one of the following values:
   2131            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2132            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2133            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   2134            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   2135            * @retval HAL status
   2136            */
   2137          HAL_StatusTypeDef HAL_TIM_IC_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
   2138          {
   2139            uint32_t tmpsmcr;
   2140            HAL_TIM_ChannelStateTypeDef channel_state = TIM_CHANNEL_STATE_GET(htim, Channel);
   2141            HAL_TIM_ChannelStateTypeDef complementary_channel_state = TIM_CHANNEL_N_STATE_GET(htim, Channel);
   2142          
   2143            /* Check the parameters */
   2144            assert_param(IS_TIM_CCX_CHANNEL(htim->Instance, Channel));
   2145          
   2146            /* Check the TIM channel state */
   2147            if ((channel_state != HAL_TIM_CHANNEL_STATE_READY)
   2148                || (complementary_channel_state != HAL_TIM_CHANNEL_STATE_READY))
   2149            {
   2150              return HAL_ERROR;
   2151            }
   2152          
   2153            /* Set the TIM channel state */
   2154            TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
   2155            TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
   2156          
   2157            /* Enable the Input Capture channel */
   2158            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   2159          
   2160            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   2161            if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
   2162            {
   2163              tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   2164              if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   2165              {
   2166                __HAL_TIM_ENABLE(htim);
   2167              }
   2168            }
   2169            else
   2170            {
   2171              __HAL_TIM_ENABLE(htim);
   2172            }
   2173          
   2174            /* Return function status */
   2175            return HAL_OK;
   2176          }
   2177          
   2178          /**
   2179            * @brief  Stops the TIM Input Capture measurement.
   2180            * @param  htim TIM Input Capture handle
   2181            * @param  Channel TIM Channels to be disabled
   2182            *          This parameter can be one of the following values:
   2183            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2184            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2185            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   2186            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   2187            * @retval HAL status
   2188            */
   2189          HAL_StatusTypeDef HAL_TIM_IC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   2190          {
   2191            /* Check the parameters */
   2192            assert_param(IS_TIM_CCX_CHANNEL(htim->Instance, Channel));
   2193          
   2194            /* Disable the Input Capture channel */
   2195            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   2196          
   2197            /* Disable the Peripheral */
   2198            __HAL_TIM_DISABLE(htim);
   2199          
   2200            /* Set the TIM channel state */
   2201            TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
   2202            TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
   2203          
   2204            /* Return function status */
   2205            return HAL_OK;
   2206          }
   2207          
   2208          /**
   2209            * @brief  Starts the TIM Input Capture measurement in interrupt mode.
   2210            * @param  htim TIM Input Capture handle
   2211            * @param  Channel TIM Channels to be enabled
   2212            *          This parameter can be one of the following values:
   2213            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2214            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2215            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   2216            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   2217            * @retval HAL status
   2218            */
   2219          HAL_StatusTypeDef HAL_TIM_IC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   2220          {
   2221            HAL_StatusTypeDef status = HAL_OK;
   2222            uint32_t tmpsmcr;
   2223          
   2224            HAL_TIM_ChannelStateTypeDef channel_state = TIM_CHANNEL_STATE_GET(htim, Channel);
   2225            HAL_TIM_ChannelStateTypeDef complementary_channel_state = TIM_CHANNEL_N_STATE_GET(htim, Channel);
   2226          
   2227            /* Check the parameters */
   2228            assert_param(IS_TIM_CCX_CHANNEL(htim->Instance, Channel));
   2229          
   2230            /* Check the TIM channel state */
   2231            if ((channel_state != HAL_TIM_CHANNEL_STATE_READY)
   2232                || (complementary_channel_state != HAL_TIM_CHANNEL_STATE_READY))
   2233            {
   2234              return HAL_ERROR;
   2235            }
   2236          
   2237            /* Set the TIM channel state */
   2238            TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
   2239            TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
   2240          
   2241            switch (Channel)
   2242            {
   2243              case TIM_CHANNEL_1:
   2244              {
   2245                /* Enable the TIM Capture/Compare 1 interrupt */
   2246                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   2247                break;
   2248              }
   2249          
   2250              case TIM_CHANNEL_2:
   2251              {
   2252                /* Enable the TIM Capture/Compare 2 interrupt */
   2253                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   2254                break;
   2255              }
   2256          
   2257              case TIM_CHANNEL_3:
   2258              {
   2259                /* Enable the TIM Capture/Compare 3 interrupt */
   2260                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   2261                break;
   2262              }
   2263          
   2264              case TIM_CHANNEL_4:
   2265              {
   2266                /* Enable the TIM Capture/Compare 4 interrupt */
   2267                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
   2268                break;
   2269              }
   2270          
   2271              default:
   2272                status = HAL_ERROR;
   2273                break;
   2274            }
   2275          
   2276            if (status == HAL_OK)
   2277            {
   2278              /* Enable the Input Capture channel */
   2279              TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   2280          
   2281              /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   2282              if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
   2283              {
   2284                tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   2285                if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   2286                {
   2287                  __HAL_TIM_ENABLE(htim);
   2288                }
   2289              }
   2290              else
   2291              {
   2292                __HAL_TIM_ENABLE(htim);
   2293              }
   2294            }
   2295          
   2296            /* Return function status */
   2297            return status;
   2298          }
   2299          
   2300          /**
   2301            * @brief  Stops the TIM Input Capture measurement in interrupt mode.
   2302            * @param  htim TIM Input Capture handle
   2303            * @param  Channel TIM Channels to be disabled
   2304            *          This parameter can be one of the following values:
   2305            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2306            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2307            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   2308            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   2309            * @retval HAL status
   2310            */
   2311          HAL_StatusTypeDef HAL_TIM_IC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   2312          {
   2313            HAL_StatusTypeDef status = HAL_OK;
   2314          
   2315            /* Check the parameters */
   2316            assert_param(IS_TIM_CCX_CHANNEL(htim->Instance, Channel));
   2317          
   2318            switch (Channel)
   2319            {
   2320              case TIM_CHANNEL_1:
   2321              {
   2322                /* Disable the TIM Capture/Compare 1 interrupt */
   2323                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   2324                break;
   2325              }
   2326          
   2327              case TIM_CHANNEL_2:
   2328              {
   2329                /* Disable the TIM Capture/Compare 2 interrupt */
   2330                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   2331                break;
   2332              }
   2333          
   2334              case TIM_CHANNEL_3:
   2335              {
   2336                /* Disable the TIM Capture/Compare 3 interrupt */
   2337                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   2338                break;
   2339              }
   2340          
   2341              case TIM_CHANNEL_4:
   2342              {
   2343                /* Disable the TIM Capture/Compare 4 interrupt */
   2344                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   2345                break;
   2346              }
   2347          
   2348              default:
   2349                status = HAL_ERROR;
   2350                break;
   2351            }
   2352          
   2353            if (status == HAL_OK)
   2354            {
   2355              /* Disable the Input Capture channel */
   2356              TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   2357          
   2358              /* Disable the Peripheral */
   2359              __HAL_TIM_DISABLE(htim);
   2360          
   2361              /* Set the TIM channel state */
   2362              TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
   2363              TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
   2364            }
   2365          
   2366            /* Return function status */
   2367            return status;
   2368          }
   2369          
   2370          /**
   2371            * @brief  Starts the TIM Input Capture measurement in DMA mode.
   2372            * @param  htim TIM Input Capture handle
   2373            * @param  Channel TIM Channels to be enabled
   2374            *          This parameter can be one of the following values:
   2375            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2376            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2377            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   2378            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   2379            * @param  pData The destination Buffer address.
   2380            * @param  Length The length of data to be transferred from TIM peripheral to memory.
   2381            * @retval HAL status
   2382            */
   2383          HAL_StatusTypeDef HAL_TIM_IC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
   2384          {
   2385            HAL_StatusTypeDef status = HAL_OK;
   2386            uint32_t tmpsmcr;
   2387          
   2388            HAL_TIM_ChannelStateTypeDef channel_state = TIM_CHANNEL_STATE_GET(htim, Channel);
   2389            HAL_TIM_ChannelStateTypeDef complementary_channel_state = TIM_CHANNEL_N_STATE_GET(htim, Channel);
   2390          
   2391            /* Check the parameters */
   2392            assert_param(IS_TIM_CCX_CHANNEL(htim->Instance, Channel));
   2393            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   2394          
   2395            /* Set the TIM channel state */
   2396            if ((channel_state == HAL_TIM_CHANNEL_STATE_BUSY)
   2397                || (complementary_channel_state == HAL_TIM_CHANNEL_STATE_BUSY))
   2398            {
   2399              return HAL_BUSY;
   2400            }
   2401            else if ((channel_state == HAL_TIM_CHANNEL_STATE_READY)
   2402                     && (complementary_channel_state == HAL_TIM_CHANNEL_STATE_READY))
   2403            {
   2404              if ((pData == NULL) || (Length == 0U))
   2405              {
   2406                return HAL_ERROR;
   2407              }
   2408              else
   2409              {
   2410                TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
   2411                TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
   2412              }
   2413            }
   2414            else
   2415            {
   2416              return HAL_ERROR;
   2417            }
   2418          
   2419            /* Enable the Input Capture channel */
   2420            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   2421          
   2422            switch (Channel)
   2423            {
   2424              case TIM_CHANNEL_1:
   2425              {
   2426                /* Set the DMA capture callbacks */
   2427                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
   2428                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   2429          
   2430                /* Set the DMA error callback */
   2431                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   2432          
   2433                /* Enable the DMA channel */
   2434                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData,
   2435                                     Length) != HAL_OK)
   2436                {
   2437                  /* Return error status */
   2438                  return HAL_ERROR;
   2439                }
   2440                /* Enable the TIM Capture/Compare 1 DMA request */
   2441                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   2442                break;
   2443              }
   2444          
   2445              case TIM_CHANNEL_2:
   2446              {
   2447                /* Set the DMA capture callbacks */
   2448                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
   2449                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   2450          
   2451                /* Set the DMA error callback */
   2452                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   2453          
   2454                /* Enable the DMA channel */
   2455                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData,
   2456                                     Length) != HAL_OK)
   2457                {
   2458                  /* Return error status */
   2459                  return HAL_ERROR;
   2460                }
   2461                /* Enable the TIM Capture/Compare 2  DMA request */
   2462                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   2463                break;
   2464              }
   2465          
   2466              case TIM_CHANNEL_3:
   2467              {
   2468                /* Set the DMA capture callbacks */
   2469                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMACaptureCplt;
   2470                htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   2471          
   2472                /* Set the DMA error callback */
   2473                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   2474          
   2475                /* Enable the DMA channel */
   2476                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->CCR3, (uint32_t)pData,
   2477                                     Length) != HAL_OK)
   2478                {
   2479                  /* Return error status */
   2480                  return HAL_ERROR;
   2481                }
   2482                /* Enable the TIM Capture/Compare 3  DMA request */
   2483                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   2484                break;
   2485              }
   2486          
   2487              case TIM_CHANNEL_4:
   2488              {
   2489                /* Set the DMA capture callbacks */
   2490                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMACaptureCplt;
   2491                htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   2492          
   2493                /* Set the DMA error callback */
   2494                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   2495          
   2496                /* Enable the DMA channel */
   2497                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->CCR4, (uint32_t)pData,
   2498                                     Length) != HAL_OK)
   2499                {
   2500                  /* Return error status */
   2501                  return HAL_ERROR;
   2502                }
   2503                /* Enable the TIM Capture/Compare 4  DMA request */
   2504                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   2505                break;
   2506              }
   2507          
   2508              default:
   2509                status = HAL_ERROR;
   2510                break;
   2511            }
   2512          
   2513            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   2514            if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
   2515            {
   2516              tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   2517              if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   2518              {
   2519                __HAL_TIM_ENABLE(htim);
   2520              }
   2521            }
   2522            else
   2523            {
   2524              __HAL_TIM_ENABLE(htim);
   2525            }
   2526          
   2527            /* Return function status */
   2528            return status;
   2529          }
   2530          
   2531          /**
   2532            * @brief  Stops the TIM Input Capture measurement in DMA mode.
   2533            * @param  htim TIM Input Capture handle
   2534            * @param  Channel TIM Channels to be disabled
   2535            *          This parameter can be one of the following values:
   2536            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2537            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2538            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   2539            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   2540            * @retval HAL status
   2541            */
   2542          HAL_StatusTypeDef HAL_TIM_IC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   2543          {
   2544            HAL_StatusTypeDef status = HAL_OK;
   2545          
   2546            /* Check the parameters */
   2547            assert_param(IS_TIM_CCX_CHANNEL(htim->Instance, Channel));
   2548            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   2549          
   2550            /* Disable the Input Capture channel */
   2551            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   2552          
   2553            switch (Channel)
   2554            {
   2555              case TIM_CHANNEL_1:
   2556              {
   2557                /* Disable the TIM Capture/Compare 1 DMA request */
   2558                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   2559                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   2560                break;
   2561              }
   2562          
   2563              case TIM_CHANNEL_2:
   2564              {
   2565                /* Disable the TIM Capture/Compare 2 DMA request */
   2566                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   2567                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   2568                break;
   2569              }
   2570          
   2571              case TIM_CHANNEL_3:
   2572              {
   2573                /* Disable the TIM Capture/Compare 3  DMA request */
   2574                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   2575                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
   2576                break;
   2577              }
   2578          
   2579              case TIM_CHANNEL_4:
   2580              {
   2581                /* Disable the TIM Capture/Compare 4  DMA request */
   2582                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   2583                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
   2584                break;
   2585              }
   2586          
   2587              default:
   2588                status = HAL_ERROR;
   2589                break;
   2590            }
   2591          
   2592            if (status == HAL_OK)
   2593            {
   2594              /* Disable the Peripheral */
   2595              __HAL_TIM_DISABLE(htim);
   2596          
   2597              /* Set the TIM channel state */
   2598              TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
   2599              TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
   2600            }
   2601          
   2602            /* Return function status */
   2603            return status;
   2604          }
   2605          /**
   2606            * @}
   2607            */
   2608          
   2609          /** @defgroup TIM_Exported_Functions_Group5 TIM One Pulse functions
   2610            *  @brief    TIM One Pulse functions
   2611            *
   2612          @verbatim
   2613            ==============================================================================
   2614                                  ##### TIM One Pulse functions #####
   2615            ==============================================================================
   2616            [..]
   2617              This section provides functions allowing to:
   2618              (+) Initialize and configure the TIM One Pulse.
   2619              (+) De-initialize the TIM One Pulse.
   2620              (+) Start the TIM One Pulse.
   2621              (+) Stop the TIM One Pulse.
   2622              (+) Start the TIM One Pulse and enable interrupt.
   2623              (+) Stop the TIM One Pulse and disable interrupt.
   2624              (+) Start the TIM One Pulse and enable DMA transfer.
   2625              (+) Stop the TIM One Pulse and disable DMA transfer.
   2626          
   2627          @endverbatim
   2628            * @{
   2629            */
   2630          /**
   2631            * @brief  Initializes the TIM One Pulse Time Base according to the specified
   2632            *         parameters in the TIM_HandleTypeDef and initializes the associated handle.
   2633            * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
   2634            *         requires a timer reset to avoid unexpected direction
   2635            *         due to DIR bit readonly in center aligned mode.
   2636            *         Ex: call @ref HAL_TIM_OnePulse_DeInit() before HAL_TIM_OnePulse_Init()
   2637            * @note   When the timer instance is initialized in One Pulse mode, timer
   2638            *         channels 1 and channel 2 are reserved and cannot be used for other
   2639            *         purpose.
   2640            * @param  htim TIM One Pulse handle
   2641            * @param  OnePulseMode Select the One pulse mode.
   2642            *         This parameter can be one of the following values:
   2643            *            @arg TIM_OPMODE_SINGLE: Only one pulse will be generated.
   2644            *            @arg TIM_OPMODE_REPETITIVE: Repetitive pulses will be generated.
   2645            * @retval HAL status
   2646            */
   2647          HAL_StatusTypeDef HAL_TIM_OnePulse_Init(TIM_HandleTypeDef *htim, uint32_t OnePulseMode)
   2648          {
   2649            /* Check the TIM handle allocation */
   2650            if (htim == NULL)
   2651            {
   2652              return HAL_ERROR;
   2653            }
   2654          
   2655            /* Check the parameters */
   2656            assert_param(IS_TIM_INSTANCE(htim->Instance));
   2657            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   2658            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   2659            assert_param(IS_TIM_OPM_MODE(OnePulseMode));
   2660            assert_param(IS_TIM_PERIOD(htim, htim->Init.Period));
   2661            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
   2662          
   2663            if (htim->State == HAL_TIM_STATE_RESET)
   2664            {
   2665              /* Allocate lock resource and initialize it */
   2666              htim->Lock = HAL_UNLOCKED;
   2667          
   2668          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   2669              /* Reset interrupt callbacks to legacy weak callbacks */
   2670              TIM_ResetCallback(htim);
   2671          
   2672              if (htim->OnePulse_MspInitCallback == NULL)
   2673              {
   2674                htim->OnePulse_MspInitCallback = HAL_TIM_OnePulse_MspInit;
   2675              }
   2676              /* Init the low level hardware : GPIO, CLOCK, NVIC */
   2677              htim->OnePulse_MspInitCallback(htim);
   2678          #else
   2679              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   2680              HAL_TIM_OnePulse_MspInit(htim);
   2681          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   2682            }
   2683          
   2684            /* Set the TIM state */
   2685            htim->State = HAL_TIM_STATE_BUSY;
   2686          
   2687            /* Configure the Time base in the One Pulse Mode */
   2688            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   2689          
   2690            /* Reset the OPM Bit */
   2691            htim->Instance->CR1 &= ~TIM_CR1_OPM;
   2692          
   2693            /* Configure the OPM Mode */
   2694            htim->Instance->CR1 |= OnePulseMode;
   2695          
   2696            /* Initialize the DMA burst operation state */
   2697            htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
   2698          
   2699            /* Initialize the TIM channels state */
   2700            TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
   2701            TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
   2702            TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
   2703            TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
   2704          
   2705            /* Initialize the TIM state*/
   2706            htim->State = HAL_TIM_STATE_READY;
   2707          
   2708            return HAL_OK;
   2709          }
   2710          
   2711          /**
   2712            * @brief  DeInitializes the TIM One Pulse
   2713            * @param  htim TIM One Pulse handle
   2714            * @retval HAL status
   2715            */
   2716          HAL_StatusTypeDef HAL_TIM_OnePulse_DeInit(TIM_HandleTypeDef *htim)
   2717          {
   2718            /* Check the parameters */
   2719            assert_param(IS_TIM_INSTANCE(htim->Instance));
   2720          
   2721            htim->State = HAL_TIM_STATE_BUSY;
   2722          
   2723            /* Disable the TIM Peripheral Clock */
   2724            __HAL_TIM_DISABLE(htim);
   2725          
   2726          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   2727            if (htim->OnePulse_MspDeInitCallback == NULL)
   2728            {
   2729              htim->OnePulse_MspDeInitCallback = HAL_TIM_OnePulse_MspDeInit;
   2730            }
   2731            /* DeInit the low level hardware */
   2732            htim->OnePulse_MspDeInitCallback(htim);
   2733          #else
   2734            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
   2735            HAL_TIM_OnePulse_MspDeInit(htim);
   2736          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   2737          
   2738            /* Change the DMA burst operation state */
   2739            htim->DMABurstState = HAL_DMA_BURST_STATE_RESET;
   2740          
   2741            /* Set the TIM channel state */
   2742            TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_RESET);
   2743            TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_RESET);
   2744            TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_RESET);
   2745            TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_RESET);
   2746          
   2747            /* Change TIM state */
   2748            htim->State = HAL_TIM_STATE_RESET;
   2749          
   2750            /* Release Lock */
   2751            __HAL_UNLOCK(htim);
   2752          
   2753            return HAL_OK;
   2754          }
   2755          
   2756          /**
   2757            * @brief  Initializes the TIM One Pulse MSP.
   2758            * @param  htim TIM One Pulse handle
   2759            * @retval None
   2760            */
   2761          __weak void HAL_TIM_OnePulse_MspInit(TIM_HandleTypeDef *htim)
   2762          {
   2763            /* Prevent unused argument(s) compilation warning */
   2764            UNUSED(htim);
   2765          
   2766            /* NOTE : This function should not be modified, when the callback is needed,
   2767                      the HAL_TIM_OnePulse_MspInit could be implemented in the user file
   2768             */
   2769          }
   2770          
   2771          /**
   2772            * @brief  DeInitializes TIM One Pulse MSP.
   2773            * @param  htim TIM One Pulse handle
   2774            * @retval None
   2775            */
   2776          __weak void HAL_TIM_OnePulse_MspDeInit(TIM_HandleTypeDef *htim)
   2777          {
   2778            /* Prevent unused argument(s) compilation warning */
   2779            UNUSED(htim);
   2780          
   2781            /* NOTE : This function should not be modified, when the callback is needed,
   2782                      the HAL_TIM_OnePulse_MspDeInit could be implemented in the user file
   2783             */
   2784          }
   2785          
   2786          /**
   2787            * @brief  Starts the TIM One Pulse signal generation.
   2788            * @note Though OutputChannel parameter is deprecated and ignored by the function
   2789            *        it has been kept to avoid HAL_TIM API compatibility break.
   2790            * @note The pulse output channel is determined when calling
   2791            *       @ref HAL_TIM_OnePulse_ConfigChannel().
   2792            * @param  htim TIM One Pulse handle
   2793            * @param  OutputChannel See note above
   2794            * @retval HAL status
   2795            */
   2796          HAL_StatusTypeDef HAL_TIM_OnePulse_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2797          {
   2798            HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);
   2799            HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);
   2800            HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);
   2801            HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);
   2802          
   2803            /* Prevent unused argument(s) compilation warning */
   2804            UNUSED(OutputChannel);
   2805          
   2806            /* Check the TIM channels state */
   2807            if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
   2808                || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)
   2809                || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
   2810                || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))
   2811            {
   2812              return HAL_ERROR;
   2813            }
   2814          
   2815            /* Set the TIM channels state */
   2816            TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
   2817            TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
   2818            TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
   2819            TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
   2820          
   2821            /* Enable the Capture compare and the Input Capture channels
   2822              (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2823              if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2824              if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output
   2825              whatever the combination, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together
   2826          
   2827              No need to enable the counter, it's enabled automatically by hardware
   2828              (the counter starts in response to a stimulus and generate a pulse */
   2829          
   2830            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   2831            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   2832          
   2833            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   2834            {
   2835              /* Enable the main output */
   2836              __HAL_TIM_MOE_ENABLE(htim);
   2837            }
   2838          
   2839            /* Return function status */
   2840            return HAL_OK;
   2841          }
   2842          
   2843          /**
   2844            * @brief  Stops the TIM One Pulse signal generation.
   2845            * @note Though OutputChannel parameter is deprecated and ignored by the function
   2846            *        it has been kept to avoid HAL_TIM API compatibility break.
   2847            * @note The pulse output channel is determined when calling
   2848            *       @ref HAL_TIM_OnePulse_ConfigChannel().
   2849            * @param  htim TIM One Pulse handle
   2850            * @param  OutputChannel See note above
   2851            * @retval HAL status
   2852            */
   2853          HAL_StatusTypeDef HAL_TIM_OnePulse_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2854          {
   2855            /* Prevent unused argument(s) compilation warning */
   2856            UNUSED(OutputChannel);
   2857          
   2858            /* Disable the Capture compare and the Input Capture channels
   2859            (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2860            if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2861            if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output
   2862            whatever the combination, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
   2863          
   2864            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   2865            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   2866          
   2867            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   2868            {
   2869              /* Disable the Main Output */
   2870              __HAL_TIM_MOE_DISABLE(htim);
   2871            }
   2872          
   2873            /* Disable the Peripheral */
   2874            __HAL_TIM_DISABLE(htim);
   2875          
   2876            /* Set the TIM channels state */
   2877            TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
   2878            TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
   2879            TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
   2880            TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
   2881          
   2882            /* Return function status */
   2883            return HAL_OK;
   2884          }
   2885          
   2886          /**
   2887            * @brief  Starts the TIM One Pulse signal generation in interrupt mode.
   2888            * @note Though OutputChannel parameter is deprecated and ignored by the function
   2889            *        it has been kept to avoid HAL_TIM API compatibility break.
   2890            * @note The pulse output channel is determined when calling
   2891            *       @ref HAL_TIM_OnePulse_ConfigChannel().
   2892            * @param  htim TIM One Pulse handle
   2893            * @param  OutputChannel See note above
   2894            * @retval HAL status
   2895            */
   2896          HAL_StatusTypeDef HAL_TIM_OnePulse_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2897          {
   2898            HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);
   2899            HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);
   2900            HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);
   2901            HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);
   2902          
   2903            /* Prevent unused argument(s) compilation warning */
   2904            UNUSED(OutputChannel);
   2905          
   2906            /* Check the TIM channels state */
   2907            if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
   2908                || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)
   2909                || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
   2910                || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))
   2911            {
   2912              return HAL_ERROR;
   2913            }
   2914          
   2915            /* Set the TIM channels state */
   2916            TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
   2917            TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
   2918            TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
   2919            TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
   2920          
   2921            /* Enable the Capture compare and the Input Capture channels
   2922              (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2923              if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2924              if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output
   2925              whatever the combination, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together
   2926          
   2927              No need to enable the counter, it's enabled automatically by hardware
   2928              (the counter starts in response to a stimulus and generate a pulse */
   2929          
   2930            /* Enable the TIM Capture/Compare 1 interrupt */
   2931            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   2932          
   2933            /* Enable the TIM Capture/Compare 2 interrupt */
   2934            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   2935          
   2936            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   2937            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   2938          
   2939            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   2940            {
   2941              /* Enable the main output */
   2942              __HAL_TIM_MOE_ENABLE(htim);
   2943            }
   2944          
   2945            /* Return function status */
   2946            return HAL_OK;
   2947          }
   2948          
   2949          /**
   2950            * @brief  Stops the TIM One Pulse signal generation in interrupt mode.
   2951            * @note Though OutputChannel parameter is deprecated and ignored by the function
   2952            *        it has been kept to avoid HAL_TIM API compatibility break.
   2953            * @note The pulse output channel is determined when calling
   2954            *       @ref HAL_TIM_OnePulse_ConfigChannel().
   2955            * @param  htim TIM One Pulse handle
   2956            * @param  OutputChannel See note above
   2957            * @retval HAL status
   2958            */
   2959          HAL_StatusTypeDef HAL_TIM_OnePulse_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2960          {
   2961            /* Prevent unused argument(s) compilation warning */
   2962            UNUSED(OutputChannel);
   2963          
   2964            /* Disable the TIM Capture/Compare 1 interrupt */
   2965            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   2966          
   2967            /* Disable the TIM Capture/Compare 2 interrupt */
   2968            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   2969          
   2970            /* Disable the Capture compare and the Input Capture channels
   2971            (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2972            if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2973            if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output
   2974            whatever the combination, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
   2975            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   2976            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   2977          
   2978            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   2979            {
   2980              /* Disable the Main Output */
   2981              __HAL_TIM_MOE_DISABLE(htim);
   2982            }
   2983          
   2984            /* Disable the Peripheral */
   2985            __HAL_TIM_DISABLE(htim);
   2986          
   2987            /* Set the TIM channels state */
   2988            TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
   2989            TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
   2990            TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
   2991            TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
   2992          
   2993            /* Return function status */
   2994            return HAL_OK;
   2995          }
   2996          
   2997          /**
   2998            * @}
   2999            */
   3000          
   3001          /** @defgroup TIM_Exported_Functions_Group6 TIM Encoder functions
   3002            *  @brief    TIM Encoder functions
   3003            *
   3004          @verbatim
   3005            ==============================================================================
   3006                                    ##### TIM Encoder functions #####
   3007            ==============================================================================
   3008            [..]
   3009              This section provides functions allowing to:
   3010              (+) Initialize and configure the TIM Encoder.
   3011              (+) De-initialize the TIM Encoder.
   3012              (+) Start the TIM Encoder.
   3013              (+) Stop the TIM Encoder.
   3014              (+) Start the TIM Encoder and enable interrupt.
   3015              (+) Stop the TIM Encoder and disable interrupt.
   3016              (+) Start the TIM Encoder and enable DMA transfer.
   3017              (+) Stop the TIM Encoder and disable DMA transfer.
   3018          
   3019          @endverbatim
   3020            * @{
   3021            */
   3022          /**
   3023            * @brief  Initializes the TIM Encoder Interface and initialize the associated handle.
   3024            * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
   3025            *         requires a timer reset to avoid unexpected direction
   3026            *         due to DIR bit readonly in center aligned mode.
   3027            *         Ex: call @ref HAL_TIM_Encoder_DeInit() before HAL_TIM_Encoder_Init()
   3028            * @note   Encoder mode and External clock mode 2 are not compatible and must not be selected together
   3029            *         Ex: A call for @ref HAL_TIM_Encoder_Init will erase the settings of @ref HAL_TIM_ConfigClockSource
   3030            *         using TIM_CLOCKSOURCE_ETRMODE2 and vice versa
   3031            * @note   When the timer instance is initialized in Encoder mode, timer
   3032            *         channels 1 and channel 2 are reserved and cannot be used for other
   3033            *         purpose.
   3034            * @param  htim TIM Encoder Interface handle
   3035            * @param  sConfig TIM Encoder Interface configuration structure
   3036            * @retval HAL status
   3037            */
   3038          HAL_StatusTypeDef HAL_TIM_Encoder_Init(TIM_HandleTypeDef *htim, const TIM_Encoder_InitTypeDef *sConfig)
   3039          {
   3040            uint32_t tmpsmcr;
   3041            uint32_t tmpccmr1;
   3042            uint32_t tmpccer;
   3043          
   3044            /* Check the TIM handle allocation */
   3045            if (htim == NULL)
   3046            {
   3047              return HAL_ERROR;
   3048            }
   3049          
   3050            /* Check the parameters */
   3051            assert_param(IS_TIM_ENCODER_INTERFACE_INSTANCE(htim->Instance));
   3052            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   3053            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   3054            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
   3055            assert_param(IS_TIM_ENCODER_MODE(sConfig->EncoderMode));
   3056            assert_param(IS_TIM_IC_SELECTION(sConfig->IC1Selection));
   3057            assert_param(IS_TIM_IC_SELECTION(sConfig->IC2Selection));
   3058            assert_param(IS_TIM_ENCODERINPUT_POLARITY(sConfig->IC1Polarity));
   3059            assert_param(IS_TIM_ENCODERINPUT_POLARITY(sConfig->IC2Polarity));
   3060            assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
   3061            assert_param(IS_TIM_IC_PRESCALER(sConfig->IC2Prescaler));
   3062            assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
   3063            assert_param(IS_TIM_IC_FILTER(sConfig->IC2Filter));
   3064            assert_param(IS_TIM_PERIOD(htim, htim->Init.Period));
   3065          
   3066            if (htim->State == HAL_TIM_STATE_RESET)
   3067            {
   3068              /* Allocate lock resource and initialize it */
   3069              htim->Lock = HAL_UNLOCKED;
   3070          
   3071          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3072              /* Reset interrupt callbacks to legacy weak callbacks */
   3073              TIM_ResetCallback(htim);
   3074          
   3075              if (htim->Encoder_MspInitCallback == NULL)
   3076              {
   3077                htim->Encoder_MspInitCallback = HAL_TIM_Encoder_MspInit;
   3078              }
   3079              /* Init the low level hardware : GPIO, CLOCK, NVIC */
   3080              htim->Encoder_MspInitCallback(htim);
   3081          #else
   3082              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   3083              HAL_TIM_Encoder_MspInit(htim);
   3084          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3085            }
   3086          
   3087            /* Set the TIM state */
   3088            htim->State = HAL_TIM_STATE_BUSY;
   3089          
   3090            /* Reset the SMS and ECE bits */
   3091            htim->Instance->SMCR &= ~(TIM_SMCR_SMS | TIM_SMCR_ECE);
   3092          
   3093            /* Configure the Time base in the Encoder Mode */
   3094            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   3095          
   3096            /* Get the TIMx SMCR register value */
   3097            tmpsmcr = htim->Instance->SMCR;
   3098          
   3099            /* Get the TIMx CCMR1 register value */
   3100            tmpccmr1 = htim->Instance->CCMR1;
   3101          
   3102            /* Get the TIMx CCER register value */
   3103            tmpccer = htim->Instance->CCER;
   3104          
   3105            /* Set the encoder Mode */
   3106            tmpsmcr |= sConfig->EncoderMode;
   3107          
   3108            /* Select the Capture Compare 1 and the Capture Compare 2 as input */
   3109            tmpccmr1 &= ~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S);
   3110            tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8U));
   3111          
   3112            /* Set the Capture Compare 1 and the Capture Compare 2 prescalers and filters */
   3113            tmpccmr1 &= ~(TIM_CCMR1_IC1PSC | TIM_CCMR1_IC2PSC);
   3114            tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);
   3115            tmpccmr1 |= sConfig->IC1Prescaler | (sConfig->IC2Prescaler << 8U);
   3116            tmpccmr1 |= (sConfig->IC1Filter << 4U) | (sConfig->IC2Filter << 12U);
   3117          
   3118            /* Set the TI1 and the TI2 Polarities */
   3119            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC2P);
   3120            tmpccer &= ~(TIM_CCER_CC1NP | TIM_CCER_CC2NP);
   3121            tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4U);
   3122          
   3123            /* Write to TIMx SMCR */
   3124            htim->Instance->SMCR = tmpsmcr;
   3125          
   3126            /* Write to TIMx CCMR1 */
   3127            htim->Instance->CCMR1 = tmpccmr1;
   3128          
   3129            /* Write to TIMx CCER */
   3130            htim->Instance->CCER = tmpccer;
   3131          
   3132            /* Initialize the DMA burst operation state */
   3133            htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
   3134          
   3135            /* Set the TIM channels state */
   3136            TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
   3137            TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
   3138            TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
   3139            TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
   3140          
   3141            /* Initialize the TIM state*/
   3142            htim->State = HAL_TIM_STATE_READY;
   3143          
   3144            return HAL_OK;
   3145          }
   3146          
   3147          
   3148          /**
   3149            * @brief  DeInitializes the TIM Encoder interface
   3150            * @param  htim TIM Encoder Interface handle
   3151            * @retval HAL status
   3152            */
   3153          HAL_StatusTypeDef HAL_TIM_Encoder_DeInit(TIM_HandleTypeDef *htim)
   3154          {
   3155            /* Check the parameters */
   3156            assert_param(IS_TIM_INSTANCE(htim->Instance));
   3157          
   3158            htim->State = HAL_TIM_STATE_BUSY;
   3159          
   3160            /* Disable the TIM Peripheral Clock */
   3161            __HAL_TIM_DISABLE(htim);
   3162          
   3163          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3164            if (htim->Encoder_MspDeInitCallback == NULL)
   3165            {
   3166              htim->Encoder_MspDeInitCallback = HAL_TIM_Encoder_MspDeInit;
   3167            }
   3168            /* DeInit the low level hardware */
   3169            htim->Encoder_MspDeInitCallback(htim);
   3170          #else
   3171            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
   3172            HAL_TIM_Encoder_MspDeInit(htim);
   3173          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3174          
   3175            /* Change the DMA burst operation state */
   3176            htim->DMABurstState = HAL_DMA_BURST_STATE_RESET;
   3177          
   3178            /* Set the TIM channels state */
   3179            TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_RESET);
   3180            TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_RESET);
   3181            TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_RESET);
   3182            TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_RESET);
   3183          
   3184            /* Change TIM state */
   3185            htim->State = HAL_TIM_STATE_RESET;
   3186          
   3187            /* Release Lock */
   3188            __HAL_UNLOCK(htim);
   3189          
   3190            return HAL_OK;
   3191          }
   3192          
   3193          /**
   3194            * @brief  Initializes the TIM Encoder Interface MSP.
   3195            * @param  htim TIM Encoder Interface handle
   3196            * @retval None
   3197            */
   3198          __weak void HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef *htim)
   3199          {
   3200            /* Prevent unused argument(s) compilation warning */
   3201            UNUSED(htim);
   3202          
   3203            /* NOTE : This function should not be modified, when the callback is needed,
   3204                      the HAL_TIM_Encoder_MspInit could be implemented in the user file
   3205             */
   3206          }
   3207          
   3208          /**
   3209            * @brief  DeInitializes TIM Encoder Interface MSP.
   3210            * @param  htim TIM Encoder Interface handle
   3211            * @retval None
   3212            */
   3213          __weak void HAL_TIM_Encoder_MspDeInit(TIM_HandleTypeDef *htim)
   3214          {
   3215            /* Prevent unused argument(s) compilation warning */
   3216            UNUSED(htim);
   3217          
   3218            /* NOTE : This function should not be modified, when the callback is needed,
   3219                      the HAL_TIM_Encoder_MspDeInit could be implemented in the user file
   3220             */
   3221          }
   3222          
   3223          /**
   3224            * @brief  Starts the TIM Encoder Interface.
   3225            * @param  htim TIM Encoder Interface handle
   3226            * @param  Channel TIM Channels to be enabled
   3227            *          This parameter can be one of the following values:
   3228            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3229            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3230            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   3231            * @retval HAL status
   3232            */
   3233          HAL_StatusTypeDef HAL_TIM_Encoder_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
   3234          {
   3235            HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);
   3236            HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);
   3237            HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);
   3238            HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);
   3239          
   3240            /* Check the parameters */
   3241            assert_param(IS_TIM_ENCODER_INTERFACE_INSTANCE(htim->Instance));
   3242          
   3243            /* Set the TIM channel(s) state */
   3244            if (Channel == TIM_CHANNEL_1)
   3245            {
   3246              if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
   3247                  || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY))
   3248              {
   3249                return HAL_ERROR;
   3250              }
   3251              else
   3252              {
   3253                TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
   3254                TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
   3255              }
   3256            }
   3257            else if (Channel == TIM_CHANNEL_2)
   3258            {
   3259              if ((channel_2_state != HAL_TIM_CHANNEL_STATE_READY)
   3260                  || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))
   3261              {
   3262                return HAL_ERROR;
   3263              }
   3264              else
   3265              {
   3266                TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
   3267                TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
   3268              }
   3269            }
   3270            else
   3271            {
   3272              if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
   3273                  || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)
   3274                  || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
   3275                  || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))
   3276              {
   3277                return HAL_ERROR;
   3278              }
   3279              else
   3280              {
   3281                TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
   3282                TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
   3283                TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
   3284                TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
   3285              }
   3286            }
   3287          
   3288            /* Enable the encoder interface channels */
   3289            switch (Channel)
   3290            {
   3291              case TIM_CHANNEL_1:
   3292              {
   3293                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   3294                break;
   3295              }
   3296          
   3297              case TIM_CHANNEL_2:
   3298              {
   3299                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   3300                break;
   3301              }
   3302          
   3303              default :
   3304              {
   3305                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   3306                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   3307                break;
   3308              }
   3309            }
   3310            /* Enable the Peripheral */
   3311            __HAL_TIM_ENABLE(htim);
   3312          
   3313            /* Return function status */
   3314            return HAL_OK;
   3315          }
   3316          
   3317          /**
   3318            * @brief  Stops the TIM Encoder Interface.
   3319            * @param  htim TIM Encoder Interface handle
   3320            * @param  Channel TIM Channels to be disabled
   3321            *          This parameter can be one of the following values:
   3322            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3323            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3324            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   3325            * @retval HAL status
   3326            */
   3327          HAL_StatusTypeDef HAL_TIM_Encoder_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   3328          {
   3329            /* Check the parameters */
   3330            assert_param(IS_TIM_ENCODER_INTERFACE_INSTANCE(htim->Instance));
   3331          
   3332            /* Disable the Input Capture channels 1 and 2
   3333              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
   3334            switch (Channel)
   3335            {
   3336              case TIM_CHANNEL_1:
   3337              {
   3338                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   3339                break;
   3340              }
   3341          
   3342              case TIM_CHANNEL_2:
   3343              {
   3344                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   3345                break;
   3346              }
   3347          
   3348              default :
   3349              {
   3350                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   3351                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   3352                break;
   3353              }
   3354            }
   3355          
   3356            /* Disable the Peripheral */
   3357            __HAL_TIM_DISABLE(htim);
   3358          
   3359            /* Set the TIM channel(s) state */
   3360            if ((Channel == TIM_CHANNEL_1) || (Channel == TIM_CHANNEL_2))
   3361            {
   3362              TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
   3363              TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
   3364            }
   3365            else
   3366            {
   3367              TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
   3368              TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
   3369              TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
   3370              TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
   3371            }
   3372          
   3373            /* Return function status */
   3374            return HAL_OK;
   3375          }
   3376          
   3377          /**
   3378            * @brief  Starts the TIM Encoder Interface in interrupt mode.
   3379            * @param  htim TIM Encoder Interface handle
   3380            * @param  Channel TIM Channels to be enabled
   3381            *          This parameter can be one of the following values:
   3382            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3383            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3384            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   3385            * @retval HAL status
   3386            */
   3387          HAL_StatusTypeDef HAL_TIM_Encoder_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   3388          {
   3389            HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);
   3390            HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);
   3391            HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);
   3392            HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);
   3393          
   3394            /* Check the parameters */
   3395            assert_param(IS_TIM_ENCODER_INTERFACE_INSTANCE(htim->Instance));
   3396          
   3397            /* Set the TIM channel(s) state */
   3398            if (Channel == TIM_CHANNEL_1)
   3399            {
   3400              if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
   3401                  || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY))
   3402              {
   3403                return HAL_ERROR;
   3404              }
   3405              else
   3406              {
   3407                TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
   3408                TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
   3409              }
   3410            }
   3411            else if (Channel == TIM_CHANNEL_2)
   3412            {
   3413              if ((channel_2_state != HAL_TIM_CHANNEL_STATE_READY)
   3414                  || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))
   3415              {
   3416                return HAL_ERROR;
   3417              }
   3418              else
   3419              {
   3420                TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
   3421                TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
   3422              }
   3423            }
   3424            else
   3425            {
   3426              if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
   3427                  || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)
   3428                  || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
   3429                  || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))
   3430              {
   3431                return HAL_ERROR;
   3432              }
   3433              else
   3434              {
   3435                TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
   3436                TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
   3437                TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
   3438                TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
   3439              }
   3440            }
   3441          
   3442            /* Enable the encoder interface channels */
   3443            /* Enable the capture compare Interrupts 1 and/or 2 */
   3444            switch (Channel)
   3445            {
   3446              case TIM_CHANNEL_1:
   3447              {
   3448                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   3449                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   3450                break;
   3451              }
   3452          
   3453              case TIM_CHANNEL_2:
   3454              {
   3455                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   3456                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   3457                break;
   3458              }
   3459          
   3460              default :
   3461              {
   3462                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   3463                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   3464                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   3465                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   3466                break;
   3467              }
   3468            }
   3469          
   3470            /* Enable the Peripheral */
   3471            __HAL_TIM_ENABLE(htim);
   3472          
   3473            /* Return function status */
   3474            return HAL_OK;
   3475          }
   3476          
   3477          /**
   3478            * @brief  Stops the TIM Encoder Interface in interrupt mode.
   3479            * @param  htim TIM Encoder Interface handle
   3480            * @param  Channel TIM Channels to be disabled
   3481            *          This parameter can be one of the following values:
   3482            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3483            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3484            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   3485            * @retval HAL status
   3486            */
   3487          HAL_StatusTypeDef HAL_TIM_Encoder_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   3488          {
   3489            /* Check the parameters */
   3490            assert_param(IS_TIM_ENCODER_INTERFACE_INSTANCE(htim->Instance));
   3491          
   3492            /* Disable the Input Capture channels 1 and 2
   3493              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
   3494            if (Channel == TIM_CHANNEL_1)
   3495            {
   3496              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   3497          
   3498              /* Disable the capture compare Interrupts 1 */
   3499              __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   3500            }
   3501            else if (Channel == TIM_CHANNEL_2)
   3502            {
   3503              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   3504          
   3505              /* Disable the capture compare Interrupts 2 */
   3506              __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   3507            }
   3508            else
   3509            {
   3510              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   3511              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   3512          
   3513              /* Disable the capture compare Interrupts 1 and 2 */
   3514              __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   3515              __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   3516            }
   3517          
   3518            /* Disable the Peripheral */
   3519            __HAL_TIM_DISABLE(htim);
   3520          
   3521            /* Set the TIM channel(s) state */
   3522            if ((Channel == TIM_CHANNEL_1) || (Channel == TIM_CHANNEL_2))
   3523            {
   3524              TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
   3525              TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
   3526            }
   3527            else
   3528            {
   3529              TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
   3530              TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
   3531              TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
   3532              TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
   3533            }
   3534          
   3535            /* Return function status */
   3536            return HAL_OK;
   3537          }
   3538          
   3539          /**
   3540            * @brief  Starts the TIM Encoder Interface in DMA mode.
   3541            * @param  htim TIM Encoder Interface handle
   3542            * @param  Channel TIM Channels to be enabled
   3543            *          This parameter can be one of the following values:
   3544            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3545            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3546            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   3547            * @param  pData1 The destination Buffer address for IC1.
   3548            * @param  pData2 The destination Buffer address for IC2.
   3549            * @param  Length The length of data to be transferred from TIM peripheral to memory.
   3550            * @retval HAL status
   3551            */
   3552          HAL_StatusTypeDef HAL_TIM_Encoder_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData1,
   3553                                                      uint32_t *pData2, uint16_t Length)
   3554          {
   3555            HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);
   3556            HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);
   3557            HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);
   3558            HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);
   3559          
   3560            /* Check the parameters */
   3561            assert_param(IS_TIM_ENCODER_INTERFACE_INSTANCE(htim->Instance));
   3562          
   3563            /* Set the TIM channel(s) state */
   3564            if (Channel == TIM_CHANNEL_1)
   3565            {
   3566              if ((channel_1_state == HAL_TIM_CHANNEL_STATE_BUSY)
   3567                  || (complementary_channel_1_state == HAL_TIM_CHANNEL_STATE_BUSY))
   3568              {
   3569                return HAL_BUSY;
   3570              }
   3571              else if ((channel_1_state == HAL_TIM_CHANNEL_STATE_READY)
   3572                       && (complementary_channel_1_state == HAL_TIM_CHANNEL_STATE_READY))
   3573              {
   3574                if ((pData1 == NULL) || (Length == 0U))
   3575                {
   3576                  return HAL_ERROR;
   3577                }
   3578                else
   3579                {
   3580                  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
   3581                  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
   3582                }
   3583              }
   3584              else
   3585              {
   3586                return HAL_ERROR;
   3587              }
   3588            }
   3589            else if (Channel == TIM_CHANNEL_2)
   3590            {
   3591              if ((channel_2_state == HAL_TIM_CHANNEL_STATE_BUSY)
   3592                  || (complementary_channel_2_state == HAL_TIM_CHANNEL_STATE_BUSY))
   3593              {
   3594                return HAL_BUSY;
   3595              }
   3596              else if ((channel_2_state == HAL_TIM_CHANNEL_STATE_READY)
   3597                       && (complementary_channel_2_state == HAL_TIM_CHANNEL_STATE_READY))
   3598              {
   3599                if ((pData2 == NULL) || (Length == 0U))
   3600                {
   3601                  return HAL_ERROR;
   3602                }
   3603                else
   3604                {
   3605                  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
   3606                  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
   3607                }
   3608              }
   3609              else
   3610              {
   3611                return HAL_ERROR;
   3612              }
   3613            }
   3614            else
   3615            {
   3616              if ((channel_1_state == HAL_TIM_CHANNEL_STATE_BUSY)
   3617                  || (channel_2_state == HAL_TIM_CHANNEL_STATE_BUSY)
   3618                  || (complementary_channel_1_state == HAL_TIM_CHANNEL_STATE_BUSY)
   3619                  || (complementary_channel_2_state == HAL_TIM_CHANNEL_STATE_BUSY))
   3620              {
   3621                return HAL_BUSY;
   3622              }
   3623              else if ((channel_1_state == HAL_TIM_CHANNEL_STATE_READY)
   3624                       && (channel_2_state == HAL_TIM_CHANNEL_STATE_READY)
   3625                       && (complementary_channel_1_state == HAL_TIM_CHANNEL_STATE_READY)
   3626                       && (complementary_channel_2_state == HAL_TIM_CHANNEL_STATE_READY))
   3627              {
   3628                if ((((pData1 == NULL) || (pData2 == NULL))) || (Length == 0U))
   3629                {
   3630                  return HAL_ERROR;
   3631                }
   3632                else
   3633                {
   3634                  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
   3635                  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
   3636                  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
   3637                  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
   3638                }
   3639              }
   3640              else
   3641              {
   3642                return HAL_ERROR;
   3643              }
   3644            }
   3645          
   3646            switch (Channel)
   3647            {
   3648              case TIM_CHANNEL_1:
   3649              {
   3650                /* Set the DMA capture callbacks */
   3651                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
   3652                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   3653          
   3654                /* Set the DMA error callback */
   3655                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   3656          
   3657                /* Enable the DMA channel */
   3658                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1,
   3659                                     Length) != HAL_OK)
   3660                {
   3661                  /* Return error status */
   3662                  return HAL_ERROR;
   3663                }
   3664                /* Enable the TIM Input Capture DMA request */
   3665                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   3666          
   3667                /* Enable the Capture compare channel */
   3668                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   3669          
   3670                /* Enable the Peripheral */
   3671                __HAL_TIM_ENABLE(htim);
   3672          
   3673                break;
   3674              }
   3675          
   3676              case TIM_CHANNEL_2:
   3677              {
   3678                /* Set the DMA capture callbacks */
   3679                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
   3680                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   3681          
   3682                /* Set the DMA error callback */
   3683                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError;
   3684                /* Enable the DMA channel */
   3685                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2,
   3686                                     Length) != HAL_OK)
   3687                {
   3688                  /* Return error status */
   3689                  return HAL_ERROR;
   3690                }
   3691                /* Enable the TIM Input Capture  DMA request */
   3692                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   3693          
   3694                /* Enable the Capture compare channel */
   3695                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   3696          
   3697                /* Enable the Peripheral */
   3698                __HAL_TIM_ENABLE(htim);
   3699          
   3700                break;
   3701              }
   3702          
   3703              default:
   3704              {
   3705                /* Set the DMA capture callbacks */
   3706                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
   3707                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   3708          
   3709                /* Set the DMA error callback */
   3710                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   3711          
   3712                /* Enable the DMA channel */
   3713                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1,
   3714                                     Length) != HAL_OK)
   3715                {
   3716                  /* Return error status */
   3717                  return HAL_ERROR;
   3718                }
   3719          
   3720                /* Set the DMA capture callbacks */
   3721                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
   3722                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   3723          
   3724                /* Set the DMA error callback */
   3725                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   3726          
   3727                /* Enable the DMA channel */
   3728                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2,
   3729                                     Length) != HAL_OK)
   3730                {
   3731                  /* Return error status */
   3732                  return HAL_ERROR;
   3733                }
   3734          
   3735                /* Enable the TIM Input Capture  DMA request */
   3736                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   3737                /* Enable the TIM Input Capture  DMA request */
   3738                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   3739          
   3740                /* Enable the Capture compare channel */
   3741                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   3742                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   3743          
   3744                /* Enable the Peripheral */
   3745                __HAL_TIM_ENABLE(htim);
   3746          
   3747                break;
   3748              }
   3749            }
   3750          
   3751            /* Return function status */
   3752            return HAL_OK;
   3753          }
   3754          
   3755          /**
   3756            * @brief  Stops the TIM Encoder Interface in DMA mode.
   3757            * @param  htim TIM Encoder Interface handle
   3758            * @param  Channel TIM Channels to be enabled
   3759            *          This parameter can be one of the following values:
   3760            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3761            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3762            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   3763            * @retval HAL status
   3764            */
   3765          HAL_StatusTypeDef HAL_TIM_Encoder_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   3766          {
   3767            /* Check the parameters */
   3768            assert_param(IS_TIM_ENCODER_INTERFACE_INSTANCE(htim->Instance));
   3769          
   3770            /* Disable the Input Capture channels 1 and 2
   3771              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
   3772            if (Channel == TIM_CHANNEL_1)
   3773            {
   3774              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   3775          
   3776              /* Disable the capture compare DMA Request 1 */
   3777              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   3778              (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   3779            }
   3780            else if (Channel == TIM_CHANNEL_2)
   3781            {
   3782              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   3783          
   3784              /* Disable the capture compare DMA Request 2 */
   3785              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   3786              (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   3787            }
   3788            else
   3789            {
   3790              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   3791              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   3792          
   3793              /* Disable the capture compare DMA Request 1 and 2 */
   3794              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   3795              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   3796              (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   3797              (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   3798            }
   3799          
   3800            /* Disable the Peripheral */
   3801            __HAL_TIM_DISABLE(htim);
   3802          
   3803            /* Set the TIM channel(s) state */
   3804            if ((Channel == TIM_CHANNEL_1) || (Channel == TIM_CHANNEL_2))
   3805            {
   3806              TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
   3807              TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
   3808            }
   3809            else
   3810            {
   3811              TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
   3812              TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
   3813              TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
   3814              TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
   3815            }
   3816          
   3817            /* Return function status */
   3818            return HAL_OK;
   3819          }
   3820          
   3821          /**
   3822            * @}
   3823            */
   3824          /** @defgroup TIM_Exported_Functions_Group7 TIM IRQ handler management
   3825            *  @brief    TIM IRQ handler management
   3826            *
   3827          @verbatim
   3828            ==============================================================================
   3829                                  ##### IRQ handler management #####
   3830            ==============================================================================
   3831            [..]
   3832              This section provides Timer IRQ handler function.
   3833          
   3834          @endverbatim
   3835            * @{
   3836            */
   3837          /**
   3838            * @brief  This function handles TIM interrupts requests.
   3839            * @param  htim TIM  handle
   3840            * @retval None
   3841            */
   3842          void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
   3843          {
   3844            uint32_t itsource = htim->Instance->DIER;
   3845            uint32_t itflag   = htim->Instance->SR;
   3846          
   3847            /* Capture compare 1 event */
   3848            if ((itflag & (TIM_FLAG_CC1)) == (TIM_FLAG_CC1))
   3849            {
   3850              if ((itsource & (TIM_IT_CC1)) == (TIM_IT_CC1))
   3851              {
   3852                {
   3853                  __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC1);
   3854                  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   3855          
   3856                  /* Input capture event */
   3857                  if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
   3858                  {
   3859          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3860                    htim->IC_CaptureCallback(htim);
   3861          #else
   3862                    HAL_TIM_IC_CaptureCallback(htim);
   3863          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3864                  }
   3865                  /* Output compare event */
   3866                  else
   3867                  {
   3868          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3869                    htim->OC_DelayElapsedCallback(htim);
   3870                    htim->PWM_PulseFinishedCallback(htim);
   3871          #else
   3872                    HAL_TIM_OC_DelayElapsedCallback(htim);
   3873                    HAL_TIM_PWM_PulseFinishedCallback(htim);
   3874          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3875                  }
   3876                  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   3877                }
   3878              }
   3879            }
   3880            /* Capture compare 2 event */
   3881            if ((itflag & (TIM_FLAG_CC2)) == (TIM_FLAG_CC2))
   3882            {
   3883              if ((itsource & (TIM_IT_CC2)) == (TIM_IT_CC2))
   3884              {
   3885                __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC2);
   3886                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   3887                /* Input capture event */
   3888                if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
   3889                {
   3890          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3891                  htim->IC_CaptureCallback(htim);
   3892          #else
   3893                  HAL_TIM_IC_CaptureCallback(htim);
   3894          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3895                }
   3896                /* Output compare event */
   3897                else
   3898                {
   3899          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3900                  htim->OC_DelayElapsedCallback(htim);
   3901                  htim->PWM_PulseFinishedCallback(htim);
   3902          #else
   3903                  HAL_TIM_OC_DelayElapsedCallback(htim);
   3904                  HAL_TIM_PWM_PulseFinishedCallback(htim);
   3905          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3906                }
   3907                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   3908              }
   3909            }
   3910            /* Capture compare 3 event */
   3911            if ((itflag & (TIM_FLAG_CC3)) == (TIM_FLAG_CC3))
   3912            {
   3913              if ((itsource & (TIM_IT_CC3)) == (TIM_IT_CC3))
   3914              {
   3915                __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC3);
   3916                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   3917                /* Input capture event */
   3918                if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
   3919                {
   3920          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3921                  htim->IC_CaptureCallback(htim);
   3922          #else
   3923                  HAL_TIM_IC_CaptureCallback(htim);
   3924          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3925                }
   3926                /* Output compare event */
   3927                else
   3928                {
   3929          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3930                  htim->OC_DelayElapsedCallback(htim);
   3931                  htim->PWM_PulseFinishedCallback(htim);
   3932          #else
   3933                  HAL_TIM_OC_DelayElapsedCallback(htim);
   3934                  HAL_TIM_PWM_PulseFinishedCallback(htim);
   3935          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3936                }
   3937                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   3938              }
   3939            }
   3940            /* Capture compare 4 event */
   3941            if ((itflag & (TIM_FLAG_CC4)) == (TIM_FLAG_CC4))
   3942            {
   3943              if ((itsource & (TIM_IT_CC4)) == (TIM_IT_CC4))
   3944              {
   3945                __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC4);
   3946                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   3947                /* Input capture event */
   3948                if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
   3949                {
   3950          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3951                  htim->IC_CaptureCallback(htim);
   3952          #else
   3953                  HAL_TIM_IC_CaptureCallback(htim);
   3954          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3955                }
   3956                /* Output compare event */
   3957                else
   3958                {
   3959          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3960                  htim->OC_DelayElapsedCallback(htim);
   3961                  htim->PWM_PulseFinishedCallback(htim);
   3962          #else
   3963                  HAL_TIM_OC_DelayElapsedCallback(htim);
   3964                  HAL_TIM_PWM_PulseFinishedCallback(htim);
   3965          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3966                }
   3967                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   3968              }
   3969            }
   3970            /* TIM Update event */
   3971            if ((itflag & (TIM_FLAG_UPDATE)) == (TIM_FLAG_UPDATE))
   3972            {
   3973              if ((itsource & (TIM_IT_UPDATE)) == (TIM_IT_UPDATE))
   3974              {
   3975                __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_UPDATE);
   3976          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3977                htim->PeriodElapsedCallback(htim);
   3978          #else
   3979                HAL_TIM_PeriodElapsedCallback(htim);
   3980          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3981              }
   3982            }
   3983            /* TIM Break input event */
   3984            if (((itflag & (TIM_FLAG_BREAK)) == (TIM_FLAG_BREAK)) || \
   3985                ((itflag & (TIM_FLAG_SYSTEM_BREAK)) == (TIM_FLAG_SYSTEM_BREAK)))
   3986            {
   3987              if ((itsource & (TIM_IT_BREAK)) == (TIM_IT_BREAK))
   3988              {
   3989                __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK | TIM_FLAG_SYSTEM_BREAK);
   3990          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3991                htim->BreakCallback(htim);
   3992          #else
   3993                HAL_TIMEx_BreakCallback(htim);
   3994          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3995              }
   3996            }
   3997            /* TIM Break2 input event */
   3998            if ((itflag & (TIM_FLAG_BREAK2)) == (TIM_FLAG_BREAK2))
   3999            {
   4000              if ((itsource & (TIM_IT_BREAK)) == (TIM_IT_BREAK))
   4001              {
   4002                __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
   4003          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   4004                htim->Break2Callback(htim);
   4005          #else
   4006                HAL_TIMEx_Break2Callback(htim);
   4007          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   4008              }
   4009            }
   4010            /* TIM Trigger detection event */
   4011            if ((itflag & (TIM_FLAG_TRIGGER)) == (TIM_FLAG_TRIGGER))
   4012            {
   4013              if ((itsource & (TIM_IT_TRIGGER)) == (TIM_IT_TRIGGER))
   4014              {
   4015                __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_TRIGGER);
   4016          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   4017                htim->TriggerCallback(htim);
   4018          #else
   4019                HAL_TIM_TriggerCallback(htim);
   4020          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   4021              }
   4022            }
   4023            /* TIM commutation event */
   4024            if ((itflag & (TIM_FLAG_COM)) == (TIM_FLAG_COM))
   4025            {
   4026              if ((itsource & (TIM_IT_COM)) == (TIM_IT_COM))
   4027              {
   4028                __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_COM);
   4029          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   4030                htim->CommutationCallback(htim);
   4031          #else
   4032                HAL_TIMEx_CommutCallback(htim);
   4033          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   4034              }
   4035            }
   4036          }
   4037          
   4038          /**
   4039            * @}
   4040            */
   4041          
   4042          /** @defgroup TIM_Exported_Functions_Group8 TIM Peripheral Control functions
   4043            *  @brief    TIM Peripheral Control functions
   4044            *
   4045          @verbatim
   4046            ==============================================================================
   4047                             ##### Peripheral Control functions #####
   4048            ==============================================================================
   4049           [..]
   4050             This section provides functions allowing to:
   4051                (+) Configure The Input Output channels for OC, PWM, IC or One Pulse mode.
   4052                (+) Configure External Clock source.
   4053                (+) Configure Complementary channels, break features and dead time.
   4054                (+) Configure Master and the Slave synchronization.
   4055                (+) Configure the DMA Burst Mode.
   4056          
   4057          @endverbatim
   4058            * @{
   4059            */
   4060          
   4061          /**
   4062            * @brief  Initializes the TIM Output Compare Channels according to the specified
   4063            *         parameters in the TIM_OC_InitTypeDef.
   4064            * @param  htim TIM Output Compare handle
   4065            * @param  sConfig TIM Output Compare configuration structure
   4066            * @param  Channel TIM Channels to configure
   4067            *          This parameter can be one of the following values:
   4068            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   4069            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   4070            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   4071            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   4072            *            @arg TIM_CHANNEL_5: TIM Channel 5 selected
   4073            *            @arg TIM_CHANNEL_6: TIM Channel 6 selected
   4074            * @retval HAL status
   4075            */
   4076          HAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim,
   4077                                                     const TIM_OC_InitTypeDef *sConfig,
   4078                                                     uint32_t Channel)
   4079          {
   4080            HAL_StatusTypeDef status = HAL_OK;
   4081          
   4082            /* Check the parameters */
   4083            assert_param(IS_TIM_CHANNELS(Channel));
   4084            assert_param(IS_TIM_OC_MODE(sConfig->OCMode));
   4085            assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
   4086          
   4087            /* Process Locked */
   4088            __HAL_LOCK(htim);
   4089          
   4090            switch (Channel)
   4091            {
   4092              case TIM_CHANNEL_1:
   4093              {
   4094                /* Check the parameters */
   4095                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   4096          
   4097                /* Configure the TIM Channel 1 in Output Compare */
   4098                TIM_OC1_SetConfig(htim->Instance, sConfig);
   4099                break;
   4100              }
   4101          
   4102              case TIM_CHANNEL_2:
   4103              {
   4104                /* Check the parameters */
   4105                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4106          
   4107                /* Configure the TIM Channel 2 in Output Compare */
   4108                TIM_OC2_SetConfig(htim->Instance, sConfig);
   4109                break;
   4110              }
   4111          
   4112              case TIM_CHANNEL_3:
   4113              {
   4114                /* Check the parameters */
   4115                assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   4116          
   4117                /* Configure the TIM Channel 3 in Output Compare */
   4118                TIM_OC3_SetConfig(htim->Instance, sConfig);
   4119                break;
   4120              }
   4121          
   4122              case TIM_CHANNEL_4:
   4123              {
   4124                /* Check the parameters */
   4125                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   4126          
   4127                /* Configure the TIM Channel 4 in Output Compare */
   4128                TIM_OC4_SetConfig(htim->Instance, sConfig);
   4129                break;
   4130              }
   4131          
   4132              case TIM_CHANNEL_5:
   4133              {
   4134                /* Check the parameters */
   4135                assert_param(IS_TIM_CC5_INSTANCE(htim->Instance));
   4136          
   4137                /* Configure the TIM Channel 5 in Output Compare */
   4138                TIM_OC5_SetConfig(htim->Instance, sConfig);
   4139                break;
   4140              }
   4141          
   4142              case TIM_CHANNEL_6:
   4143              {
   4144                /* Check the parameters */
   4145                assert_param(IS_TIM_CC6_INSTANCE(htim->Instance));
   4146          
   4147                /* Configure the TIM Channel 6 in Output Compare */
   4148                TIM_OC6_SetConfig(htim->Instance, sConfig);
   4149                break;
   4150              }
   4151          
   4152              default:
   4153                status = HAL_ERROR;
   4154                break;
   4155            }
   4156          
   4157            __HAL_UNLOCK(htim);
   4158          
   4159            return status;
   4160          }
   4161          
   4162          /**
   4163            * @brief  Initializes the TIM Input Capture Channels according to the specified
   4164            *         parameters in the TIM_IC_InitTypeDef.
   4165            * @param  htim TIM IC handle
   4166            * @param  sConfig TIM Input Capture configuration structure
   4167            * @param  Channel TIM Channel to configure
   4168            *          This parameter can be one of the following values:
   4169            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   4170            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   4171            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   4172            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   4173            * @retval HAL status
   4174            */
   4175          HAL_StatusTypeDef HAL_TIM_IC_ConfigChannel(TIM_HandleTypeDef *htim, const TIM_IC_InitTypeDef *sConfig, uint32_t Channel)
   4176          {
   4177            HAL_StatusTypeDef status = HAL_OK;
   4178          
   4179            /* Check the parameters */
   4180            assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   4181            assert_param(IS_TIM_IC_POLARITY(sConfig->ICPolarity));
   4182            assert_param(IS_TIM_IC_SELECTION(sConfig->ICSelection));
   4183            assert_param(IS_TIM_IC_PRESCALER(sConfig->ICPrescaler));
   4184            assert_param(IS_TIM_IC_FILTER(sConfig->ICFilter));
   4185          
   4186            /* Process Locked */
   4187            __HAL_LOCK(htim);
   4188          
   4189            if (Channel == TIM_CHANNEL_1)
   4190            {
   4191              /* TI1 Configuration */
   4192              TIM_TI1_SetConfig(htim->Instance,
   4193                                sConfig->ICPolarity,
   4194                                sConfig->ICSelection,
   4195                                sConfig->ICFilter);
   4196          
   4197              /* Reset the IC1PSC Bits */
   4198              htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
   4199          
   4200              /* Set the IC1PSC value */
   4201              htim->Instance->CCMR1 |= sConfig->ICPrescaler;
   4202            }
   4203            else if (Channel == TIM_CHANNEL_2)
   4204            {
   4205              /* TI2 Configuration */
   4206              assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4207          
   4208              TIM_TI2_SetConfig(htim->Instance,
   4209                                sConfig->ICPolarity,
   4210                                sConfig->ICSelection,
   4211                                sConfig->ICFilter);
   4212          
   4213              /* Reset the IC2PSC Bits */
   4214              htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
   4215          
   4216              /* Set the IC2PSC value */
   4217              htim->Instance->CCMR1 |= (sConfig->ICPrescaler << 8U);
   4218            }
   4219            else if (Channel == TIM_CHANNEL_3)
   4220            {
   4221              /* TI3 Configuration */
   4222              assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   4223          
   4224              TIM_TI3_SetConfig(htim->Instance,
   4225                                sConfig->ICPolarity,
   4226                                sConfig->ICSelection,
   4227                                sConfig->ICFilter);
   4228          
   4229              /* Reset the IC3PSC Bits */
   4230              htim->Instance->CCMR2 &= ~TIM_CCMR2_IC3PSC;
   4231          
   4232              /* Set the IC3PSC value */
   4233              htim->Instance->CCMR2 |= sConfig->ICPrescaler;
   4234            }
   4235            else if (Channel == TIM_CHANNEL_4)
   4236            {
   4237              /* TI4 Configuration */
   4238              assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   4239          
   4240              TIM_TI4_SetConfig(htim->Instance,
   4241                                sConfig->ICPolarity,
   4242                                sConfig->ICSelection,
   4243                                sConfig->ICFilter);
   4244          
   4245              /* Reset the IC4PSC Bits */
   4246              htim->Instance->CCMR2 &= ~TIM_CCMR2_IC4PSC;
   4247          
   4248              /* Set the IC4PSC value */
   4249              htim->Instance->CCMR2 |= (sConfig->ICPrescaler << 8U);
   4250            }
   4251            else
   4252            {
   4253              status = HAL_ERROR;
   4254            }
   4255          
   4256            __HAL_UNLOCK(htim);
   4257          
   4258            return status;
   4259          }
   4260          
   4261          /**
   4262            * @brief  Initializes the TIM PWM  channels according to the specified
   4263            *         parameters in the TIM_OC_InitTypeDef.
   4264            * @param  htim TIM PWM handle
   4265            * @param  sConfig TIM PWM configuration structure
   4266            * @param  Channel TIM Channels to be configured
   4267            *          This parameter can be one of the following values:
   4268            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   4269            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   4270            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   4271            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   4272            *            @arg TIM_CHANNEL_5: TIM Channel 5 selected
   4273            *            @arg TIM_CHANNEL_6: TIM Channel 6 selected
   4274            * @retval HAL status
   4275            */
   4276          HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim,
   4277                                                      const TIM_OC_InitTypeDef *sConfig,
   4278                                                      uint32_t Channel)
   4279          {
   4280            HAL_StatusTypeDef status = HAL_OK;
   4281          
   4282            /* Check the parameters */
   4283            assert_param(IS_TIM_CHANNELS(Channel));
   4284            assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
   4285            assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
   4286            assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));
   4287          
   4288            /* Process Locked */
   4289            __HAL_LOCK(htim);
   4290          
   4291            switch (Channel)
   4292            {
   4293              case TIM_CHANNEL_1:
   4294              {
   4295                /* Check the parameters */
   4296                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   4297          
   4298                /* Configure the Channel 1 in PWM mode */
   4299                TIM_OC1_SetConfig(htim->Instance, sConfig);
   4300          
   4301                /* Set the Preload enable bit for channel1 */
   4302                htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
   4303          
   4304                /* Configure the Output Fast mode */
   4305                htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
   4306                htim->Instance->CCMR1 |= sConfig->OCFastMode;
   4307                break;
   4308              }
   4309          
   4310              case TIM_CHANNEL_2:
   4311              {
   4312                /* Check the parameters */
   4313                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4314          
   4315                /* Configure the Channel 2 in PWM mode */
   4316                TIM_OC2_SetConfig(htim->Instance, sConfig);
   4317          
   4318                /* Set the Preload enable bit for channel2 */
   4319                htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
   4320          
   4321                /* Configure the Output Fast mode */
   4322                htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
   4323                htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
   4324                break;
   4325              }
   4326          
   4327              case TIM_CHANNEL_3:
   4328              {
   4329                /* Check the parameters */
   4330                assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   4331          
   4332                /* Configure the Channel 3 in PWM mode */
   4333                TIM_OC3_SetConfig(htim->Instance, sConfig);
   4334          
   4335                /* Set the Preload enable bit for channel3 */
   4336                htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
   4337          
   4338                /* Configure the Output Fast mode */
   4339                htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
   4340                htim->Instance->CCMR2 |= sConfig->OCFastMode;
   4341                break;
   4342              }
   4343          
   4344              case TIM_CHANNEL_4:
   4345              {
   4346                /* Check the parameters */
   4347                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   4348          
   4349                /* Configure the Channel 4 in PWM mode */
   4350                TIM_OC4_SetConfig(htim->Instance, sConfig);
   4351          
   4352                /* Set the Preload enable bit for channel4 */
   4353                htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
   4354          
   4355                /* Configure the Output Fast mode */
   4356                htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
   4357                htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
   4358                break;
   4359              }
   4360          
   4361              case TIM_CHANNEL_5:
   4362              {
   4363                /* Check the parameters */
   4364                assert_param(IS_TIM_CC5_INSTANCE(htim->Instance));
   4365          
   4366                /* Configure the Channel 5 in PWM mode */
   4367                TIM_OC5_SetConfig(htim->Instance, sConfig);
   4368          
   4369                /* Set the Preload enable bit for channel5*/
   4370                htim->Instance->CCMR3 |= TIM_CCMR3_OC5PE;
   4371          
   4372                /* Configure the Output Fast mode */
   4373                htim->Instance->CCMR3 &= ~TIM_CCMR3_OC5FE;
   4374                htim->Instance->CCMR3 |= sConfig->OCFastMode;
   4375                break;
   4376              }
   4377          
   4378              case TIM_CHANNEL_6:
   4379              {
   4380                /* Check the parameters */
   4381                assert_param(IS_TIM_CC6_INSTANCE(htim->Instance));
   4382          
   4383                /* Configure the Channel 6 in PWM mode */
   4384                TIM_OC6_SetConfig(htim->Instance, sConfig);
   4385          
   4386                /* Set the Preload enable bit for channel6 */
   4387                htim->Instance->CCMR3 |= TIM_CCMR3_OC6PE;
   4388          
   4389                /* Configure the Output Fast mode */
   4390                htim->Instance->CCMR3 &= ~TIM_CCMR3_OC6FE;
   4391                htim->Instance->CCMR3 |= sConfig->OCFastMode << 8U;
   4392                break;
   4393              }
   4394          
   4395              default:
   4396                status = HAL_ERROR;
   4397                break;
   4398            }
   4399          
   4400            __HAL_UNLOCK(htim);
   4401          
   4402            return status;
   4403          }
   4404          
   4405          /**
   4406            * @brief  Initializes the TIM One Pulse Channels according to the specified
   4407            *         parameters in the TIM_OnePulse_InitTypeDef.
   4408            * @param  htim TIM One Pulse handle
   4409            * @param  sConfig TIM One Pulse configuration structure
   4410            * @param  OutputChannel TIM output channel to configure
   4411            *          This parameter can be one of the following values:
   4412            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   4413            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   4414            * @param  InputChannel TIM input Channel to configure
   4415            *          This parameter can be one of the following values:
   4416            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   4417            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   4418            * @note  To output a waveform with a minimum delay user can enable the fast
   4419            *        mode by calling the @ref __HAL_TIM_ENABLE_OCxFAST macro. Then CCx
   4420            *        output is forced in response to the edge detection on TIx input,
   4421            *        without taking in account the comparison.
   4422            * @retval HAL status
   4423            */
   4424          HAL_StatusTypeDef HAL_TIM_OnePulse_ConfigChannel(TIM_HandleTypeDef *htim,  TIM_OnePulse_InitTypeDef *sConfig,
   4425                                                           uint32_t OutputChannel,  uint32_t InputChannel)
   4426          {
   4427            HAL_StatusTypeDef status = HAL_OK;
   4428            TIM_OC_InitTypeDef temp1;
   4429          
   4430            /* Check the parameters */
   4431            assert_param(IS_TIM_OPM_CHANNELS(OutputChannel));
   4432            assert_param(IS_TIM_OPM_CHANNELS(InputChannel));
   4433          
   4434            if (OutputChannel != InputChannel)
   4435            {
   4436              /* Process Locked */
   4437              __HAL_LOCK(htim);
   4438          
   4439              htim->State = HAL_TIM_STATE_BUSY;
   4440          
   4441              /* Extract the Output compare configuration from sConfig structure */
   4442              temp1.OCMode = sConfig->OCMode;
   4443              temp1.Pulse = sConfig->Pulse;
   4444              temp1.OCPolarity = sConfig->OCPolarity;
   4445              temp1.OCNPolarity = sConfig->OCNPolarity;
   4446              temp1.OCIdleState = sConfig->OCIdleState;
   4447              temp1.OCNIdleState = sConfig->OCNIdleState;
   4448          
   4449              switch (OutputChannel)
   4450              {
   4451                case TIM_CHANNEL_1:
   4452                {
   4453                  assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   4454          
   4455                  TIM_OC1_SetConfig(htim->Instance, &temp1);
   4456                  break;
   4457                }
   4458          
   4459                case TIM_CHANNEL_2:
   4460                {
   4461                  assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4462          
   4463                  TIM_OC2_SetConfig(htim->Instance, &temp1);
   4464                  break;
   4465                }
   4466          
   4467                default:
   4468                  status = HAL_ERROR;
   4469                  break;
   4470              }
   4471          
   4472              if (status == HAL_OK)
   4473              {
   4474                switch (InputChannel)
   4475                {
   4476                  case TIM_CHANNEL_1:
   4477                  {
   4478                    assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   4479          
   4480                    TIM_TI1_SetConfig(htim->Instance, sConfig->ICPolarity,
   4481                                      sConfig->ICSelection, sConfig->ICFilter);
   4482          
   4483                    /* Reset the IC1PSC Bits */
   4484                    htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
   4485          
   4486                    /* Select the Trigger source */
   4487                    htim->Instance->SMCR &= ~TIM_SMCR_TS;
   4488                    htim->Instance->SMCR |= TIM_TS_TI1FP1;
   4489          
   4490                    /* Select the Slave Mode */
   4491                    htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   4492                    htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
   4493                    break;
   4494                  }
   4495          
   4496                  case TIM_CHANNEL_2:
   4497                  {
   4498                    assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4499          
   4500                    TIM_TI2_SetConfig(htim->Instance, sConfig->ICPolarity,
   4501                                      sConfig->ICSelection, sConfig->ICFilter);
   4502          
   4503                    /* Reset the IC2PSC Bits */
   4504                    htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
   4505          
   4506                    /* Select the Trigger source */
   4507                    htim->Instance->SMCR &= ~TIM_SMCR_TS;
   4508                    htim->Instance->SMCR |= TIM_TS_TI2FP2;
   4509          
   4510                    /* Select the Slave Mode */
   4511                    htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   4512                    htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
   4513                    break;
   4514                  }
   4515          
   4516                  default:
   4517                    status = HAL_ERROR;
   4518                    break;
   4519                }
   4520              }
   4521          
   4522              htim->State = HAL_TIM_STATE_READY;
   4523          
   4524              __HAL_UNLOCK(htim);
   4525          
   4526              return status;
   4527            }
   4528            else
   4529            {
   4530              return HAL_ERROR;
   4531            }
   4532          }
   4533          
   4534          /**
   4535            * @brief  Configure the DMA Burst to transfer Data from the memory to the TIM peripheral
   4536            * @param  htim TIM handle
   4537            * @param  BurstBaseAddress TIM Base address from where the DMA  will start the Data write
   4538            *         This parameter can be one of the following values:
   4539            *            @arg TIM_DMABASE_CR1
   4540            *            @arg TIM_DMABASE_CR2
   4541            *            @arg TIM_DMABASE_SMCR
   4542            *            @arg TIM_DMABASE_DIER
   4543            *            @arg TIM_DMABASE_SR
   4544            *            @arg TIM_DMABASE_EGR
   4545            *            @arg TIM_DMABASE_CCMR1
   4546            *            @arg TIM_DMABASE_CCMR2
   4547            *            @arg TIM_DMABASE_CCER
   4548            *            @arg TIM_DMABASE_CNT
   4549            *            @arg TIM_DMABASE_PSC
   4550            *            @arg TIM_DMABASE_ARR
   4551            *            @arg TIM_DMABASE_RCR
   4552            *            @arg TIM_DMABASE_CCR1
   4553            *            @arg TIM_DMABASE_CCR2
   4554            *            @arg TIM_DMABASE_CCR3
   4555            *            @arg TIM_DMABASE_CCR4
   4556            *            @arg TIM_DMABASE_BDTR
   4557            *            @arg TIM_DMABASE_OR1
   4558            *            @arg TIM_DMABASE_CCMR3
   4559            *            @arg TIM_DMABASE_CCR5
   4560            *            @arg TIM_DMABASE_CCR6
   4561            *            @arg TIM_DMABASE_AF1
   4562            *            @arg TIM_DMABASE_AF2
   4563            *            @arg TIM_DMABASE_TISEL
   4564            * @param  BurstRequestSrc TIM DMA Request sources
   4565            *         This parameter can be one of the following values:
   4566            *            @arg TIM_DMA_UPDATE: TIM update Interrupt source
   4567            *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
   4568            *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
   4569            *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
   4570            *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
   4571            *            @arg TIM_DMA_COM: TIM Commutation DMA source
   4572            *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source
   4573            * @param  BurstBuffer The Buffer address.
   4574            * @param  BurstLength DMA Burst length. This parameter can be one value
   4575            *         between: TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.
   4576            * @note   This function should be used only when BurstLength is equal to DMA data transfer length.
   4577            * @retval HAL status
   4578            */
   4579          HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress,
   4580                                                        uint32_t BurstRequestSrc, const uint32_t *BurstBuffer,
   4581                                                        uint32_t  BurstLength)
   4582          {
   4583            HAL_StatusTypeDef status;
   4584          
   4585            status = HAL_TIM_DMABurst_MultiWriteStart(htim, BurstBaseAddress, BurstRequestSrc, BurstBuffer, BurstLength,
   4586                                                      ((BurstLength) >> 8U) + 1U);
   4587          
   4588          
   4589          
   4590            return status;
   4591          }
   4592          
   4593          /**
   4594            * @brief  Configure the DMA Burst to transfer multiple Data from the memory to the TIM peripheral
   4595            * @param  htim TIM handle
   4596            * @param  BurstBaseAddress TIM Base address from where the DMA will start the Data write
   4597            *         This parameter can be one of the following values:
   4598            *            @arg TIM_DMABASE_CR1
   4599            *            @arg TIM_DMABASE_CR2
   4600            *            @arg TIM_DMABASE_SMCR
   4601            *            @arg TIM_DMABASE_DIER
   4602            *            @arg TIM_DMABASE_SR
   4603            *            @arg TIM_DMABASE_EGR
   4604            *            @arg TIM_DMABASE_CCMR1
   4605            *            @arg TIM_DMABASE_CCMR2
   4606            *            @arg TIM_DMABASE_CCER
   4607            *            @arg TIM_DMABASE_CNT
   4608            *            @arg TIM_DMABASE_PSC
   4609            *            @arg TIM_DMABASE_ARR
   4610            *            @arg TIM_DMABASE_RCR
   4611            *            @arg TIM_DMABASE_CCR1
   4612            *            @arg TIM_DMABASE_CCR2
   4613            *            @arg TIM_DMABASE_CCR3
   4614            *            @arg TIM_DMABASE_CCR4
   4615            *            @arg TIM_DMABASE_BDTR
   4616            *            @arg TIM_DMABASE_OR1
   4617            *            @arg TIM_DMABASE_CCMR3
   4618            *            @arg TIM_DMABASE_CCR5
   4619            *            @arg TIM_DMABASE_CCR6
   4620            *            @arg TIM_DMABASE_AF1
   4621            *            @arg TIM_DMABASE_AF2
   4622            *            @arg TIM_DMABASE_TISEL
   4623            * @param  BurstRequestSrc TIM DMA Request sources
   4624            *         This parameter can be one of the following values:
   4625            *            @arg TIM_DMA_UPDATE: TIM update Interrupt source
   4626            *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
   4627            *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
   4628            *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
   4629            *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
   4630            *            @arg TIM_DMA_COM: TIM Commutation DMA source
   4631            *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source
   4632            * @param  BurstBuffer The Buffer address.
   4633            * @param  BurstLength DMA Burst length. This parameter can be one value
   4634            *         between: TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.
   4635            * @param  DataLength Data length. This parameter can be one value
   4636            *         between 1 and 0xFFFF.
   4637            * @retval HAL status
   4638            */
   4639          HAL_StatusTypeDef HAL_TIM_DMABurst_MultiWriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress,
   4640                                                             uint32_t BurstRequestSrc, const uint32_t *BurstBuffer,
   4641                                                             uint32_t  BurstLength,  uint32_t  DataLength)
   4642          {
   4643            HAL_StatusTypeDef status = HAL_OK;
   4644          
   4645            /* Check the parameters */
   4646            assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
   4647            assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
   4648            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   4649            assert_param(IS_TIM_DMA_LENGTH(BurstLength));
   4650            assert_param(IS_TIM_DMA_DATA_LENGTH(DataLength));
   4651          
   4652            if (htim->DMABurstState == HAL_DMA_BURST_STATE_BUSY)
   4653            {
   4654              return HAL_BUSY;
   4655            }
   4656            else if (htim->DMABurstState == HAL_DMA_BURST_STATE_READY)
   4657            {
   4658              if ((BurstBuffer == NULL) && (BurstLength > 0U))
   4659              {
   4660                return HAL_ERROR;
   4661              }
   4662              else
   4663              {
   4664                htim->DMABurstState = HAL_DMA_BURST_STATE_BUSY;
   4665              }
   4666            }
   4667            else
   4668            {
   4669              /* nothing to do */
   4670            }
   4671          
   4672            switch (BurstRequestSrc)
   4673            {
   4674              case TIM_DMA_UPDATE:
   4675              {
   4676                /* Set the DMA Period elapsed callbacks */
   4677                htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
   4678                htim->hdma[TIM_DMA_ID_UPDATE]->XferHalfCpltCallback = TIM_DMAPeriodElapsedHalfCplt;
   4679          
   4680                /* Set the DMA error callback */
   4681                htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
   4682          
   4683                /* Enable the DMA channel */
   4684                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)BurstBuffer,
   4685                                     (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)
   4686                {
   4687                  /* Return error status */
   4688                  return HAL_ERROR;
   4689                }
   4690                break;
   4691              }
   4692              case TIM_DMA_CC1:
   4693              {
   4694                /* Set the DMA compare callbacks */
   4695                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
   4696                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   4697          
   4698                /* Set the DMA error callback */
   4699                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   4700          
   4701                /* Enable the DMA channel */
   4702                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)BurstBuffer,
   4703                                     (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)
   4704                {
   4705                  /* Return error status */
   4706                  return HAL_ERROR;
   4707                }
   4708                break;
   4709              }
   4710              case TIM_DMA_CC2:
   4711              {
   4712                /* Set the DMA compare callbacks */
   4713                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
   4714                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   4715          
   4716                /* Set the DMA error callback */
   4717                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   4718          
   4719                /* Enable the DMA channel */
   4720                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)BurstBuffer,
   4721                                     (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)
   4722                {
   4723                  /* Return error status */
   4724                  return HAL_ERROR;
   4725                }
   4726                break;
   4727              }
   4728              case TIM_DMA_CC3:
   4729              {
   4730                /* Set the DMA compare callbacks */
   4731                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
   4732                htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   4733          
   4734                /* Set the DMA error callback */
   4735                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   4736          
   4737                /* Enable the DMA channel */
   4738                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)BurstBuffer,
   4739                                     (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)
   4740                {
   4741                  /* Return error status */
   4742                  return HAL_ERROR;
   4743                }
   4744                break;
   4745              }
   4746              case TIM_DMA_CC4:
   4747              {
   4748                /* Set the DMA compare callbacks */
   4749                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
   4750                htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   4751          
   4752                /* Set the DMA error callback */
   4753                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   4754          
   4755                /* Enable the DMA channel */
   4756                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)BurstBuffer,
   4757                                     (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)
   4758                {
   4759                  /* Return error status */
   4760                  return HAL_ERROR;
   4761                }
   4762                break;
   4763              }
   4764              case TIM_DMA_COM:
   4765              {
   4766                /* Set the DMA commutation callbacks */
   4767                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback =  TIMEx_DMACommutationCplt;
   4768                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferHalfCpltCallback =  TIMEx_DMACommutationHalfCplt;
   4769          
   4770                /* Set the DMA error callback */
   4771                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;
   4772          
   4773                /* Enable the DMA channel */
   4774                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)BurstBuffer,
   4775                                     (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)
   4776                {
   4777                  /* Return error status */
   4778                  return HAL_ERROR;
   4779                }
   4780                break;
   4781              }
   4782              case TIM_DMA_TRIGGER:
   4783              {
   4784                /* Set the DMA trigger callbacks */
   4785                htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
   4786                htim->hdma[TIM_DMA_ID_TRIGGER]->XferHalfCpltCallback = TIM_DMATriggerHalfCplt;
   4787          
   4788                /* Set the DMA error callback */
   4789                htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
   4790          
   4791                /* Enable the DMA channel */
   4792                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)BurstBuffer,
   4793                                     (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)
   4794                {
   4795                  /* Return error status */
   4796                  return HAL_ERROR;
   4797                }
   4798                break;
   4799              }
   4800              default:
   4801                status = HAL_ERROR;
   4802                break;
   4803            }
   4804          
   4805            if (status == HAL_OK)
   4806            {
   4807              /* Configure the DMA Burst Mode */
   4808              htim->Instance->DCR = (BurstBaseAddress | BurstLength);
   4809              /* Enable the TIM DMA Request */
   4810              __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
   4811            }
   4812          
   4813            /* Return function status */
   4814            return status;
   4815          }
   4816          
   4817          /**
   4818            * @brief  Stops the TIM DMA Burst mode
   4819            * @param  htim TIM handle
   4820            * @param  BurstRequestSrc TIM DMA Request sources to disable
   4821            * @retval HAL status
   4822            */
   4823          HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
   4824          {
   4825            HAL_StatusTypeDef status = HAL_OK;
   4826          
   4827            /* Check the parameters */
   4828            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   4829          
   4830            /* Abort the DMA transfer (at least disable the DMA channel) */
   4831            switch (BurstRequestSrc)
   4832            {
   4833              case TIM_DMA_UPDATE:
   4834              {
   4835                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_UPDATE]);
   4836                break;
   4837              }
   4838              case TIM_DMA_CC1:
   4839              {
   4840                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   4841                break;
   4842              }
   4843              case TIM_DMA_CC2:
   4844              {
   4845                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   4846                break;
   4847              }
   4848              case TIM_DMA_CC3:
   4849              {
   4850                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
   4851                break;
   4852              }
   4853              case TIM_DMA_CC4:
   4854              {
   4855                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
   4856                break;
   4857              }
   4858              case TIM_DMA_COM:
   4859              {
   4860                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_COMMUTATION]);
   4861                break;
   4862              }
   4863              case TIM_DMA_TRIGGER:
   4864              {
   4865                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_TRIGGER]);
   4866                break;
   4867              }
   4868              default:
   4869                status = HAL_ERROR;
   4870                break;
   4871            }
   4872          
   4873            if (status == HAL_OK)
   4874            {
   4875              /* Disable the TIM Update DMA request */
   4876              __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
   4877          
   4878              /* Change the DMA burst operation state */
   4879              htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
   4880            }
   4881          
   4882            /* Return function status */
   4883            return status;
   4884          }
   4885          
   4886          /**
   4887            * @brief  Configure the DMA Burst to transfer Data from the TIM peripheral to the memory
   4888            * @param  htim TIM handle
   4889            * @param  BurstBaseAddress TIM Base address from where the DMA  will start the Data read
   4890            *         This parameter can be one of the following values:
   4891            *            @arg TIM_DMABASE_CR1
   4892            *            @arg TIM_DMABASE_CR2
   4893            *            @arg TIM_DMABASE_SMCR
   4894            *            @arg TIM_DMABASE_DIER
   4895            *            @arg TIM_DMABASE_SR
   4896            *            @arg TIM_DMABASE_EGR
   4897            *            @arg TIM_DMABASE_CCMR1
   4898            *            @arg TIM_DMABASE_CCMR2
   4899            *            @arg TIM_DMABASE_CCER
   4900            *            @arg TIM_DMABASE_CNT
   4901            *            @arg TIM_DMABASE_PSC
   4902            *            @arg TIM_DMABASE_ARR
   4903            *            @arg TIM_DMABASE_RCR
   4904            *            @arg TIM_DMABASE_CCR1
   4905            *            @arg TIM_DMABASE_CCR2
   4906            *            @arg TIM_DMABASE_CCR3
   4907            *            @arg TIM_DMABASE_CCR4
   4908            *            @arg TIM_DMABASE_BDTR
   4909            *            @arg TIM_DMABASE_OR1
   4910            *            @arg TIM_DMABASE_CCMR3
   4911            *            @arg TIM_DMABASE_CCR5
   4912            *            @arg TIM_DMABASE_CCR6
   4913            *            @arg TIM_DMABASE_AF1
   4914            *            @arg TIM_DMABASE_AF2
   4915            *            @arg TIM_DMABASE_TISEL
   4916            * @param  BurstRequestSrc TIM DMA Request sources
   4917            *         This parameter can be one of the following values:
   4918            *            @arg TIM_DMA_UPDATE: TIM update Interrupt source
   4919            *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
   4920            *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
   4921            *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
   4922            *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
   4923            *            @arg TIM_DMA_COM: TIM Commutation DMA source
   4924            *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source
   4925            * @param  BurstBuffer The Buffer address.
   4926            * @param  BurstLength DMA Burst length. This parameter can be one value
   4927            *         between: TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.
   4928            * @note   This function should be used only when BurstLength is equal to DMA data transfer length.
   4929            * @retval HAL status
   4930            */
   4931          HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress,
   4932                                                       uint32_t BurstRequestSrc, uint32_t  *BurstBuffer, uint32_t  BurstLength)
   4933          {
   4934            HAL_StatusTypeDef status;
   4935          
   4936            status = HAL_TIM_DMABurst_MultiReadStart(htim, BurstBaseAddress, BurstRequestSrc, BurstBuffer, BurstLength,
   4937                                                     ((BurstLength) >> 8U) + 1U);
   4938          
   4939          
   4940            return status;
   4941          }
   4942          
   4943          /**
   4944            * @brief  Configure the DMA Burst to transfer Data from the TIM peripheral to the memory
   4945            * @param  htim TIM handle
   4946            * @param  BurstBaseAddress TIM Base address from where the DMA  will start the Data read
   4947            *         This parameter can be one of the following values:
   4948            *            @arg TIM_DMABASE_CR1
   4949            *            @arg TIM_DMABASE_CR2
   4950            *            @arg TIM_DMABASE_SMCR
   4951            *            @arg TIM_DMABASE_DIER
   4952            *            @arg TIM_DMABASE_SR
   4953            *            @arg TIM_DMABASE_EGR
   4954            *            @arg TIM_DMABASE_CCMR1
   4955            *            @arg TIM_DMABASE_CCMR2
   4956            *            @arg TIM_DMABASE_CCER
   4957            *            @arg TIM_DMABASE_CNT
   4958            *            @arg TIM_DMABASE_PSC
   4959            *            @arg TIM_DMABASE_ARR
   4960            *            @arg TIM_DMABASE_RCR
   4961            *            @arg TIM_DMABASE_CCR1
   4962            *            @arg TIM_DMABASE_CCR2
   4963            *            @arg TIM_DMABASE_CCR3
   4964            *            @arg TIM_DMABASE_CCR4
   4965            *            @arg TIM_DMABASE_BDTR
   4966            *            @arg TIM_DMABASE_OR1
   4967            *            @arg TIM_DMABASE_CCMR3
   4968            *            @arg TIM_DMABASE_CCR5
   4969            *            @arg TIM_DMABASE_CCR6
   4970            *            @arg TIM_DMABASE_AF1
   4971            *            @arg TIM_DMABASE_AF2
   4972            *            @arg TIM_DMABASE_TISEL
   4973            * @param  BurstRequestSrc TIM DMA Request sources
   4974            *         This parameter can be one of the following values:
   4975            *            @arg TIM_DMA_UPDATE: TIM update Interrupt source
   4976            *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
   4977            *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
   4978            *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
   4979            *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
   4980            *            @arg TIM_DMA_COM: TIM Commutation DMA source
   4981            *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source
   4982            * @param  BurstBuffer The Buffer address.
   4983            * @param  BurstLength DMA Burst length. This parameter can be one value
   4984            *         between: TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.
   4985            * @param  DataLength Data length. This parameter can be one value
   4986            *         between 1 and 0xFFFF.
   4987            * @retval HAL status
   4988            */
   4989          HAL_StatusTypeDef HAL_TIM_DMABurst_MultiReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress,
   4990                                                            uint32_t BurstRequestSrc, uint32_t  *BurstBuffer,
   4991                                                            uint32_t  BurstLength, uint32_t  DataLength)
   4992          {
   4993            HAL_StatusTypeDef status = HAL_OK;
   4994          
   4995            /* Check the parameters */
   4996            assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
   4997            assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
   4998            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   4999            assert_param(IS_TIM_DMA_LENGTH(BurstLength));
   5000            assert_param(IS_TIM_DMA_DATA_LENGTH(DataLength));
   5001          
   5002            if (htim->DMABurstState == HAL_DMA_BURST_STATE_BUSY)
   5003            {
   5004              return HAL_BUSY;
   5005            }
   5006            else if (htim->DMABurstState == HAL_DMA_BURST_STATE_READY)
   5007            {
   5008              if ((BurstBuffer == NULL) && (BurstLength > 0U))
   5009              {
   5010                return HAL_ERROR;
   5011              }
   5012              else
   5013              {
   5014                htim->DMABurstState = HAL_DMA_BURST_STATE_BUSY;
   5015              }
   5016            }
   5017            else
   5018            {
   5019              /* nothing to do */
   5020            }
   5021            switch (BurstRequestSrc)
   5022            {
   5023              case TIM_DMA_UPDATE:
   5024              {
   5025                /* Set the DMA Period elapsed callbacks */
   5026                htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
   5027                htim->hdma[TIM_DMA_ID_UPDATE]->XferHalfCpltCallback = TIM_DMAPeriodElapsedHalfCplt;
   5028          
   5029                /* Set the DMA error callback */
   5030                htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
   5031          
   5032                /* Enable the DMA channel */
   5033                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,
   5034                                     DataLength) != HAL_OK)
   5035                {
   5036                  /* Return error status */
   5037                  return HAL_ERROR;
   5038                }
   5039                break;
   5040              }
   5041              case TIM_DMA_CC1:
   5042              {
   5043                /* Set the DMA capture callbacks */
   5044                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
   5045                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   5046          
   5047                /* Set the DMA error callback */
   5048                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   5049          
   5050                /* Enable the DMA channel */
   5051                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,
   5052                                     DataLength) != HAL_OK)
   5053                {
   5054                  /* Return error status */
   5055                  return HAL_ERROR;
   5056                }
   5057                break;
   5058              }
   5059              case TIM_DMA_CC2:
   5060              {
   5061                /* Set the DMA capture callbacks */
   5062                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
   5063                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   5064          
   5065                /* Set the DMA error callback */
   5066                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   5067          
   5068                /* Enable the DMA channel */
   5069                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,
   5070                                     DataLength) != HAL_OK)
   5071                {
   5072                  /* Return error status */
   5073                  return HAL_ERROR;
   5074                }
   5075                break;
   5076              }
   5077              case TIM_DMA_CC3:
   5078              {
   5079                /* Set the DMA capture callbacks */
   5080                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMACaptureCplt;
   5081                htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   5082          
   5083                /* Set the DMA error callback */
   5084                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   5085          
   5086                /* Enable the DMA channel */
   5087                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,
   5088                                     DataLength) != HAL_OK)
   5089                {
   5090                  /* Return error status */
   5091                  return HAL_ERROR;
   5092                }
   5093                break;
   5094              }
   5095              case TIM_DMA_CC4:
   5096              {
   5097                /* Set the DMA capture callbacks */
   5098                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMACaptureCplt;
   5099                htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   5100          
   5101                /* Set the DMA error callback */
   5102                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   5103          
   5104                /* Enable the DMA channel */
   5105                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,
   5106                                     DataLength) != HAL_OK)
   5107                {
   5108                  /* Return error status */
   5109                  return HAL_ERROR;
   5110                }
   5111                break;
   5112              }
   5113              case TIM_DMA_COM:
   5114              {
   5115                /* Set the DMA commutation callbacks */
   5116                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback =  TIMEx_DMACommutationCplt;
   5117                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferHalfCpltCallback =  TIMEx_DMACommutationHalfCplt;
   5118          
   5119                /* Set the DMA error callback */
   5120                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;
   5121          
   5122                /* Enable the DMA channel */
   5123                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,
   5124                                     DataLength) != HAL_OK)
   5125                {
   5126                  /* Return error status */
   5127                  return HAL_ERROR;
   5128                }
   5129                break;
   5130              }
   5131              case TIM_DMA_TRIGGER:
   5132              {
   5133                /* Set the DMA trigger callbacks */
   5134                htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
   5135                htim->hdma[TIM_DMA_ID_TRIGGER]->XferHalfCpltCallback = TIM_DMATriggerHalfCplt;
   5136          
   5137                /* Set the DMA error callback */
   5138                htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
   5139          
   5140                /* Enable the DMA channel */
   5141                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,
   5142                                     DataLength) != HAL_OK)
   5143                {
   5144                  /* Return error status */
   5145                  return HAL_ERROR;
   5146                }
   5147                break;
   5148              }
   5149              default:
   5150                status = HAL_ERROR;
   5151                break;
   5152            }
   5153          
   5154            if (status == HAL_OK)
   5155            {
   5156              /* Configure the DMA Burst Mode */
   5157              htim->Instance->DCR = (BurstBaseAddress | BurstLength);
   5158          
   5159              /* Enable the TIM DMA Request */
   5160              __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
   5161            }
   5162          
   5163            /* Return function status */
   5164            return status;
   5165          }
   5166          
   5167          /**
   5168            * @brief  Stop the DMA burst reading
   5169            * @param  htim TIM handle
   5170            * @param  BurstRequestSrc TIM DMA Request sources to disable.
   5171            * @retval HAL status
   5172            */
   5173          HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
   5174          {
   5175            HAL_StatusTypeDef status = HAL_OK;
   5176          
   5177            /* Check the parameters */
   5178            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   5179          
   5180            /* Abort the DMA transfer (at least disable the DMA channel) */
   5181            switch (BurstRequestSrc)
   5182            {
   5183              case TIM_DMA_UPDATE:
   5184              {
   5185                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_UPDATE]);
   5186                break;
   5187              }
   5188              case TIM_DMA_CC1:
   5189              {
   5190                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   5191                break;
   5192              }
   5193              case TIM_DMA_CC2:
   5194              {
   5195                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   5196                break;
   5197              }
   5198              case TIM_DMA_CC3:
   5199              {
   5200                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
   5201                break;
   5202              }
   5203              case TIM_DMA_CC4:
   5204              {
   5205                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
   5206                break;
   5207              }
   5208              case TIM_DMA_COM:
   5209              {
   5210                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_COMMUTATION]);
   5211                break;
   5212              }
   5213              case TIM_DMA_TRIGGER:
   5214              {
   5215                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_TRIGGER]);
   5216                break;
   5217              }
   5218              default:
   5219                status = HAL_ERROR;
   5220                break;
   5221            }
   5222          
   5223            if (status == HAL_OK)
   5224            {
   5225              /* Disable the TIM Update DMA request */
   5226              __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
   5227          
   5228              /* Change the DMA burst operation state */
   5229              htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
   5230            }
   5231          
   5232            /* Return function status */
   5233            return status;
   5234          }
   5235          
   5236          /**
   5237            * @brief  Generate a software event
   5238            * @param  htim TIM handle
   5239            * @param  EventSource specifies the event source.
   5240            *          This parameter can be one of the following values:
   5241            *            @arg TIM_EVENTSOURCE_UPDATE: Timer update Event source
   5242            *            @arg TIM_EVENTSOURCE_CC1: Timer Capture Compare 1 Event source
   5243            *            @arg TIM_EVENTSOURCE_CC2: Timer Capture Compare 2 Event source
   5244            *            @arg TIM_EVENTSOURCE_CC3: Timer Capture Compare 3 Event source
   5245            *            @arg TIM_EVENTSOURCE_CC4: Timer Capture Compare 4 Event source
   5246            *            @arg TIM_EVENTSOURCE_COM: Timer COM event source
   5247            *            @arg TIM_EVENTSOURCE_TRIGGER: Timer Trigger Event source
   5248            *            @arg TIM_EVENTSOURCE_BREAK: Timer Break event source
   5249            *            @arg TIM_EVENTSOURCE_BREAK2: Timer Break2 event source
   5250            * @note   Basic timers can only generate an update event.
   5251            * @note   TIM_EVENTSOURCE_COM is relevant only with advanced timer instances.
   5252            * @note   TIM_EVENTSOURCE_BREAK and TIM_EVENTSOURCE_BREAK2 are relevant
   5253            *         only for timer instances supporting break input(s).
   5254            * @retval HAL status
   5255            */
   5256          
   5257          HAL_StatusTypeDef HAL_TIM_GenerateEvent(TIM_HandleTypeDef *htim, uint32_t EventSource)
   5258          {
   5259            /* Check the parameters */
   5260            assert_param(IS_TIM_INSTANCE(htim->Instance));
   5261            assert_param(IS_TIM_EVENT_SOURCE(EventSource));
   5262          
   5263            /* Process Locked */
   5264            __HAL_LOCK(htim);
   5265          
   5266            /* Change the TIM state */
   5267            htim->State = HAL_TIM_STATE_BUSY;
   5268          
   5269            /* Set the event sources */
   5270            htim->Instance->EGR = EventSource;
   5271          
   5272            /* Change the TIM state */
   5273            htim->State = HAL_TIM_STATE_READY;
   5274          
   5275            __HAL_UNLOCK(htim);
   5276          
   5277            /* Return function status */
   5278            return HAL_OK;
   5279          }
   5280          
   5281          /**
   5282            * @brief  Configures the OCRef clear feature
   5283            * @param  htim TIM handle
   5284            * @param  sClearInputConfig pointer to a TIM_ClearInputConfigTypeDef structure that
   5285            *         contains the OCREF clear feature and parameters for the TIM peripheral.
   5286            * @param  Channel specifies the TIM Channel
   5287            *          This parameter can be one of the following values:
   5288            *            @arg TIM_CHANNEL_1: TIM Channel 1
   5289            *            @arg TIM_CHANNEL_2: TIM Channel 2
   5290            *            @arg TIM_CHANNEL_3: TIM Channel 3
   5291            *            @arg TIM_CHANNEL_4: TIM Channel 4
   5292            *            @arg TIM_CHANNEL_5: TIM Channel 5
   5293            *            @arg TIM_CHANNEL_6: TIM Channel 6
   5294            * @retval HAL status
   5295            */
   5296          HAL_StatusTypeDef HAL_TIM_ConfigOCrefClear(TIM_HandleTypeDef *htim,
   5297                                                     const TIM_ClearInputConfigTypeDef *sClearInputConfig,
   5298                                                     uint32_t Channel)
   5299          {
   5300            HAL_StatusTypeDef status = HAL_OK;
   5301          
   5302            /* Check the parameters */
   5303            assert_param(IS_TIM_OCXREF_CLEAR_INSTANCE(htim->Instance));
   5304            assert_param(IS_TIM_CLEARINPUT_SOURCE(sClearInputConfig->ClearInputSource));
   5305          
   5306            /* Process Locked */
   5307            __HAL_LOCK(htim);
   5308          
   5309            htim->State = HAL_TIM_STATE_BUSY;
   5310          
   5311            switch (sClearInputConfig->ClearInputSource)
   5312            {
   5313              case TIM_CLEARINPUTSOURCE_NONE:
   5314              {
   5315                /* Clear the OCREF clear selection bit and the the ETR Bits */
   5316                CLEAR_BIT(htim->Instance->SMCR, (TIM_SMCR_OCCS | TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP));
   5317          
   5318                /* Clear TIMx_OR1_OCREF_CLR (reset value) */
   5319                CLEAR_BIT(htim->Instance->OR1, TIMx_OR1_OCREF_CLR);
   5320                break;
   5321              }
   5322          #if defined(COMP1) || defined(COMP2) || defined(COMP3)
   5323          #if defined(COMP1) && defined(COMP2)
   5324              case TIM_CLEARINPUTSOURCE_COMP1:
   5325              case TIM_CLEARINPUTSOURCE_COMP2:
   5326          #endif /* COMP1 && COMP2 */
   5327          #if defined(COMP3)
   5328              case TIM_CLEARINPUTSOURCE_COMP3:
   5329          #endif /* COMP3 */
   5330              {
   5331                /* Clear the OCREF clear selection bit */
   5332                CLEAR_BIT(htim->Instance->SMCR, TIM_SMCR_OCCS);
   5333          
   5334                /* OCREF_CLR_INT is connected to COMPx output */
   5335                MODIFY_REG(htim->Instance->OR1, TIMx_OR1_OCREF_CLR, sClearInputConfig->ClearInputSource);
   5336                break;
   5337              }
   5338          #endif /* COMP1 || COMP2 || COMP3 */
   5339          
   5340              case TIM_CLEARINPUTSOURCE_ETR:
   5341              {
   5342                /* Check the parameters */
   5343                assert_param(IS_TIM_CLEARINPUT_POLARITY(sClearInputConfig->ClearInputPolarity));
   5344                assert_param(IS_TIM_CLEARINPUT_PRESCALER(sClearInputConfig->ClearInputPrescaler));
   5345                assert_param(IS_TIM_CLEARINPUT_FILTER(sClearInputConfig->ClearInputFilter));
   5346          
   5347                /* When OCRef clear feature is used with ETR source, ETR prescaler must be off */
   5348                if (sClearInputConfig->ClearInputPrescaler != TIM_CLEARINPUTPRESCALER_DIV1)
   5349                {
   5350                  htim->State = HAL_TIM_STATE_READY;
   5351                  __HAL_UNLOCK(htim);
   5352                  return HAL_ERROR;
   5353                }
   5354          
   5355                TIM_ETR_SetConfig(htim->Instance,
   5356                                  sClearInputConfig->ClearInputPrescaler,
   5357                                  sClearInputConfig->ClearInputPolarity,
   5358                                  sClearInputConfig->ClearInputFilter);
   5359          
   5360                /* Set the OCREF clear selection bit */
   5361                SET_BIT(htim->Instance->SMCR, TIM_SMCR_OCCS);
   5362          
   5363                /* Clear TIMx_OR1_OCREF_CLR (reset value) */
   5364                CLEAR_BIT(htim->Instance->OR1, TIMx_OR1_OCREF_CLR);
   5365                break;
   5366              }
   5367          
   5368              default:
   5369                status = HAL_ERROR;
   5370                break;
   5371            }
   5372          
   5373            if (status == HAL_OK)
   5374            {
   5375              switch (Channel)
   5376              {
   5377                case TIM_CHANNEL_1:
   5378                {
   5379                  if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
   5380                  {
   5381                    /* Enable the OCREF clear feature for Channel 1 */
   5382                    SET_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC1CE);
   5383                  }
   5384                  else
   5385                  {
   5386                    /* Disable the OCREF clear feature for Channel 1 */
   5387                    CLEAR_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC1CE);
   5388                  }
   5389                  break;
   5390                }
   5391                case TIM_CHANNEL_2:
   5392                {
   5393                  if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
   5394                  {
   5395                    /* Enable the OCREF clear feature for Channel 2 */
   5396                    SET_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC2CE);
   5397                  }
   5398                  else
   5399                  {
   5400                    /* Disable the OCREF clear feature for Channel 2 */
   5401                    CLEAR_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC2CE);
   5402                  }
   5403                  break;
   5404                }
   5405                case TIM_CHANNEL_3:
   5406                {
   5407                  if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
   5408                  {
   5409                    /* Enable the OCREF clear feature for Channel 3 */
   5410                    SET_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC3CE);
   5411                  }
   5412                  else
   5413                  {
   5414                    /* Disable the OCREF clear feature for Channel 3 */
   5415                    CLEAR_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC3CE);
   5416                  }
   5417                  break;
   5418                }
   5419                case TIM_CHANNEL_4:
   5420                {
   5421                  if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
   5422                  {
   5423                    /* Enable the OCREF clear feature for Channel 4 */
   5424                    SET_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC4CE);
   5425                  }
   5426                  else
   5427                  {
   5428                    /* Disable the OCREF clear feature for Channel 4 */
   5429                    CLEAR_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC4CE);
   5430                  }
   5431                  break;
   5432                }
   5433                case TIM_CHANNEL_5:
   5434                {
   5435                  if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
   5436                  {
   5437                    /* Enable the OCREF clear feature for Channel 5 */
   5438                    SET_BIT(htim->Instance->CCMR3, TIM_CCMR3_OC5CE);
   5439                  }
   5440                  else
   5441                  {
   5442                    /* Disable the OCREF clear feature for Channel 5 */
   5443                    CLEAR_BIT(htim->Instance->CCMR3, TIM_CCMR3_OC5CE);
   5444                  }
   5445                  break;
   5446                }
   5447                case TIM_CHANNEL_6:
   5448                {
   5449                  if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
   5450                  {
   5451                    /* Enable the OCREF clear feature for Channel 6 */
   5452                    SET_BIT(htim->Instance->CCMR3, TIM_CCMR3_OC6CE);
   5453                  }
   5454                  else
   5455                  {
   5456                    /* Disable the OCREF clear feature for Channel 6 */
   5457                    CLEAR_BIT(htim->Instance->CCMR3, TIM_CCMR3_OC6CE);
   5458                  }
   5459                  break;
   5460                }
   5461                default:
   5462                  break;
   5463              }
   5464            }
   5465          
   5466            htim->State = HAL_TIM_STATE_READY;
   5467          
   5468            __HAL_UNLOCK(htim);
   5469          
   5470            return status;
   5471          }
   5472          
   5473          /**
   5474            * @brief   Configures the clock source to be used
   5475            * @param  htim TIM handle
   5476            * @param  sClockSourceConfig pointer to a TIM_ClockConfigTypeDef structure that
   5477            *         contains the clock source information for the TIM peripheral.
   5478            * @retval HAL status
   5479            */
   5480          HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, const TIM_ClockConfigTypeDef *sClockSourceConfig)
   5481          {
   5482            HAL_StatusTypeDef status = HAL_OK;
   5483            uint32_t tmpsmcr;
   5484          
   5485            /* Process Locked */
   5486            __HAL_LOCK(htim);
   5487          
   5488            htim->State = HAL_TIM_STATE_BUSY;
   5489          
   5490            /* Check the parameters */
   5491            assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));
   5492          
   5493            /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
   5494            tmpsmcr = htim->Instance->SMCR;
   5495            tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
   5496            tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
   5497            htim->Instance->SMCR = tmpsmcr;
   5498          
   5499            switch (sClockSourceConfig->ClockSource)
   5500            {
   5501              case TIM_CLOCKSOURCE_INTERNAL:
   5502              {
   5503                assert_param(IS_TIM_INSTANCE(htim->Instance));
   5504                break;
   5505              }
   5506          
   5507              case TIM_CLOCKSOURCE_ETRMODE1:
   5508              {
   5509                /* Check whether or not the timer instance supports external trigger input mode 1 (ETRF)*/
   5510                assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
   5511          
   5512                /* Check ETR input conditioning related parameters */
   5513                assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
   5514                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   5515                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   5516          
   5517                /* Configure the ETR Clock source */
   5518                TIM_ETR_SetConfig(htim->Instance,
   5519                                  sClockSourceConfig->ClockPrescaler,
   5520                                  sClockSourceConfig->ClockPolarity,
   5521                                  sClockSourceConfig->ClockFilter);
   5522          
   5523                /* Select the External clock mode1 and the ETRF trigger */
   5524                tmpsmcr = htim->Instance->SMCR;
   5525                tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
   5526                /* Write to TIMx SMCR */
   5527                htim->Instance->SMCR = tmpsmcr;
   5528                break;
   5529              }
   5530          
   5531              case TIM_CLOCKSOURCE_ETRMODE2:
   5532              {
   5533                /* Check whether or not the timer instance supports external trigger input mode 2 (ETRF)*/
   5534                assert_param(IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(htim->Instance));
   5535          
   5536                /* Check ETR input conditioning related parameters */
   5537                assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
   5538                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   5539                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   5540          
   5541                /* Configure the ETR Clock source */
   5542                TIM_ETR_SetConfig(htim->Instance,
   5543                                  sClockSourceConfig->ClockPrescaler,
   5544                                  sClockSourceConfig->ClockPolarity,
   5545                                  sClockSourceConfig->ClockFilter);
   5546                /* Enable the External clock mode2 */
   5547                htim->Instance->SMCR |= TIM_SMCR_ECE;
   5548                break;
   5549              }
   5550          
   5551              case TIM_CLOCKSOURCE_TI1:
   5552              {
   5553                /* Check whether or not the timer instance supports external clock mode 1 */
   5554                assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   5555          
   5556                /* Check TI1 input conditioning related parameters */
   5557                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   5558                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   5559          
   5560                TIM_TI1_ConfigInputStage(htim->Instance,
   5561                                         sClockSourceConfig->ClockPolarity,
   5562                                         sClockSourceConfig->ClockFilter);
   5563                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
   5564                break;
   5565              }
   5566          
   5567              case TIM_CLOCKSOURCE_TI2:
   5568              {
   5569                /* Check whether or not the timer instance supports external clock mode 1 (ETRF)*/
   5570                assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   5571          
   5572                /* Check TI2 input conditioning related parameters */
   5573                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   5574                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   5575          
   5576                TIM_TI2_ConfigInputStage(htim->Instance,
   5577                                         sClockSourceConfig->ClockPolarity,
   5578                                         sClockSourceConfig->ClockFilter);
   5579                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
   5580                break;
   5581              }
   5582          
   5583              case TIM_CLOCKSOURCE_TI1ED:
   5584              {
   5585                /* Check whether or not the timer instance supports external clock mode 1 */
   5586                assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   5587          
   5588                /* Check TI1 input conditioning related parameters */
   5589                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   5590                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   5591          
   5592                TIM_TI1_ConfigInputStage(htim->Instance,
   5593                                         sClockSourceConfig->ClockPolarity,
   5594                                         sClockSourceConfig->ClockFilter);
   5595                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
   5596                break;
   5597              }
   5598          
   5599              case TIM_CLOCKSOURCE_ITR0:
   5600              case TIM_CLOCKSOURCE_ITR1:
   5601              case TIM_CLOCKSOURCE_ITR2:
   5602              case TIM_CLOCKSOURCE_ITR3:
   5603              {
   5604                /* Check whether or not the timer instance supports internal trigger input */
   5605                assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
   5606          
   5607                TIM_ITRx_SetConfig(htim->Instance, sClockSourceConfig->ClockSource);
   5608                break;
   5609              }
   5610          
   5611              default:
   5612                status = HAL_ERROR;
   5613                break;
   5614            }
   5615            htim->State = HAL_TIM_STATE_READY;
   5616          
   5617            __HAL_UNLOCK(htim);
   5618          
   5619            return status;
   5620          }
   5621          
   5622          /**
   5623            * @brief  Selects the signal connected to the TI1 input: direct from CH1_input
   5624            *         or a XOR combination between CH1_input, CH2_input & CH3_input
   5625            * @param  htim TIM handle.
   5626            * @param  TI1_Selection Indicate whether or not channel 1 is connected to the
   5627            *         output of a XOR gate.
   5628            *          This parameter can be one of the following values:
   5629            *            @arg TIM_TI1SELECTION_CH1: The TIMx_CH1 pin is connected to TI1 input
   5630            *            @arg TIM_TI1SELECTION_XORCOMBINATION: The TIMx_CH1, CH2 and CH3
   5631            *            pins are connected to the TI1 input (XOR combination)
   5632            * @retval HAL status
   5633            */
   5634          HAL_StatusTypeDef HAL_TIM_ConfigTI1Input(TIM_HandleTypeDef *htim, uint32_t TI1_Selection)
   5635          {
   5636            uint32_t tmpcr2;
   5637          
   5638            /* Check the parameters */
   5639            assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
   5640            assert_param(IS_TIM_TI1SELECTION(TI1_Selection));
   5641          
   5642            /* Get the TIMx CR2 register value */
   5643            tmpcr2 = htim->Instance->CR2;
   5644          
   5645            /* Reset the TI1 selection */
   5646            tmpcr2 &= ~TIM_CR2_TI1S;
   5647          
   5648            /* Set the TI1 selection */
   5649            tmpcr2 |= TI1_Selection;
   5650          
   5651            /* Write to TIMxCR2 */
   5652            htim->Instance->CR2 = tmpcr2;
   5653          
   5654            return HAL_OK;
   5655          }
   5656          
   5657          /**
   5658            * @brief  Configures the TIM in Slave mode
   5659            * @param  htim TIM handle.
   5660            * @param  sSlaveConfig pointer to a TIM_SlaveConfigTypeDef structure that
   5661            *         contains the selected trigger (internal trigger input, filtered
   5662            *         timer input or external trigger input) and the Slave mode
   5663            *         (Disable, Reset, Gated, Trigger, External clock mode 1).
   5664            * @retval HAL status
   5665            */
   5666          HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchro(TIM_HandleTypeDef *htim, const TIM_SlaveConfigTypeDef *sSlaveConfig)
   5667          {
   5668            /* Check the parameters */
   5669            assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
   5670            assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
   5671            assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
   5672          
   5673            __HAL_LOCK(htim);
   5674          
   5675            htim->State = HAL_TIM_STATE_BUSY;
   5676          
   5677            if (TIM_SlaveTimer_SetConfig(htim, sSlaveConfig) != HAL_OK)
   5678            {
   5679              htim->State = HAL_TIM_STATE_READY;
   5680              __HAL_UNLOCK(htim);
   5681              return HAL_ERROR;
   5682            }
   5683          
   5684            /* Disable Trigger Interrupt */
   5685            __HAL_TIM_DISABLE_IT(htim, TIM_IT_TRIGGER);
   5686          
   5687            /* Disable Trigger DMA request */
   5688            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
   5689          
   5690            htim->State = HAL_TIM_STATE_READY;
   5691          
   5692            __HAL_UNLOCK(htim);
   5693          
   5694            return HAL_OK;
   5695          }
   5696          
   5697          /**
   5698            * @brief  Configures the TIM in Slave mode in interrupt mode
   5699            * @param  htim TIM handle.
   5700            * @param  sSlaveConfig pointer to a TIM_SlaveConfigTypeDef structure that
   5701            *         contains the selected trigger (internal trigger input, filtered
   5702            *         timer input or external trigger input) and the Slave mode
   5703            *         (Disable, Reset, Gated, Trigger, External clock mode 1).
   5704            * @retval HAL status
   5705            */
   5706          HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchro_IT(TIM_HandleTypeDef *htim,
   5707                                                          const TIM_SlaveConfigTypeDef *sSlaveConfig)
   5708          {
   5709            /* Check the parameters */
   5710            assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
   5711            assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
   5712            assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
   5713          
   5714            __HAL_LOCK(htim);
   5715          
   5716            htim->State = HAL_TIM_STATE_BUSY;
   5717          
   5718            if (TIM_SlaveTimer_SetConfig(htim, sSlaveConfig) != HAL_OK)
   5719            {
   5720              htim->State = HAL_TIM_STATE_READY;
   5721              __HAL_UNLOCK(htim);
   5722              return HAL_ERROR;
   5723            }
   5724          
   5725            /* Enable Trigger Interrupt */
   5726            __HAL_TIM_ENABLE_IT(htim, TIM_IT_TRIGGER);
   5727          
   5728            /* Disable Trigger DMA request */
   5729            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
   5730          
   5731            htim->State = HAL_TIM_STATE_READY;
   5732          
   5733            __HAL_UNLOCK(htim);
   5734          
   5735            return HAL_OK;
   5736          }
   5737          
   5738          /**
   5739            * @brief  Read the captured value from Capture Compare unit
   5740            * @param  htim TIM handle.
   5741            * @param  Channel TIM Channels to be enabled
   5742            *          This parameter can be one of the following values:
   5743            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   5744            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   5745            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   5746            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   5747            * @retval Captured value
   5748            */
   5749          uint32_t HAL_TIM_ReadCapturedValue(const TIM_HandleTypeDef *htim, uint32_t Channel)
   5750          {
   5751            uint32_t tmpreg = 0U;
   5752          
   5753            switch (Channel)
   5754            {
   5755              case TIM_CHANNEL_1:
   5756              {
   5757                /* Check the parameters */
   5758                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   5759          
   5760                /* Return the capture 1 value */
   5761                tmpreg =  htim->Instance->CCR1;
   5762          
   5763                break;
   5764              }
   5765              case TIM_CHANNEL_2:
   5766              {
   5767                /* Check the parameters */
   5768                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   5769          
   5770                /* Return the capture 2 value */
   5771                tmpreg =   htim->Instance->CCR2;
   5772          
   5773                break;
   5774              }
   5775          
   5776              case TIM_CHANNEL_3:
   5777              {
   5778                /* Check the parameters */
   5779                assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   5780          
   5781                /* Return the capture 3 value */
   5782                tmpreg =   htim->Instance->CCR3;
   5783          
   5784                break;
   5785              }
   5786          
   5787              case TIM_CHANNEL_4:
   5788              {
   5789                /* Check the parameters */
   5790                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   5791          
   5792                /* Return the capture 4 value */
   5793                tmpreg =   htim->Instance->CCR4;
   5794          
   5795                break;
   5796              }
   5797          
   5798              default:
   5799                break;
   5800            }
   5801          
   5802            return tmpreg;
   5803          }
   5804          
   5805          /**
   5806            * @}
   5807            */
   5808          
   5809          /** @defgroup TIM_Exported_Functions_Group9 TIM Callbacks functions
   5810            *  @brief    TIM Callbacks functions
   5811            *
   5812          @verbatim
   5813            ==============================================================================
   5814                                  ##### TIM Callbacks functions #####
   5815            ==============================================================================
   5816           [..]
   5817             This section provides TIM callback functions:
   5818             (+) TIM Period elapsed callback
   5819             (+) TIM Output Compare callback
   5820             (+) TIM Input capture callback
   5821             (+) TIM Trigger callback
   5822             (+) TIM Error callback
   5823          
   5824          @endverbatim
   5825            * @{
   5826            */
   5827          
   5828          /**
   5829            * @brief  Period elapsed callback in non-blocking mode
   5830            * @param  htim TIM handle
   5831            * @retval None
   5832            */
   5833          __weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
   5834          {
   5835            /* Prevent unused argument(s) compilation warning */
   5836            UNUSED(htim);
   5837          
   5838            /* NOTE : This function should not be modified, when the callback is needed,
   5839                      the HAL_TIM_PeriodElapsedCallback could be implemented in the user file
   5840             */
   5841          }
   5842          
   5843          /**
   5844            * @brief  Period elapsed half complete callback in non-blocking mode
   5845            * @param  htim TIM handle
   5846            * @retval None
   5847            */
   5848          __weak void HAL_TIM_PeriodElapsedHalfCpltCallback(TIM_HandleTypeDef *htim)
   5849          {
   5850            /* Prevent unused argument(s) compilation warning */
   5851            UNUSED(htim);
   5852          
   5853            /* NOTE : This function should not be modified, when the callback is needed,
   5854                      the HAL_TIM_PeriodElapsedHalfCpltCallback could be implemented in the user file
   5855             */
   5856          }
   5857          
   5858          /**
   5859            * @brief  Output Compare callback in non-blocking mode
   5860            * @param  htim TIM OC handle
   5861            * @retval None
   5862            */
   5863          __weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
   5864          {
   5865            /* Prevent unused argument(s) compilation warning */
   5866            UNUSED(htim);
   5867          
   5868            /* NOTE : This function should not be modified, when the callback is needed,
   5869                      the HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
   5870             */
   5871          }
   5872          
   5873          /**
   5874            * @brief  Input Capture callback in non-blocking mode
   5875            * @param  htim TIM IC handle
   5876            * @retval None
   5877            */
   5878          __weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
   5879          {
   5880            /* Prevent unused argument(s) compilation warning */
   5881            UNUSED(htim);
   5882          
   5883            /* NOTE : This function should not be modified, when the callback is needed,
   5884                      the HAL_TIM_IC_CaptureCallback could be implemented in the user file
   5885             */
   5886          }
   5887          
   5888          /**
   5889            * @brief  Input Capture half complete callback in non-blocking mode
   5890            * @param  htim TIM IC handle
   5891            * @retval None
   5892            */
   5893          __weak void HAL_TIM_IC_CaptureHalfCpltCallback(TIM_HandleTypeDef *htim)
   5894          {
   5895            /* Prevent unused argument(s) compilation warning */
   5896            UNUSED(htim);
   5897          
   5898            /* NOTE : This function should not be modified, when the callback is needed,
   5899                      the HAL_TIM_IC_CaptureHalfCpltCallback could be implemented in the user file
   5900             */
   5901          }
   5902          
   5903          /**
   5904            * @brief  PWM Pulse finished callback in non-blocking mode
   5905            * @param  htim TIM handle
   5906            * @retval None
   5907            */
   5908          __weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
   5909          {
   5910            /* Prevent unused argument(s) compilation warning */
   5911            UNUSED(htim);
   5912          
   5913            /* NOTE : This function should not be modified, when the callback is needed,
   5914                      the HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
   5915             */
   5916          }
   5917          
   5918          /**
   5919            * @brief  PWM Pulse finished half complete callback in non-blocking mode
   5920            * @param  htim TIM handle
   5921            * @retval None
   5922            */
   5923          __weak void HAL_TIM_PWM_PulseFinishedHalfCpltCallback(TIM_HandleTypeDef *htim)
   5924          {
   5925            /* Prevent unused argument(s) compilation warning */
   5926            UNUSED(htim);
   5927          
   5928            /* NOTE : This function should not be modified, when the callback is needed,
   5929                      the HAL_TIM_PWM_PulseFinishedHalfCpltCallback could be implemented in the user file
   5930             */
   5931          }
   5932          
   5933          /**
   5934            * @brief  Hall Trigger detection callback in non-blocking mode
   5935            * @param  htim TIM handle
   5936            * @retval None
   5937            */
   5938          __weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
   5939          {
   5940            /* Prevent unused argument(s) compilation warning */
   5941            UNUSED(htim);
   5942          
   5943            /* NOTE : This function should not be modified, when the callback is needed,
   5944                      the HAL_TIM_TriggerCallback could be implemented in the user file
   5945             */
   5946          }
   5947          
   5948          /**
   5949            * @brief  Hall Trigger detection half complete callback in non-blocking mode
   5950            * @param  htim TIM handle
   5951            * @retval None
   5952            */
   5953          __weak void HAL_TIM_TriggerHalfCpltCallback(TIM_HandleTypeDef *htim)
   5954          {
   5955            /* Prevent unused argument(s) compilation warning */
   5956            UNUSED(htim);
   5957          
   5958            /* NOTE : This function should not be modified, when the callback is needed,
   5959                      the HAL_TIM_TriggerHalfCpltCallback could be implemented in the user file
   5960             */
   5961          }
   5962          
   5963          /**
   5964            * @brief  Timer error callback in non-blocking mode
   5965            * @param  htim TIM handle
   5966            * @retval None
   5967            */
   5968          __weak void HAL_TIM_ErrorCallback(TIM_HandleTypeDef *htim)
   5969          {
   5970            /* Prevent unused argument(s) compilation warning */
   5971            UNUSED(htim);
   5972          
   5973            /* NOTE : This function should not be modified, when the callback is needed,
   5974                      the HAL_TIM_ErrorCallback could be implemented in the user file
   5975             */
   5976          }
   5977          
   5978          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   5979          /**
   5980            * @brief  Register a User TIM callback to be used instead of the weak predefined callback
   5981            * @param htim tim handle
   5982            * @param CallbackID ID of the callback to be registered
   5983            *        This parameter can be one of the following values:
   5984            *          @arg @ref HAL_TIM_BASE_MSPINIT_CB_ID Base MspInit Callback ID
   5985            *          @arg @ref HAL_TIM_BASE_MSPDEINIT_CB_ID Base MspDeInit Callback ID
   5986            *          @arg @ref HAL_TIM_IC_MSPINIT_CB_ID IC MspInit Callback ID
   5987            *          @arg @ref HAL_TIM_IC_MSPDEINIT_CB_ID IC MspDeInit Callback ID
   5988            *          @arg @ref HAL_TIM_OC_MSPINIT_CB_ID OC MspInit Callback ID
   5989            *          @arg @ref HAL_TIM_OC_MSPDEINIT_CB_ID OC MspDeInit Callback ID
   5990            *          @arg @ref HAL_TIM_PWM_MSPINIT_CB_ID PWM MspInit Callback ID
   5991            *          @arg @ref HAL_TIM_PWM_MSPDEINIT_CB_ID PWM MspDeInit Callback ID
   5992            *          @arg @ref HAL_TIM_ONE_PULSE_MSPINIT_CB_ID One Pulse MspInit Callback ID
   5993            *          @arg @ref HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID One Pulse MspDeInit Callback ID
   5994            *          @arg @ref HAL_TIM_ENCODER_MSPINIT_CB_ID Encoder MspInit Callback ID
   5995            *          @arg @ref HAL_TIM_ENCODER_MSPDEINIT_CB_ID Encoder MspDeInit Callback ID
   5996            *          @arg @ref HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID Hall Sensor MspInit Callback ID
   5997            *          @arg @ref HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID Hall Sensor MspDeInit Callback ID
   5998            *          @arg @ref HAL_TIM_PERIOD_ELAPSED_CB_ID Period Elapsed Callback ID
   5999            *          @arg @ref HAL_TIM_PERIOD_ELAPSED_HALF_CB_ID Period Elapsed half complete Callback ID
   6000            *          @arg @ref HAL_TIM_TRIGGER_CB_ID Trigger Callback ID
   6001            *          @arg @ref HAL_TIM_TRIGGER_HALF_CB_ID Trigger half complete Callback ID
   6002            *          @arg @ref HAL_TIM_IC_CAPTURE_CB_ID Input Capture Callback ID
   6003            *          @arg @ref HAL_TIM_IC_CAPTURE_HALF_CB_ID Input Capture half complete Callback ID
   6004            *          @arg @ref HAL_TIM_OC_DELAY_ELAPSED_CB_ID Output Compare Delay Elapsed Callback ID
   6005            *          @arg @ref HAL_TIM_PWM_PULSE_FINISHED_CB_ID PWM Pulse Finished Callback ID
   6006            *          @arg @ref HAL_TIM_PWM_PULSE_FINISHED_HALF_CB_ID PWM Pulse Finished half complete Callback ID
   6007            *          @arg @ref HAL_TIM_ERROR_CB_ID Error Callback ID
   6008            *          @arg @ref HAL_TIM_COMMUTATION_CB_ID Commutation Callback ID
   6009            *          @arg @ref HAL_TIM_COMMUTATION_HALF_CB_ID Commutation half complete Callback ID
   6010            *          @arg @ref HAL_TIM_BREAK_CB_ID Break Callback ID
   6011            *          @arg @ref HAL_TIM_BREAK2_CB_ID Break2 Callback ID
   6012            *          @param pCallback pointer to the callback function
   6013            *          @retval status
   6014            */
   6015          HAL_StatusTypeDef HAL_TIM_RegisterCallback(TIM_HandleTypeDef *htim, HAL_TIM_CallbackIDTypeDef CallbackID,
   6016                                                     pTIM_CallbackTypeDef pCallback)
   6017          {
   6018            HAL_StatusTypeDef status = HAL_OK;
   6019          
   6020            if (pCallback == NULL)
   6021            {
   6022              return HAL_ERROR;
   6023            }
   6024          
   6025            if (htim->State == HAL_TIM_STATE_READY)
   6026            {
   6027              switch (CallbackID)
   6028              {
   6029                case HAL_TIM_BASE_MSPINIT_CB_ID :
   6030                  htim->Base_MspInitCallback                 = pCallback;
   6031                  break;
   6032          
   6033                case HAL_TIM_BASE_MSPDEINIT_CB_ID :
   6034                  htim->Base_MspDeInitCallback               = pCallback;
   6035                  break;
   6036          
   6037                case HAL_TIM_IC_MSPINIT_CB_ID :
   6038                  htim->IC_MspInitCallback                   = pCallback;
   6039                  break;
   6040          
   6041                case HAL_TIM_IC_MSPDEINIT_CB_ID :
   6042                  htim->IC_MspDeInitCallback                 = pCallback;
   6043                  break;
   6044          
   6045                case HAL_TIM_OC_MSPINIT_CB_ID :
   6046                  htim->OC_MspInitCallback                   = pCallback;
   6047                  break;
   6048          
   6049                case HAL_TIM_OC_MSPDEINIT_CB_ID :
   6050                  htim->OC_MspDeInitCallback                 = pCallback;
   6051                  break;
   6052          
   6053                case HAL_TIM_PWM_MSPINIT_CB_ID :
   6054                  htim->PWM_MspInitCallback                  = pCallback;
   6055                  break;
   6056          
   6057                case HAL_TIM_PWM_MSPDEINIT_CB_ID :
   6058                  htim->PWM_MspDeInitCallback                = pCallback;
   6059                  break;
   6060          
   6061                case HAL_TIM_ONE_PULSE_MSPINIT_CB_ID :
   6062                  htim->OnePulse_MspInitCallback             = pCallback;
   6063                  break;
   6064          
   6065                case HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID :
   6066                  htim->OnePulse_MspDeInitCallback           = pCallback;
   6067                  break;
   6068          
   6069                case HAL_TIM_ENCODER_MSPINIT_CB_ID :
   6070                  htim->Encoder_MspInitCallback              = pCallback;
   6071                  break;
   6072          
   6073                case HAL_TIM_ENCODER_MSPDEINIT_CB_ID :
   6074                  htim->Encoder_MspDeInitCallback            = pCallback;
   6075                  break;
   6076          
   6077                case HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID :
   6078                  htim->HallSensor_MspInitCallback           = pCallback;
   6079                  break;
   6080          
   6081                case HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID :
   6082                  htim->HallSensor_MspDeInitCallback         = pCallback;
   6083                  break;
   6084          
   6085                case HAL_TIM_PERIOD_ELAPSED_CB_ID :
   6086                  htim->PeriodElapsedCallback                = pCallback;
   6087                  break;
   6088          
   6089                case HAL_TIM_PERIOD_ELAPSED_HALF_CB_ID :
   6090                  htim->PeriodElapsedHalfCpltCallback        = pCallback;
   6091                  break;
   6092          
   6093                case HAL_TIM_TRIGGER_CB_ID :
   6094                  htim->TriggerCallback                      = pCallback;
   6095                  break;
   6096          
   6097                case HAL_TIM_TRIGGER_HALF_CB_ID :
   6098                  htim->TriggerHalfCpltCallback              = pCallback;
   6099                  break;
   6100          
   6101                case HAL_TIM_IC_CAPTURE_CB_ID :
   6102                  htim->IC_CaptureCallback                   = pCallback;
   6103                  break;
   6104          
   6105                case HAL_TIM_IC_CAPTURE_HALF_CB_ID :
   6106                  htim->IC_CaptureHalfCpltCallback           = pCallback;
   6107                  break;
   6108          
   6109                case HAL_TIM_OC_DELAY_ELAPSED_CB_ID :
   6110                  htim->OC_DelayElapsedCallback              = pCallback;
   6111                  break;
   6112          
   6113                case HAL_TIM_PWM_PULSE_FINISHED_CB_ID :
   6114                  htim->PWM_PulseFinishedCallback            = pCallback;
   6115                  break;
   6116          
   6117                case HAL_TIM_PWM_PULSE_FINISHED_HALF_CB_ID :
   6118                  htim->PWM_PulseFinishedHalfCpltCallback    = pCallback;
   6119                  break;
   6120          
   6121                case HAL_TIM_ERROR_CB_ID :
   6122                  htim->ErrorCallback                        = pCallback;
   6123                  break;
   6124          
   6125                case HAL_TIM_COMMUTATION_CB_ID :
   6126                  htim->CommutationCallback                  = pCallback;
   6127                  break;
   6128          
   6129                case HAL_TIM_COMMUTATION_HALF_CB_ID :
   6130                  htim->CommutationHalfCpltCallback          = pCallback;
   6131                  break;
   6132          
   6133                case HAL_TIM_BREAK_CB_ID :
   6134                  htim->BreakCallback                        = pCallback;
   6135                  break;
   6136          
   6137                case HAL_TIM_BREAK2_CB_ID :
   6138                  htim->Break2Callback                       = pCallback;
   6139                  break;
   6140          
   6141                default :
   6142                  /* Return error status */
   6143                  status = HAL_ERROR;
   6144                  break;
   6145              }
   6146            }
   6147            else if (htim->State == HAL_TIM_STATE_RESET)
   6148            {
   6149              switch (CallbackID)
   6150              {
   6151                case HAL_TIM_BASE_MSPINIT_CB_ID :
   6152                  htim->Base_MspInitCallback         = pCallback;
   6153                  break;
   6154          
   6155                case HAL_TIM_BASE_MSPDEINIT_CB_ID :
   6156                  htim->Base_MspDeInitCallback       = pCallback;
   6157                  break;
   6158          
   6159                case HAL_TIM_IC_MSPINIT_CB_ID :
   6160                  htim->IC_MspInitCallback           = pCallback;
   6161                  break;
   6162          
   6163                case HAL_TIM_IC_MSPDEINIT_CB_ID :
   6164                  htim->IC_MspDeInitCallback         = pCallback;
   6165                  break;
   6166          
   6167                case HAL_TIM_OC_MSPINIT_CB_ID :
   6168                  htim->OC_MspInitCallback           = pCallback;
   6169                  break;
   6170          
   6171                case HAL_TIM_OC_MSPDEINIT_CB_ID :
   6172                  htim->OC_MspDeInitCallback         = pCallback;
   6173                  break;
   6174          
   6175                case HAL_TIM_PWM_MSPINIT_CB_ID :
   6176                  htim->PWM_MspInitCallback          = pCallback;
   6177                  break;
   6178          
   6179                case HAL_TIM_PWM_MSPDEINIT_CB_ID :
   6180                  htim->PWM_MspDeInitCallback        = pCallback;
   6181                  break;
   6182          
   6183                case HAL_TIM_ONE_PULSE_MSPINIT_CB_ID :
   6184                  htim->OnePulse_MspInitCallback     = pCallback;
   6185                  break;
   6186          
   6187                case HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID :
   6188                  htim->OnePulse_MspDeInitCallback   = pCallback;
   6189                  break;
   6190          
   6191                case HAL_TIM_ENCODER_MSPINIT_CB_ID :
   6192                  htim->Encoder_MspInitCallback      = pCallback;
   6193                  break;
   6194          
   6195                case HAL_TIM_ENCODER_MSPDEINIT_CB_ID :
   6196                  htim->Encoder_MspDeInitCallback    = pCallback;
   6197                  break;
   6198          
   6199                case HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID :
   6200                  htim->HallSensor_MspInitCallback   = pCallback;
   6201                  break;
   6202          
   6203                case HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID :
   6204                  htim->HallSensor_MspDeInitCallback = pCallback;
   6205                  break;
   6206          
   6207                default :
   6208                  /* Return error status */
   6209                  status = HAL_ERROR;
   6210                  break;
   6211              }
   6212            }
   6213            else
   6214            {
   6215              /* Return error status */
   6216              status = HAL_ERROR;
   6217            }
   6218          
   6219            return status;
   6220          }
   6221          
   6222          /**
   6223            * @brief  Unregister a TIM callback
   6224            *         TIM callback is redirected to the weak predefined callback
   6225            * @param htim tim handle
   6226            * @param CallbackID ID of the callback to be unregistered
   6227            *        This parameter can be one of the following values:
   6228            *          @arg @ref HAL_TIM_BASE_MSPINIT_CB_ID Base MspInit Callback ID
   6229            *          @arg @ref HAL_TIM_BASE_MSPDEINIT_CB_ID Base MspDeInit Callback ID
   6230            *          @arg @ref HAL_TIM_IC_MSPINIT_CB_ID IC MspInit Callback ID
   6231            *          @arg @ref HAL_TIM_IC_MSPDEINIT_CB_ID IC MspDeInit Callback ID
   6232            *          @arg @ref HAL_TIM_OC_MSPINIT_CB_ID OC MspInit Callback ID
   6233            *          @arg @ref HAL_TIM_OC_MSPDEINIT_CB_ID OC MspDeInit Callback ID
   6234            *          @arg @ref HAL_TIM_PWM_MSPINIT_CB_ID PWM MspInit Callback ID
   6235            *          @arg @ref HAL_TIM_PWM_MSPDEINIT_CB_ID PWM MspDeInit Callback ID
   6236            *          @arg @ref HAL_TIM_ONE_PULSE_MSPINIT_CB_ID One Pulse MspInit Callback ID
   6237            *          @arg @ref HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID One Pulse MspDeInit Callback ID
   6238            *          @arg @ref HAL_TIM_ENCODER_MSPINIT_CB_ID Encoder MspInit Callback ID
   6239            *          @arg @ref HAL_TIM_ENCODER_MSPDEINIT_CB_ID Encoder MspDeInit Callback ID
   6240            *          @arg @ref HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID Hall Sensor MspInit Callback ID
   6241            *          @arg @ref HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID Hall Sensor MspDeInit Callback ID
   6242            *          @arg @ref HAL_TIM_PERIOD_ELAPSED_CB_ID Period Elapsed Callback ID
   6243            *          @arg @ref HAL_TIM_PERIOD_ELAPSED_HALF_CB_ID Period Elapsed half complete Callback ID
   6244            *          @arg @ref HAL_TIM_TRIGGER_CB_ID Trigger Callback ID
   6245            *          @arg @ref HAL_TIM_TRIGGER_HALF_CB_ID Trigger half complete Callback ID
   6246            *          @arg @ref HAL_TIM_IC_CAPTURE_CB_ID Input Capture Callback ID
   6247            *          @arg @ref HAL_TIM_IC_CAPTURE_HALF_CB_ID Input Capture half complete Callback ID
   6248            *          @arg @ref HAL_TIM_OC_DELAY_ELAPSED_CB_ID Output Compare Delay Elapsed Callback ID
   6249            *          @arg @ref HAL_TIM_PWM_PULSE_FINISHED_CB_ID PWM Pulse Finished Callback ID
   6250            *          @arg @ref HAL_TIM_PWM_PULSE_FINISHED_HALF_CB_ID PWM Pulse Finished half complete Callback ID
   6251            *          @arg @ref HAL_TIM_ERROR_CB_ID Error Callback ID
   6252            *          @arg @ref HAL_TIM_COMMUTATION_CB_ID Commutation Callback ID
   6253            *          @arg @ref HAL_TIM_COMMUTATION_HALF_CB_ID Commutation half complete Callback ID
   6254            *          @arg @ref HAL_TIM_BREAK_CB_ID Break Callback ID
   6255            *          @arg @ref HAL_TIM_BREAK2_CB_ID Break2 Callback ID
   6256            *          @retval status
   6257            */
   6258          HAL_StatusTypeDef HAL_TIM_UnRegisterCallback(TIM_HandleTypeDef *htim, HAL_TIM_CallbackIDTypeDef CallbackID)
   6259          {
   6260            HAL_StatusTypeDef status = HAL_OK;
   6261          
   6262            if (htim->State == HAL_TIM_STATE_READY)
   6263            {
   6264              switch (CallbackID)
   6265              {
   6266                case HAL_TIM_BASE_MSPINIT_CB_ID :
   6267                  /* Legacy weak Base MspInit Callback */
   6268                  htim->Base_MspInitCallback              = HAL_TIM_Base_MspInit;
   6269                  break;
   6270          
   6271                case HAL_TIM_BASE_MSPDEINIT_CB_ID :
   6272                  /* Legacy weak Base Msp DeInit Callback */
   6273                  htim->Base_MspDeInitCallback            = HAL_TIM_Base_MspDeInit;
   6274                  break;
   6275          
   6276                case HAL_TIM_IC_MSPINIT_CB_ID :
   6277                  /* Legacy weak IC Msp Init Callback */
   6278                  htim->IC_MspInitCallback                = HAL_TIM_IC_MspInit;
   6279                  break;
   6280          
   6281                case HAL_TIM_IC_MSPDEINIT_CB_ID :
   6282                  /* Legacy weak IC Msp DeInit Callback */
   6283                  htim->IC_MspDeInitCallback              = HAL_TIM_IC_MspDeInit;
   6284                  break;
   6285          
   6286                case HAL_TIM_OC_MSPINIT_CB_ID :
   6287                  /* Legacy weak OC Msp Init Callback */
   6288                  htim->OC_MspInitCallback                = HAL_TIM_OC_MspInit;
   6289                  break;
   6290          
   6291                case HAL_TIM_OC_MSPDEINIT_CB_ID :
   6292                  /* Legacy weak OC Msp DeInit Callback */
   6293                  htim->OC_MspDeInitCallback              = HAL_TIM_OC_MspDeInit;
   6294                  break;
   6295          
   6296                case HAL_TIM_PWM_MSPINIT_CB_ID :
   6297                  /* Legacy weak PWM Msp Init Callback */
   6298                  htim->PWM_MspInitCallback               = HAL_TIM_PWM_MspInit;
   6299                  break;
   6300          
   6301                case HAL_TIM_PWM_MSPDEINIT_CB_ID :
   6302                  /* Legacy weak PWM Msp DeInit Callback */
   6303                  htim->PWM_MspDeInitCallback             = HAL_TIM_PWM_MspDeInit;
   6304                  break;
   6305          
   6306                case HAL_TIM_ONE_PULSE_MSPINIT_CB_ID :
   6307                  /* Legacy weak One Pulse Msp Init Callback */
   6308                  htim->OnePulse_MspInitCallback          = HAL_TIM_OnePulse_MspInit;
   6309                  break;
   6310          
   6311                case HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID :
   6312                  /* Legacy weak One Pulse Msp DeInit Callback */
   6313                  htim->OnePulse_MspDeInitCallback        = HAL_TIM_OnePulse_MspDeInit;
   6314                  break;
   6315          
   6316                case HAL_TIM_ENCODER_MSPINIT_CB_ID :
   6317                  /* Legacy weak Encoder Msp Init Callback */
   6318                  htim->Encoder_MspInitCallback           = HAL_TIM_Encoder_MspInit;
   6319                  break;
   6320          
   6321                case HAL_TIM_ENCODER_MSPDEINIT_CB_ID :
   6322                  /* Legacy weak Encoder Msp DeInit Callback */
   6323                  htim->Encoder_MspDeInitCallback         = HAL_TIM_Encoder_MspDeInit;
   6324                  break;
   6325          
   6326                case HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID :
   6327                  /* Legacy weak Hall Sensor Msp Init Callback */
   6328                  htim->HallSensor_MspInitCallback        = HAL_TIMEx_HallSensor_MspInit;
   6329                  break;
   6330          
   6331                case HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID :
   6332                  /* Legacy weak Hall Sensor Msp DeInit Callback */
   6333                  htim->HallSensor_MspDeInitCallback      = HAL_TIMEx_HallSensor_MspDeInit;
   6334                  break;
   6335          
   6336                case HAL_TIM_PERIOD_ELAPSED_CB_ID :
   6337                  /* Legacy weak Period Elapsed Callback */
   6338                  htim->PeriodElapsedCallback             = HAL_TIM_PeriodElapsedCallback;
   6339                  break;
   6340          
   6341                case HAL_TIM_PERIOD_ELAPSED_HALF_CB_ID :
   6342                  /* Legacy weak Period Elapsed half complete Callback */
   6343                  htim->PeriodElapsedHalfCpltCallback     = HAL_TIM_PeriodElapsedHalfCpltCallback;
   6344                  break;
   6345          
   6346                case HAL_TIM_TRIGGER_CB_ID :
   6347                  /* Legacy weak Trigger Callback */
   6348                  htim->TriggerCallback                   = HAL_TIM_TriggerCallback;
   6349                  break;
   6350          
   6351                case HAL_TIM_TRIGGER_HALF_CB_ID :
   6352                  /* Legacy weak Trigger half complete Callback */
   6353                  htim->TriggerHalfCpltCallback           = HAL_TIM_TriggerHalfCpltCallback;
   6354                  break;
   6355          
   6356                case HAL_TIM_IC_CAPTURE_CB_ID :
   6357                  /* Legacy weak IC Capture Callback */
   6358                  htim->IC_CaptureCallback                = HAL_TIM_IC_CaptureCallback;
   6359                  break;
   6360          
   6361                case HAL_TIM_IC_CAPTURE_HALF_CB_ID :
   6362                  /* Legacy weak IC Capture half complete Callback */
   6363                  htim->IC_CaptureHalfCpltCallback        = HAL_TIM_IC_CaptureHalfCpltCallback;
   6364                  break;
   6365          
   6366                case HAL_TIM_OC_DELAY_ELAPSED_CB_ID :
   6367                  /* Legacy weak OC Delay Elapsed Callback */
   6368                  htim->OC_DelayElapsedCallback           = HAL_TIM_OC_DelayElapsedCallback;
   6369                  break;
   6370          
   6371                case HAL_TIM_PWM_PULSE_FINISHED_CB_ID :
   6372                  /* Legacy weak PWM Pulse Finished Callback */
   6373                  htim->PWM_PulseFinishedCallback         = HAL_TIM_PWM_PulseFinishedCallback;
   6374                  break;
   6375          
   6376                case HAL_TIM_PWM_PULSE_FINISHED_HALF_CB_ID :
   6377                  /* Legacy weak PWM Pulse Finished half complete Callback */
   6378                  htim->PWM_PulseFinishedHalfCpltCallback = HAL_TIM_PWM_PulseFinishedHalfCpltCallback;
   6379                  break;
   6380          
   6381                case HAL_TIM_ERROR_CB_ID :
   6382                  /* Legacy weak Error Callback */
   6383                  htim->ErrorCallback                     = HAL_TIM_ErrorCallback;
   6384                  break;
   6385          
   6386                case HAL_TIM_COMMUTATION_CB_ID :
   6387                  /* Legacy weak Commutation Callback */
   6388                  htim->CommutationCallback               = HAL_TIMEx_CommutCallback;
   6389                  break;
   6390          
   6391                case HAL_TIM_COMMUTATION_HALF_CB_ID :
   6392                  /* Legacy weak Commutation half complete Callback */
   6393                  htim->CommutationHalfCpltCallback       = HAL_TIMEx_CommutHalfCpltCallback;
   6394                  break;
   6395          
   6396                case HAL_TIM_BREAK_CB_ID :
   6397                  /* Legacy weak Break Callback */
   6398                  htim->BreakCallback                     = HAL_TIMEx_BreakCallback;
   6399                  break;
   6400          
   6401                case HAL_TIM_BREAK2_CB_ID :
   6402                  /* Legacy weak Break2 Callback */
   6403                  htim->Break2Callback                    = HAL_TIMEx_Break2Callback;
   6404                  break;
   6405          
   6406                default :
   6407                  /* Return error status */
   6408                  status = HAL_ERROR;
   6409                  break;
   6410              }
   6411            }
   6412            else if (htim->State == HAL_TIM_STATE_RESET)
   6413            {
   6414              switch (CallbackID)
   6415              {
   6416                case HAL_TIM_BASE_MSPINIT_CB_ID :
   6417                  /* Legacy weak Base MspInit Callback */
   6418                  htim->Base_MspInitCallback         = HAL_TIM_Base_MspInit;
   6419                  break;
   6420          
   6421                case HAL_TIM_BASE_MSPDEINIT_CB_ID :
   6422                  /* Legacy weak Base Msp DeInit Callback */
   6423                  htim->Base_MspDeInitCallback       = HAL_TIM_Base_MspDeInit;
   6424                  break;
   6425          
   6426                case HAL_TIM_IC_MSPINIT_CB_ID :
   6427                  /* Legacy weak IC Msp Init Callback */
   6428                  htim->IC_MspInitCallback           = HAL_TIM_IC_MspInit;
   6429                  break;
   6430          
   6431                case HAL_TIM_IC_MSPDEINIT_CB_ID :
   6432                  /* Legacy weak IC Msp DeInit Callback */
   6433                  htim->IC_MspDeInitCallback         = HAL_TIM_IC_MspDeInit;
   6434                  break;
   6435          
   6436                case HAL_TIM_OC_MSPINIT_CB_ID :
   6437                  /* Legacy weak OC Msp Init Callback */
   6438                  htim->OC_MspInitCallback           = HAL_TIM_OC_MspInit;
   6439                  break;
   6440          
   6441                case HAL_TIM_OC_MSPDEINIT_CB_ID :
   6442                  /* Legacy weak OC Msp DeInit Callback */
   6443                  htim->OC_MspDeInitCallback         = HAL_TIM_OC_MspDeInit;
   6444                  break;
   6445          
   6446                case HAL_TIM_PWM_MSPINIT_CB_ID :
   6447                  /* Legacy weak PWM Msp Init Callback */
   6448                  htim->PWM_MspInitCallback          = HAL_TIM_PWM_MspInit;
   6449                  break;
   6450          
   6451                case HAL_TIM_PWM_MSPDEINIT_CB_ID :
   6452                  /* Legacy weak PWM Msp DeInit Callback */
   6453                  htim->PWM_MspDeInitCallback        = HAL_TIM_PWM_MspDeInit;
   6454                  break;
   6455          
   6456                case HAL_TIM_ONE_PULSE_MSPINIT_CB_ID :
   6457                  /* Legacy weak One Pulse Msp Init Callback */
   6458                  htim->OnePulse_MspInitCallback     = HAL_TIM_OnePulse_MspInit;
   6459                  break;
   6460          
   6461                case HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID :
   6462                  /* Legacy weak One Pulse Msp DeInit Callback */
   6463                  htim->OnePulse_MspDeInitCallback   = HAL_TIM_OnePulse_MspDeInit;
   6464                  break;
   6465          
   6466                case HAL_TIM_ENCODER_MSPINIT_CB_ID :
   6467                  /* Legacy weak Encoder Msp Init Callback */
   6468                  htim->Encoder_MspInitCallback      = HAL_TIM_Encoder_MspInit;
   6469                  break;
   6470          
   6471                case HAL_TIM_ENCODER_MSPDEINIT_CB_ID :
   6472                  /* Legacy weak Encoder Msp DeInit Callback */
   6473                  htim->Encoder_MspDeInitCallback    = HAL_TIM_Encoder_MspDeInit;
   6474                  break;
   6475          
   6476                case HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID :
   6477                  /* Legacy weak Hall Sensor Msp Init Callback */
   6478                  htim->HallSensor_MspInitCallback   = HAL_TIMEx_HallSensor_MspInit;
   6479                  break;
   6480          
   6481                case HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID :
   6482                  /* Legacy weak Hall Sensor Msp DeInit Callback */
   6483                  htim->HallSensor_MspDeInitCallback = HAL_TIMEx_HallSensor_MspDeInit;
   6484                  break;
   6485          
   6486                default :
   6487                  /* Return error status */
   6488                  status = HAL_ERROR;
   6489                  break;
   6490              }
   6491            }
   6492            else
   6493            {
   6494              /* Return error status */
   6495              status = HAL_ERROR;
   6496            }
   6497          
   6498            return status;
   6499          }
   6500          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   6501          
   6502          /**
   6503            * @}
   6504            */
   6505          
   6506          /** @defgroup TIM_Exported_Functions_Group10 TIM Peripheral State functions
   6507            *  @brief   TIM Peripheral State functions
   6508            *
   6509          @verbatim
   6510            ==============================================================================
   6511                                  ##### Peripheral State functions #####
   6512            ==============================================================================
   6513              [..]
   6514              This subsection permits to get in run-time the status of the peripheral
   6515              and the data flow.
   6516          
   6517          @endverbatim
   6518            * @{
   6519            */
   6520          
   6521          /**
   6522            * @brief  Return the TIM Base handle state.
   6523            * @param  htim TIM Base handle
   6524            * @retval HAL state
   6525            */
   6526          HAL_TIM_StateTypeDef HAL_TIM_Base_GetState(const TIM_HandleTypeDef *htim)
   6527          {
   6528            return htim->State;
   6529          }
   6530          
   6531          /**
   6532            * @brief  Return the TIM OC handle state.
   6533            * @param  htim TIM Output Compare handle
   6534            * @retval HAL state
   6535            */
   6536          HAL_TIM_StateTypeDef HAL_TIM_OC_GetState(const TIM_HandleTypeDef *htim)
   6537          {
   6538            return htim->State;
   6539          }
   6540          
   6541          /**
   6542            * @brief  Return the TIM PWM handle state.
   6543            * @param  htim TIM handle
   6544            * @retval HAL state
   6545            */
   6546          HAL_TIM_StateTypeDef HAL_TIM_PWM_GetState(const TIM_HandleTypeDef *htim)
   6547          {
   6548            return htim->State;
   6549          }
   6550          
   6551          /**
   6552            * @brief  Return the TIM Input Capture handle state.
   6553            * @param  htim TIM IC handle
   6554            * @retval HAL state
   6555            */
   6556          HAL_TIM_StateTypeDef HAL_TIM_IC_GetState(const TIM_HandleTypeDef *htim)
   6557          {
   6558            return htim->State;
   6559          }
   6560          
   6561          /**
   6562            * @brief  Return the TIM One Pulse Mode handle state.
   6563            * @param  htim TIM OPM handle
   6564            * @retval HAL state
   6565            */
   6566          HAL_TIM_StateTypeDef HAL_TIM_OnePulse_GetState(const TIM_HandleTypeDef *htim)
   6567          {
   6568            return htim->State;
   6569          }
   6570          
   6571          /**
   6572            * @brief  Return the TIM Encoder Mode handle state.
   6573            * @param  htim TIM Encoder Interface handle
   6574            * @retval HAL state
   6575            */
   6576          HAL_TIM_StateTypeDef HAL_TIM_Encoder_GetState(const TIM_HandleTypeDef *htim)
   6577          {
   6578            return htim->State;
   6579          }
   6580          
   6581          /**
   6582            * @brief  Return the TIM Encoder Mode handle state.
   6583            * @param  htim TIM handle
   6584            * @retval Active channel
   6585            */
   6586          HAL_TIM_ActiveChannel HAL_TIM_GetActiveChannel(const TIM_HandleTypeDef *htim)
   6587          {
   6588            return htim->Channel;
   6589          }
   6590          
   6591          /**
   6592            * @brief  Return actual state of the TIM channel.
   6593            * @param  htim TIM handle
   6594            * @param  Channel TIM Channel
   6595            *          This parameter can be one of the following values:
   6596            *            @arg TIM_CHANNEL_1: TIM Channel 1
   6597            *            @arg TIM_CHANNEL_2: TIM Channel 2
   6598            *            @arg TIM_CHANNEL_3: TIM Channel 3
   6599            *            @arg TIM_CHANNEL_4: TIM Channel 4
   6600            *            @arg TIM_CHANNEL_5: TIM Channel 5
   6601            *            @arg TIM_CHANNEL_6: TIM Channel 6
   6602            * @retval TIM Channel state
   6603            */
   6604          HAL_TIM_ChannelStateTypeDef HAL_TIM_GetChannelState(const TIM_HandleTypeDef *htim,  uint32_t Channel)
   6605          {
   6606            HAL_TIM_ChannelStateTypeDef channel_state;
   6607          
   6608            /* Check the parameters */
   6609            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   6610          
   6611            channel_state = TIM_CHANNEL_STATE_GET(htim, Channel);
   6612          
   6613            return channel_state;
   6614          }
   6615          
   6616          /**
   6617            * @brief  Return actual state of a DMA burst operation.
   6618            * @param  htim TIM handle
   6619            * @retval DMA burst state
   6620            */
   6621          HAL_TIM_DMABurstStateTypeDef HAL_TIM_DMABurstState(const TIM_HandleTypeDef *htim)
   6622          {
   6623            /* Check the parameters */
   6624            assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
   6625          
   6626            return htim->DMABurstState;
   6627          }
   6628          
   6629          /**
   6630            * @}
   6631            */
   6632          
   6633          /**
   6634            * @}
   6635            */
   6636          
   6637          /** @defgroup TIM_Private_Functions TIM Private Functions
   6638            * @{
   6639            */
   6640          
   6641          /**
   6642            * @brief  TIM DMA error callback
   6643            * @param  hdma pointer to DMA handle.
   6644            * @retval None
   6645            */
   6646          void TIM_DMAError(DMA_HandleTypeDef *hdma)
   6647          {
   6648            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   6649          
   6650            if (hdma == htim->hdma[TIM_DMA_ID_CC1])
   6651            {
   6652              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   6653              TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
   6654            }
   6655            else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
   6656            {
   6657              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   6658              TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
   6659            }
   6660            else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
   6661            {
   6662              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   6663              TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_3, HAL_TIM_CHANNEL_STATE_READY);
   6664            }
   6665            else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
   6666            {
   6667              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   6668              TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_4, HAL_TIM_CHANNEL_STATE_READY);
   6669            }
   6670            else
   6671            {
   6672              htim->State = HAL_TIM_STATE_READY;
   6673            }
   6674          
   6675          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   6676            htim->ErrorCallback(htim);
   6677          #else
   6678            HAL_TIM_ErrorCallback(htim);
   6679          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   6680          
   6681            htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   6682          }
   6683          
   6684          /**
   6685            * @brief  TIM DMA Delay Pulse complete callback.
   6686            * @param  hdma pointer to DMA handle.
   6687            * @retval None
   6688            */
   6689          static void TIM_DMADelayPulseCplt(DMA_HandleTypeDef *hdma)
   6690          {
   6691            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   6692          
   6693            if (hdma == htim->hdma[TIM_DMA_ID_CC1])
   6694            {
   6695              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   6696          
   6697              if (hdma->Init.Mode == DMA_NORMAL)
   6698              {
   6699                TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
   6700              }
   6701            }
   6702            else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
   6703            {
   6704              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   6705          
   6706              if (hdma->Init.Mode == DMA_NORMAL)
   6707              {
   6708                TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
   6709              }
   6710            }
   6711            else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
   6712            {
   6713              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   6714          
   6715              if (hdma->Init.Mode == DMA_NORMAL)
   6716              {
   6717                TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_3, HAL_TIM_CHANNEL_STATE_READY);
   6718              }
   6719            }
   6720            else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
   6721            {
   6722              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   6723          
   6724              if (hdma->Init.Mode == DMA_NORMAL)
   6725              {
   6726                TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_4, HAL_TIM_CHANNEL_STATE_READY);
   6727              }
   6728            }
   6729            else
   6730            {
   6731              /* nothing to do */
   6732            }
   6733          
   6734          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   6735            htim->PWM_PulseFinishedCallback(htim);
   6736          #else
   6737            HAL_TIM_PWM_PulseFinishedCallback(htim);
   6738          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   6739          
   6740            htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   6741          }
   6742          
   6743          /**
   6744            * @brief  TIM DMA Delay Pulse half complete callback.
   6745            * @param  hdma pointer to DMA handle.
   6746            * @retval None
   6747            */
   6748          void TIM_DMADelayPulseHalfCplt(DMA_HandleTypeDef *hdma)
   6749          {
   6750            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   6751          
   6752            if (hdma == htim->hdma[TIM_DMA_ID_CC1])
   6753            {
   6754              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   6755            }
   6756            else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
   6757            {
   6758              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   6759            }
   6760            else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
   6761            {
   6762              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   6763            }
   6764            else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
   6765            {
   6766              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   6767            }
   6768            else
   6769            {
   6770              /* nothing to do */
   6771            }
   6772          
   6773          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   6774            htim->PWM_PulseFinishedHalfCpltCallback(htim);
   6775          #else
   6776            HAL_TIM_PWM_PulseFinishedHalfCpltCallback(htim);
   6777          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   6778          
   6779            htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   6780          }
   6781          
   6782          /**
   6783            * @brief  TIM DMA Capture complete callback.
   6784            * @param  hdma pointer to DMA handle.
   6785            * @retval None
   6786            */
   6787          void TIM_DMACaptureCplt(DMA_HandleTypeDef *hdma)
   6788          {
   6789            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   6790          
   6791            if (hdma == htim->hdma[TIM_DMA_ID_CC1])
   6792            {
   6793              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   6794          
   6795              if (hdma->Init.Mode == DMA_NORMAL)
   6796              {
   6797                TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
   6798                TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
   6799              }
   6800            }
   6801            else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
   6802            {
   6803              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   6804          
   6805              if (hdma->Init.Mode == DMA_NORMAL)
   6806              {
   6807                TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
   6808                TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
   6809              }
   6810            }
   6811            else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
   6812            {
   6813              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   6814          
   6815              if (hdma->Init.Mode == DMA_NORMAL)
   6816              {
   6817                TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_3, HAL_TIM_CHANNEL_STATE_READY);
   6818                TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_3, HAL_TIM_CHANNEL_STATE_READY);
   6819              }
   6820            }
   6821            else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
   6822            {
   6823              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   6824          
   6825              if (hdma->Init.Mode == DMA_NORMAL)
   6826              {
   6827                TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_4, HAL_TIM_CHANNEL_STATE_READY);
   6828                TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_4, HAL_TIM_CHANNEL_STATE_READY);
   6829              }
   6830            }
   6831            else
   6832            {
   6833              /* nothing to do */
   6834            }
   6835          
   6836          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   6837            htim->IC_CaptureCallback(htim);
   6838          #else
   6839            HAL_TIM_IC_CaptureCallback(htim);
   6840          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   6841          
   6842            htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   6843          }
   6844          
   6845          /**
   6846            * @brief  TIM DMA Capture half complete callback.
   6847            * @param  hdma pointer to DMA handle.
   6848            * @retval None
   6849            */
   6850          void TIM_DMACaptureHalfCplt(DMA_HandleTypeDef *hdma)
   6851          {
   6852            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   6853          
   6854            if (hdma == htim->hdma[TIM_DMA_ID_CC1])
   6855            {
   6856              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   6857            }
   6858            else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
   6859            {
   6860              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   6861            }
   6862            else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
   6863            {
   6864              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   6865            }
   6866            else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
   6867            {
   6868              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   6869            }
   6870            else
   6871            {
   6872              /* nothing to do */
   6873            }
   6874          
   6875          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   6876            htim->IC_CaptureHalfCpltCallback(htim);
   6877          #else
   6878            HAL_TIM_IC_CaptureHalfCpltCallback(htim);
   6879          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   6880          
   6881            htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   6882          }
   6883          
   6884          /**
   6885            * @brief  TIM DMA Period Elapse complete callback.
   6886            * @param  hdma pointer to DMA handle.
   6887            * @retval None
   6888            */
   6889          static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma)
   6890          {
   6891            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   6892          
   6893            if (htim->hdma[TIM_DMA_ID_UPDATE]->Init.Mode == DMA_NORMAL)
   6894            {
   6895              htim->State = HAL_TIM_STATE_READY;
   6896            }
   6897          
   6898          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   6899            htim->PeriodElapsedCallback(htim);
   6900          #else
   6901            HAL_TIM_PeriodElapsedCallback(htim);
   6902          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   6903          }
   6904          
   6905          /**
   6906            * @brief  TIM DMA Period Elapse half complete callback.
   6907            * @param  hdma pointer to DMA handle.
   6908            * @retval None
   6909            */
   6910          static void TIM_DMAPeriodElapsedHalfCplt(DMA_HandleTypeDef *hdma)
   6911          {
   6912            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   6913          
   6914          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   6915            htim->PeriodElapsedHalfCpltCallback(htim);
   6916          #else
   6917            HAL_TIM_PeriodElapsedHalfCpltCallback(htim);
   6918          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   6919          }
   6920          
   6921          /**
   6922            * @brief  TIM DMA Trigger callback.
   6923            * @param  hdma pointer to DMA handle.
   6924            * @retval None
   6925            */
   6926          static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma)
   6927          {
   6928            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   6929          
   6930            if (htim->hdma[TIM_DMA_ID_TRIGGER]->Init.Mode == DMA_NORMAL)
   6931            {
   6932              htim->State = HAL_TIM_STATE_READY;
   6933            }
   6934          
   6935          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   6936            htim->TriggerCallback(htim);
   6937          #else
   6938            HAL_TIM_TriggerCallback(htim);
   6939          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   6940          }
   6941          
   6942          /**
   6943            * @brief  TIM DMA Trigger half complete callback.
   6944            * @param  hdma pointer to DMA handle.
   6945            * @retval None
   6946            */
   6947          static void TIM_DMATriggerHalfCplt(DMA_HandleTypeDef *hdma)
   6948          {
   6949            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   6950          
   6951          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   6952            htim->TriggerHalfCpltCallback(htim);
   6953          #else
   6954            HAL_TIM_TriggerHalfCpltCallback(htim);
   6955          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   6956          }
   6957          
   6958          /**
   6959            * @brief  Time Base configuration
   6960            * @param  TIMx TIM peripheral
   6961            * @param  Structure TIM Base configuration structure
   6962            * @retval None
   6963            */
   6964          void TIM_Base_SetConfig(TIM_TypeDef *TIMx, const TIM_Base_InitTypeDef *Structure)
   6965          {
   6966            uint32_t tmpcr1;
   6967            tmpcr1 = TIMx->CR1;
   6968          
   6969            /* Set TIM Time Base Unit parameters ---------------------------------------*/
   6970            if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
   6971            {
   6972              /* Select the Counter Mode */
   6973              tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
   6974              tmpcr1 |= Structure->CounterMode;
   6975            }
   6976          
   6977            if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
   6978            {
   6979              /* Set the clock division */
   6980              tmpcr1 &= ~TIM_CR1_CKD;
   6981              tmpcr1 |= (uint32_t)Structure->ClockDivision;
   6982            }
   6983          
   6984            /* Set the auto-reload preload */
   6985            MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
   6986          
   6987            TIMx->CR1 = tmpcr1;
   6988          
   6989            /* Set the Autoreload value */
   6990            TIMx->ARR = (uint32_t)Structure->Period ;
   6991          
   6992            /* Set the Prescaler value */
   6993            TIMx->PSC = Structure->Prescaler;
   6994          
   6995            if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
   6996            {
   6997              /* Set the Repetition Counter value */
   6998              TIMx->RCR = Structure->RepetitionCounter;
   6999            }
   7000          
   7001            /* Generate an update event to reload the Prescaler
   7002               and the repetition counter (only for advanced timer) value immediately */
   7003            TIMx->EGR = TIM_EGR_UG;
   7004          
   7005            /* Check if the update flag is set after the Update Generation, if so clear the UIF flag */
   7006            if (HAL_IS_BIT_SET(TIMx->SR, TIM_FLAG_UPDATE))
   7007            {
   7008              /* Clear the update flag */
   7009              CLEAR_BIT(TIMx->SR, TIM_FLAG_UPDATE);
   7010            }
   7011          }
   7012          
   7013          /**
   7014            * @brief  Timer Output Compare 1 configuration
   7015            * @param  TIMx to select the TIM peripheral
   7016            * @param  OC_Config The output configuration structure
   7017            * @retval None
   7018            */
   7019          static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, const TIM_OC_InitTypeDef *OC_Config)
   7020          {
   7021            uint32_t tmpccmrx;
   7022            uint32_t tmpccer;
   7023            uint32_t tmpcr2;
   7024          
   7025            /* Get the TIMx CCER register value */
   7026            tmpccer = TIMx->CCER;
   7027          
   7028            /* Disable the Channel 1: Reset the CC1E Bit */
   7029            TIMx->CCER &= ~TIM_CCER_CC1E;
   7030          
   7031            /* Get the TIMx CR2 register value */
   7032            tmpcr2 =  TIMx->CR2;
   7033          
   7034            /* Get the TIMx CCMR1 register value */
   7035            tmpccmrx = TIMx->CCMR1;
   7036          
   7037            /* Reset the Output Compare Mode Bits */
   7038            tmpccmrx &= ~TIM_CCMR1_OC1M;
   7039            tmpccmrx &= ~TIM_CCMR1_CC1S;
   7040            /* Select the Output Compare Mode */
   7041            tmpccmrx |= OC_Config->OCMode;
   7042          
   7043            /* Reset the Output Polarity level */
   7044            tmpccer &= ~TIM_CCER_CC1P;
   7045            /* Set the Output Compare Polarity */
   7046            tmpccer |= OC_Config->OCPolarity;
   7047          
   7048            if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
   7049            {
   7050              /* Check parameters */
   7051              assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   7052          
   7053              /* Reset the Output N Polarity level */
   7054              tmpccer &= ~TIM_CCER_CC1NP;
   7055              /* Set the Output N Polarity */
   7056              tmpccer |= OC_Config->OCNPolarity;
   7057              /* Reset the Output N State */
   7058              tmpccer &= ~TIM_CCER_CC1NE;
   7059            }
   7060          
   7061            if (IS_TIM_BREAK_INSTANCE(TIMx))
   7062            {
   7063              /* Check parameters */
   7064              assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
   7065              assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   7066          
   7067              /* Reset the Output Compare and Output Compare N IDLE State */
   7068              tmpcr2 &= ~TIM_CR2_OIS1;
   7069              tmpcr2 &= ~TIM_CR2_OIS1N;
   7070              /* Set the Output Idle state */
   7071              tmpcr2 |= OC_Config->OCIdleState;
   7072              /* Set the Output N Idle state */
   7073              tmpcr2 |= OC_Config->OCNIdleState;
   7074            }
   7075          
   7076            /* Write to TIMx CR2 */
   7077            TIMx->CR2 = tmpcr2;
   7078          
   7079            /* Write to TIMx CCMR1 */
   7080            TIMx->CCMR1 = tmpccmrx;
   7081          
   7082            /* Set the Capture Compare Register value */
   7083            TIMx->CCR1 = OC_Config->Pulse;
   7084          
   7085            /* Write to TIMx CCER */
   7086            TIMx->CCER = tmpccer;
   7087          }
   7088          
   7089          /**
   7090            * @brief  Timer Output Compare 2 configuration
   7091            * @param  TIMx to select the TIM peripheral
   7092            * @param  OC_Config The output configuration structure
   7093            * @retval None
   7094            */
   7095          void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, const TIM_OC_InitTypeDef *OC_Config)
   7096          {
   7097            uint32_t tmpccmrx;
   7098            uint32_t tmpccer;
   7099            uint32_t tmpcr2;
   7100          
   7101            /* Get the TIMx CCER register value */
   7102            tmpccer = TIMx->CCER;
   7103          
   7104            /* Disable the Channel 2: Reset the CC2E Bit */
   7105            TIMx->CCER &= ~TIM_CCER_CC2E;
   7106          
   7107            /* Get the TIMx CR2 register value */
   7108            tmpcr2 =  TIMx->CR2;
   7109          
   7110            /* Get the TIMx CCMR1 register value */
   7111            tmpccmrx = TIMx->CCMR1;
   7112          
   7113            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   7114            tmpccmrx &= ~TIM_CCMR1_OC2M;
   7115            tmpccmrx &= ~TIM_CCMR1_CC2S;
   7116          
   7117            /* Select the Output Compare Mode */
   7118            tmpccmrx |= (OC_Config->OCMode << 8U);
   7119          
   7120            /* Reset the Output Polarity level */
   7121            tmpccer &= ~TIM_CCER_CC2P;
   7122            /* Set the Output Compare Polarity */
   7123            tmpccer |= (OC_Config->OCPolarity << 4U);
   7124          
   7125            if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
   7126            {
   7127              assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   7128          
   7129              /* Reset the Output N Polarity level */
   7130              tmpccer &= ~TIM_CCER_CC2NP;
   7131              /* Set the Output N Polarity */
   7132              tmpccer |= (OC_Config->OCNPolarity << 4U);
   7133              /* Reset the Output N State */
   7134              tmpccer &= ~TIM_CCER_CC2NE;
   7135            }
   7136          
   7137            if (IS_TIM_BREAK_INSTANCE(TIMx))
   7138            {
   7139              /* Check parameters */
   7140              assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
   7141              assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   7142          
   7143              /* Reset the Output Compare and Output Compare N IDLE State */
   7144              tmpcr2 &= ~TIM_CR2_OIS2;
   7145              tmpcr2 &= ~TIM_CR2_OIS2N;
   7146              /* Set the Output Idle state */
   7147              tmpcr2 |= (OC_Config->OCIdleState << 2U);
   7148              /* Set the Output N Idle state */
   7149              tmpcr2 |= (OC_Config->OCNIdleState << 2U);
   7150            }
   7151          
   7152            /* Write to TIMx CR2 */
   7153            TIMx->CR2 = tmpcr2;
   7154          
   7155            /* Write to TIMx CCMR1 */
   7156            TIMx->CCMR1 = tmpccmrx;
   7157          
   7158            /* Set the Capture Compare Register value */
   7159            TIMx->CCR2 = OC_Config->Pulse;
   7160          
   7161            /* Write to TIMx CCER */
   7162            TIMx->CCER = tmpccer;
   7163          }
   7164          
   7165          /**
   7166            * @brief  Timer Output Compare 3 configuration
   7167            * @param  TIMx to select the TIM peripheral
   7168            * @param  OC_Config The output configuration structure
   7169            * @retval None
   7170            */
   7171          static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, const TIM_OC_InitTypeDef *OC_Config)
   7172          {
   7173            uint32_t tmpccmrx;
   7174            uint32_t tmpccer;
   7175            uint32_t tmpcr2;
   7176          
   7177            /* Get the TIMx CCER register value */
   7178            tmpccer = TIMx->CCER;
   7179          
   7180            /* Disable the Channel 3: Reset the CC2E Bit */
   7181            TIMx->CCER &= ~TIM_CCER_CC3E;
   7182          
   7183            /* Get the TIMx CR2 register value */
   7184            tmpcr2 =  TIMx->CR2;
   7185          
   7186            /* Get the TIMx CCMR2 register value */
   7187            tmpccmrx = TIMx->CCMR2;
   7188          
   7189            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   7190            tmpccmrx &= ~TIM_CCMR2_OC3M;
   7191            tmpccmrx &= ~TIM_CCMR2_CC3S;
   7192            /* Select the Output Compare Mode */
   7193            tmpccmrx |= OC_Config->OCMode;
   7194          
   7195            /* Reset the Output Polarity level */
   7196            tmpccer &= ~TIM_CCER_CC3P;
   7197            /* Set the Output Compare Polarity */
   7198            tmpccer |= (OC_Config->OCPolarity << 8U);
   7199          
   7200            if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
   7201            {
   7202              assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   7203          
   7204              /* Reset the Output N Polarity level */
   7205              tmpccer &= ~TIM_CCER_CC3NP;
   7206              /* Set the Output N Polarity */
   7207              tmpccer |= (OC_Config->OCNPolarity << 8U);
   7208              /* Reset the Output N State */
   7209              tmpccer &= ~TIM_CCER_CC3NE;
   7210            }
   7211          
   7212            if (IS_TIM_BREAK_INSTANCE(TIMx))
   7213            {
   7214              /* Check parameters */
   7215              assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
   7216              assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   7217          
   7218              /* Reset the Output Compare and Output Compare N IDLE State */
   7219              tmpcr2 &= ~TIM_CR2_OIS3;
   7220              tmpcr2 &= ~TIM_CR2_OIS3N;
   7221              /* Set the Output Idle state */
   7222              tmpcr2 |= (OC_Config->OCIdleState << 4U);
   7223              /* Set the Output N Idle state */
   7224              tmpcr2 |= (OC_Config->OCNIdleState << 4U);
   7225            }
   7226          
   7227            /* Write to TIMx CR2 */
   7228            TIMx->CR2 = tmpcr2;
   7229          
   7230            /* Write to TIMx CCMR2 */
   7231            TIMx->CCMR2 = tmpccmrx;
   7232          
   7233            /* Set the Capture Compare Register value */
   7234            TIMx->CCR3 = OC_Config->Pulse;
   7235          
   7236            /* Write to TIMx CCER */
   7237            TIMx->CCER = tmpccer;
   7238          }
   7239          
   7240          /**
   7241            * @brief  Timer Output Compare 4 configuration
   7242            * @param  TIMx to select the TIM peripheral
   7243            * @param  OC_Config The output configuration structure
   7244            * @retval None
   7245            */
   7246          static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, const TIM_OC_InitTypeDef *OC_Config)
   7247          {
   7248            uint32_t tmpccmrx;
   7249            uint32_t tmpccer;
   7250            uint32_t tmpcr2;
   7251          
   7252            /* Get the TIMx CCER register value */
   7253            tmpccer = TIMx->CCER;
   7254          
   7255            /* Disable the Channel 4: Reset the CC4E Bit */
   7256            TIMx->CCER &= ~TIM_CCER_CC4E;
   7257          
   7258            /* Get the TIMx CR2 register value */
   7259            tmpcr2 =  TIMx->CR2;
   7260          
   7261            /* Get the TIMx CCMR2 register value */
   7262            tmpccmrx = TIMx->CCMR2;
   7263          
   7264            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   7265            tmpccmrx &= ~TIM_CCMR2_OC4M;
   7266            tmpccmrx &= ~TIM_CCMR2_CC4S;
   7267          
   7268            /* Select the Output Compare Mode */
   7269            tmpccmrx |= (OC_Config->OCMode << 8U);
   7270          
   7271            /* Reset the Output Polarity level */
   7272            tmpccer &= ~TIM_CCER_CC4P;
   7273            /* Set the Output Compare Polarity */
   7274            tmpccer |= (OC_Config->OCPolarity << 12U);
   7275          
   7276            if (IS_TIM_BREAK_INSTANCE(TIMx))
   7277            {
   7278              /* Check parameters */
   7279              assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   7280          
   7281              /* Reset the Output Compare IDLE State */
   7282              tmpcr2 &= ~TIM_CR2_OIS4;
   7283          
   7284              /* Set the Output Idle state */
   7285              tmpcr2 |= (OC_Config->OCIdleState << 6U);
   7286            }
   7287          
   7288            /* Write to TIMx CR2 */
   7289            TIMx->CR2 = tmpcr2;
   7290          
   7291            /* Write to TIMx CCMR2 */
   7292            TIMx->CCMR2 = tmpccmrx;
   7293          
   7294            /* Set the Capture Compare Register value */
   7295            TIMx->CCR4 = OC_Config->Pulse;
   7296          
   7297            /* Write to TIMx CCER */
   7298            TIMx->CCER = tmpccer;
   7299          }
   7300          
   7301          /**
   7302            * @brief  Timer Output Compare 5 configuration
   7303            * @param  TIMx to select the TIM peripheral
   7304            * @param  OC_Config The output configuration structure
   7305            * @retval None
   7306            */
   7307          static void TIM_OC5_SetConfig(TIM_TypeDef *TIMx,
   7308                                        const TIM_OC_InitTypeDef *OC_Config)
   7309          {
   7310            uint32_t tmpccmrx;
   7311            uint32_t tmpccer;
   7312            uint32_t tmpcr2;
   7313          
   7314            /* Get the TIMx CCER register value */
   7315            tmpccer = TIMx->CCER;
   7316          
   7317            /* Disable the output: Reset the CCxE Bit */
   7318            TIMx->CCER &= ~TIM_CCER_CC5E;
   7319          
   7320            /* Get the TIMx CR2 register value */
   7321            tmpcr2 =  TIMx->CR2;
   7322            /* Get the TIMx CCMR1 register value */
   7323            tmpccmrx = TIMx->CCMR3;
   7324          
   7325            /* Reset the Output Compare Mode Bits */
   7326            tmpccmrx &= ~(TIM_CCMR3_OC5M);
   7327            /* Select the Output Compare Mode */
   7328            tmpccmrx |= OC_Config->OCMode;
   7329          
   7330            /* Reset the Output Polarity level */
   7331            tmpccer &= ~TIM_CCER_CC5P;
   7332            /* Set the Output Compare Polarity */
   7333            tmpccer |= (OC_Config->OCPolarity << 16U);
   7334          
   7335            if (IS_TIM_BREAK_INSTANCE(TIMx))
   7336            {
   7337              /* Reset the Output Compare IDLE State */
   7338              tmpcr2 &= ~TIM_CR2_OIS5;
   7339              /* Set the Output Idle state */
   7340              tmpcr2 |= (OC_Config->OCIdleState << 8U);
   7341            }
   7342            /* Write to TIMx CR2 */
   7343            TIMx->CR2 = tmpcr2;
   7344          
   7345            /* Write to TIMx CCMR3 */
   7346            TIMx->CCMR3 = tmpccmrx;
   7347          
   7348            /* Set the Capture Compare Register value */
   7349            TIMx->CCR5 = OC_Config->Pulse;
   7350          
   7351            /* Write to TIMx CCER */
   7352            TIMx->CCER = tmpccer;
   7353          }
   7354          
   7355          /**
   7356            * @brief  Timer Output Compare 6 configuration
   7357            * @param  TIMx to select the TIM peripheral
   7358            * @param  OC_Config The output configuration structure
   7359            * @retval None
   7360            */
   7361          static void TIM_OC6_SetConfig(TIM_TypeDef *TIMx,
   7362                                        const TIM_OC_InitTypeDef *OC_Config)
   7363          {
   7364            uint32_t tmpccmrx;
   7365            uint32_t tmpccer;
   7366            uint32_t tmpcr2;
   7367          
   7368            /* Get the TIMx CCER register value */
   7369            tmpccer = TIMx->CCER;
   7370          
   7371            /* Disable the output: Reset the CCxE Bit */
   7372            TIMx->CCER &= ~TIM_CCER_CC6E;
   7373          
   7374            /* Get the TIMx CR2 register value */
   7375            tmpcr2 =  TIMx->CR2;
   7376            /* Get the TIMx CCMR1 register value */
   7377            tmpccmrx = TIMx->CCMR3;
   7378          
   7379            /* Reset the Output Compare Mode Bits */
   7380            tmpccmrx &= ~(TIM_CCMR3_OC6M);
   7381            /* Select the Output Compare Mode */
   7382            tmpccmrx |= (OC_Config->OCMode << 8U);
   7383          
   7384            /* Reset the Output Polarity level */
   7385            tmpccer &= (uint32_t)~TIM_CCER_CC6P;
   7386            /* Set the Output Compare Polarity */
   7387            tmpccer |= (OC_Config->OCPolarity << 20U);
   7388          
   7389            if (IS_TIM_BREAK_INSTANCE(TIMx))
   7390            {
   7391              /* Reset the Output Compare IDLE State */
   7392              tmpcr2 &= ~TIM_CR2_OIS6;
   7393              /* Set the Output Idle state */
   7394              tmpcr2 |= (OC_Config->OCIdleState << 10U);
   7395            }
   7396          
   7397            /* Write to TIMx CR2 */
   7398            TIMx->CR2 = tmpcr2;
   7399          
   7400            /* Write to TIMx CCMR3 */
   7401            TIMx->CCMR3 = tmpccmrx;
   7402          
   7403            /* Set the Capture Compare Register value */
   7404            TIMx->CCR6 = OC_Config->Pulse;
   7405          
   7406            /* Write to TIMx CCER */
   7407            TIMx->CCER = tmpccer;
   7408          }
   7409          
   7410          /**
   7411            * @brief  Slave Timer configuration function
   7412            * @param  htim TIM handle
   7413            * @param  sSlaveConfig Slave timer configuration
   7414            * @retval None
   7415            */
   7416          static HAL_StatusTypeDef TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,
   7417                                                            const TIM_SlaveConfigTypeDef *sSlaveConfig)
   7418          {
   7419            HAL_StatusTypeDef status = HAL_OK;
   7420            uint32_t tmpsmcr;
   7421            uint32_t tmpccmr1;
   7422            uint32_t tmpccer;
   7423          
   7424            /* Get the TIMx SMCR register value */
   7425            tmpsmcr = htim->Instance->SMCR;
   7426          
   7427            /* Reset the Trigger Selection Bits */
   7428            tmpsmcr &= ~TIM_SMCR_TS;
   7429            /* Set the Input Trigger source */
   7430            tmpsmcr |= sSlaveConfig->InputTrigger;
   7431          
   7432            /* Reset the slave mode Bits */
   7433            tmpsmcr &= ~TIM_SMCR_SMS;
   7434            /* Set the slave mode */
   7435            tmpsmcr |= sSlaveConfig->SlaveMode;
   7436          
   7437            /* Write to TIMx SMCR */
   7438            htim->Instance->SMCR = tmpsmcr;
   7439          
   7440            /* Configure the trigger prescaler, filter, and polarity */
   7441            switch (sSlaveConfig->InputTrigger)
   7442            {
   7443              case TIM_TS_ETRF:
   7444              {
   7445                /* Check the parameters */
   7446                assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
   7447                assert_param(IS_TIM_TRIGGERPRESCALER(sSlaveConfig->TriggerPrescaler));
   7448                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   7449                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   7450                /* Configure the ETR Trigger source */
   7451                TIM_ETR_SetConfig(htim->Instance,
   7452                                  sSlaveConfig->TriggerPrescaler,
   7453                                  sSlaveConfig->TriggerPolarity,
   7454                                  sSlaveConfig->TriggerFilter);
   7455                break;
   7456              }
   7457          
   7458              case TIM_TS_TI1F_ED:
   7459              {
   7460                /* Check the parameters */
   7461                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   7462                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   7463          
   7464                if (sSlaveConfig->SlaveMode == TIM_SLAVEMODE_GATED)
   7465                {
   7466                  return HAL_ERROR;
   7467                }
   7468          
   7469                /* Disable the Channel 1: Reset the CC1E Bit */
   7470                tmpccer = htim->Instance->CCER;
   7471                htim->Instance->CCER &= ~TIM_CCER_CC1E;
   7472                tmpccmr1 = htim->Instance->CCMR1;
   7473          
   7474                /* Set the filter */
   7475                tmpccmr1 &= ~TIM_CCMR1_IC1F;
   7476                tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4U);
   7477          
   7478                /* Write to TIMx CCMR1 and CCER registers */
   7479                htim->Instance->CCMR1 = tmpccmr1;
   7480                htim->Instance->CCER = tmpccer;
   7481                break;
   7482              }
   7483          
   7484              case TIM_TS_TI1FP1:
   7485              {
   7486                /* Check the parameters */
   7487                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   7488                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   7489                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   7490          
   7491                /* Configure TI1 Filter and Polarity */
   7492                TIM_TI1_ConfigInputStage(htim->Instance,
   7493                                         sSlaveConfig->TriggerPolarity,
   7494                                         sSlaveConfig->TriggerFilter);
   7495                break;
   7496              }
   7497          
   7498              case TIM_TS_TI2FP2:
   7499              {
   7500                /* Check the parameters */
   7501                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   7502                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   7503                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   7504          
   7505                /* Configure TI2 Filter and Polarity */
   7506                TIM_TI2_ConfigInputStage(htim->Instance,
   7507                                         sSlaveConfig->TriggerPolarity,
   7508                                         sSlaveConfig->TriggerFilter);
   7509                break;
   7510              }
   7511          
   7512              case TIM_TS_ITR0:
   7513              case TIM_TS_ITR1:
   7514              case TIM_TS_ITR2:
   7515              case TIM_TS_ITR3:
   7516              {
   7517                /* Check the parameter */
   7518                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   7519                break;
   7520              }
   7521          
   7522              default:
   7523                status = HAL_ERROR;
   7524                break;
   7525            }
   7526          
   7527            return status;
   7528          }
   7529          
   7530          /**
   7531            * @brief  Configure the TI1 as Input.
   7532            * @param  TIMx to select the TIM peripheral.
   7533            * @param  TIM_ICPolarity The Input Polarity.
   7534            *          This parameter can be one of the following values:
   7535            *            @arg TIM_ICPOLARITY_RISING
   7536            *            @arg TIM_ICPOLARITY_FALLING
   7537            *            @arg TIM_ICPOLARITY_BOTHEDGE
   7538            * @param  TIM_ICSelection specifies the input to be used.
   7539            *          This parameter can be one of the following values:
   7540            *            @arg TIM_ICSELECTION_DIRECTTI: TIM Input 1 is selected to be connected to IC1.
   7541            *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 1 is selected to be connected to IC2.
   7542            *            @arg TIM_ICSELECTION_TRC: TIM Input 1 is selected to be connected to TRC.
   7543            * @param  TIM_ICFilter Specifies the Input Capture Filter.
   7544            *          This parameter must be a value between 0x00 and 0x0F.
   7545            * @retval None
   7546            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI2FP1
   7547            *       (on channel2 path) is used as the input signal. Therefore CCMR1 must be
   7548            *        protected against un-initialized filter and polarity values.
   7549            */
   7550          void TIM_TI1_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   7551                                 uint32_t TIM_ICFilter)
   7552          {
   7553            uint32_t tmpccmr1;
   7554            uint32_t tmpccer;
   7555          
   7556            /* Disable the Channel 1: Reset the CC1E Bit */
   7557            tmpccer = TIMx->CCER;
   7558            TIMx->CCER &= ~TIM_CCER_CC1E;
   7559            tmpccmr1 = TIMx->CCMR1;
   7560          
   7561            /* Select the Input */
   7562            if (IS_TIM_CC2_INSTANCE(TIMx) != RESET)
   7563            {
   7564              tmpccmr1 &= ~TIM_CCMR1_CC1S;
   7565              tmpccmr1 |= TIM_ICSelection;
   7566            }
   7567            else
   7568            {
   7569              tmpccmr1 |= TIM_CCMR1_CC1S_0;
   7570            }
   7571          
   7572            /* Set the filter */
   7573            tmpccmr1 &= ~TIM_CCMR1_IC1F;
   7574            tmpccmr1 |= ((TIM_ICFilter << 4U) & TIM_CCMR1_IC1F);
   7575          
   7576            /* Select the Polarity and set the CC1E Bit */
   7577            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
   7578            tmpccer |= (TIM_ICPolarity & (TIM_CCER_CC1P | TIM_CCER_CC1NP));
   7579          
   7580            /* Write to TIMx CCMR1 and CCER registers */
   7581            TIMx->CCMR1 = tmpccmr1;
   7582            TIMx->CCER = tmpccer;
   7583          }
   7584          
   7585          /**
   7586            * @brief  Configure the Polarity and Filter for TI1.
   7587            * @param  TIMx to select the TIM peripheral.
   7588            * @param  TIM_ICPolarity The Input Polarity.
   7589            *          This parameter can be one of the following values:
   7590            *            @arg TIM_ICPOLARITY_RISING
   7591            *            @arg TIM_ICPOLARITY_FALLING
   7592            *            @arg TIM_ICPOLARITY_BOTHEDGE
   7593            * @param  TIM_ICFilter Specifies the Input Capture Filter.
   7594            *          This parameter must be a value between 0x00 and 0x0F.
   7595            * @retval None
   7596            */
   7597          static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
   7598          {
   7599            uint32_t tmpccmr1;
   7600            uint32_t tmpccer;
   7601          
   7602            /* Disable the Channel 1: Reset the CC1E Bit */
   7603            tmpccer = TIMx->CCER;
   7604            TIMx->CCER &= ~TIM_CCER_CC1E;
   7605            tmpccmr1 = TIMx->CCMR1;
   7606          
   7607            /* Set the filter */
   7608            tmpccmr1 &= ~TIM_CCMR1_IC1F;
   7609            tmpccmr1 |= (TIM_ICFilter << 4U);
   7610          
   7611            /* Select the Polarity and set the CC1E Bit */
   7612            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
   7613            tmpccer |= TIM_ICPolarity;
   7614          
   7615            /* Write to TIMx CCMR1 and CCER registers */
   7616            TIMx->CCMR1 = tmpccmr1;
   7617            TIMx->CCER = tmpccer;
   7618          }
   7619          
   7620          /**
   7621            * @brief  Configure the TI2 as Input.
   7622            * @param  TIMx to select the TIM peripheral
   7623            * @param  TIM_ICPolarity The Input Polarity.
   7624            *          This parameter can be one of the following values:
   7625            *            @arg TIM_ICPOLARITY_RISING
   7626            *            @arg TIM_ICPOLARITY_FALLING
   7627            *            @arg TIM_ICPOLARITY_BOTHEDGE
   7628            * @param  TIM_ICSelection specifies the input to be used.
   7629            *          This parameter can be one of the following values:
   7630            *            @arg TIM_ICSELECTION_DIRECTTI: TIM Input 2 is selected to be connected to IC2.
   7631            *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 2 is selected to be connected to IC1.
   7632            *            @arg TIM_ICSELECTION_TRC: TIM Input 2 is selected to be connected to TRC.
   7633            * @param  TIM_ICFilter Specifies the Input Capture Filter.
   7634            *          This parameter must be a value between 0x00 and 0x0F.
   7635            * @retval None
   7636            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI1FP2
   7637            *       (on channel1 path) is used as the input signal. Therefore CCMR1 must be
   7638            *        protected against un-initialized filter and polarity values.
   7639            */
   7640          static void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   7641                                        uint32_t TIM_ICFilter)
   7642          {
   7643            uint32_t tmpccmr1;
   7644            uint32_t tmpccer;
   7645          
   7646            /* Disable the Channel 2: Reset the CC2E Bit */
   7647            tmpccer = TIMx->CCER;
   7648            TIMx->CCER &= ~TIM_CCER_CC2E;
   7649            tmpccmr1 = TIMx->CCMR1;
   7650          
   7651            /* Select the Input */
   7652            tmpccmr1 &= ~TIM_CCMR1_CC2S;
   7653            tmpccmr1 |= (TIM_ICSelection << 8U);
   7654          
   7655            /* Set the filter */
   7656            tmpccmr1 &= ~TIM_CCMR1_IC2F;
   7657            tmpccmr1 |= ((TIM_ICFilter << 12U) & TIM_CCMR1_IC2F);
   7658          
   7659            /* Select the Polarity and set the CC2E Bit */
   7660            tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
   7661            tmpccer |= ((TIM_ICPolarity << 4U) & (TIM_CCER_CC2P | TIM_CCER_CC2NP));
   7662          
   7663            /* Write to TIMx CCMR1 and CCER registers */
   7664            TIMx->CCMR1 = tmpccmr1 ;
   7665            TIMx->CCER = tmpccer;
   7666          }
   7667          
   7668          /**
   7669            * @brief  Configure the Polarity and Filter for TI2.
   7670            * @param  TIMx to select the TIM peripheral.
   7671            * @param  TIM_ICPolarity The Input Polarity.
   7672            *          This parameter can be one of the following values:
   7673            *            @arg TIM_ICPOLARITY_RISING
   7674            *            @arg TIM_ICPOLARITY_FALLING
   7675            *            @arg TIM_ICPOLARITY_BOTHEDGE
   7676            * @param  TIM_ICFilter Specifies the Input Capture Filter.
   7677            *          This parameter must be a value between 0x00 and 0x0F.
   7678            * @retval None
   7679            */
   7680          static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
   7681          {
   7682            uint32_t tmpccmr1;
   7683            uint32_t tmpccer;
   7684          
   7685            /* Disable the Channel 2: Reset the CC2E Bit */
   7686            tmpccer = TIMx->CCER;
   7687            TIMx->CCER &= ~TIM_CCER_CC2E;
   7688            tmpccmr1 = TIMx->CCMR1;
   7689          
   7690            /* Set the filter */
   7691            tmpccmr1 &= ~TIM_CCMR1_IC2F;
   7692            tmpccmr1 |= (TIM_ICFilter << 12U);
   7693          
   7694            /* Select the Polarity and set the CC2E Bit */
   7695            tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
   7696            tmpccer |= (TIM_ICPolarity << 4U);
   7697          
   7698            /* Write to TIMx CCMR1 and CCER registers */
   7699            TIMx->CCMR1 = tmpccmr1 ;
   7700            TIMx->CCER = tmpccer;
   7701          }
   7702          
   7703          /**
   7704            * @brief  Configure the TI3 as Input.
   7705            * @param  TIMx to select the TIM peripheral
   7706            * @param  TIM_ICPolarity The Input Polarity.
   7707            *          This parameter can be one of the following values:
   7708            *            @arg TIM_ICPOLARITY_RISING
   7709            *            @arg TIM_ICPOLARITY_FALLING
   7710            *            @arg TIM_ICPOLARITY_BOTHEDGE
   7711            * @param  TIM_ICSelection specifies the input to be used.
   7712            *          This parameter can be one of the following values:
   7713            *            @arg TIM_ICSELECTION_DIRECTTI: TIM Input 3 is selected to be connected to IC3.
   7714            *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 3 is selected to be connected to IC4.
   7715            *            @arg TIM_ICSELECTION_TRC: TIM Input 3 is selected to be connected to TRC.
   7716            * @param  TIM_ICFilter Specifies the Input Capture Filter.
   7717            *          This parameter must be a value between 0x00 and 0x0F.
   7718            * @retval None
   7719            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI3FP4
   7720            *       (on channel1 path) is used as the input signal. Therefore CCMR2 must be
   7721            *        protected against un-initialized filter and polarity values.
   7722            */
   7723          static void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   7724                                        uint32_t TIM_ICFilter)
   7725          {
   7726            uint32_t tmpccmr2;
   7727            uint32_t tmpccer;
   7728          
   7729            /* Disable the Channel 3: Reset the CC3E Bit */
   7730            tmpccer = TIMx->CCER;
   7731            TIMx->CCER &= ~TIM_CCER_CC3E;
   7732            tmpccmr2 = TIMx->CCMR2;
   7733          
   7734            /* Select the Input */
   7735            tmpccmr2 &= ~TIM_CCMR2_CC3S;
   7736            tmpccmr2 |= TIM_ICSelection;
   7737          
   7738            /* Set the filter */
   7739            tmpccmr2 &= ~TIM_CCMR2_IC3F;
   7740            tmpccmr2 |= ((TIM_ICFilter << 4U) & TIM_CCMR2_IC3F);
   7741          
   7742            /* Select the Polarity and set the CC3E Bit */
   7743            tmpccer &= ~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
   7744            tmpccer |= ((TIM_ICPolarity << 8U) & (TIM_CCER_CC3P | TIM_CCER_CC3NP));
   7745          
   7746            /* Write to TIMx CCMR2 and CCER registers */
   7747            TIMx->CCMR2 = tmpccmr2;
   7748            TIMx->CCER = tmpccer;
   7749          }
   7750          
   7751          /**
   7752            * @brief  Configure the TI4 as Input.
   7753            * @param  TIMx to select the TIM peripheral
   7754            * @param  TIM_ICPolarity The Input Polarity.
   7755            *          This parameter can be one of the following values:
   7756            *            @arg TIM_ICPOLARITY_RISING
   7757            *            @arg TIM_ICPOLARITY_FALLING
   7758            *            @arg TIM_ICPOLARITY_BOTHEDGE
   7759            * @param  TIM_ICSelection specifies the input to be used.
   7760            *          This parameter can be one of the following values:
   7761            *            @arg TIM_ICSELECTION_DIRECTTI: TIM Input 4 is selected to be connected to IC4.
   7762            *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 4 is selected to be connected to IC3.
   7763            *            @arg TIM_ICSELECTION_TRC: TIM Input 4 is selected to be connected to TRC.
   7764            * @param  TIM_ICFilter Specifies the Input Capture Filter.
   7765            *          This parameter must be a value between 0x00 and 0x0F.
   7766            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI4FP3
   7767            *       (on channel1 path) is used as the input signal. Therefore CCMR2 must be
   7768            *        protected against un-initialized filter and polarity values.
   7769            * @retval None
   7770            */
   7771          static void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   7772                                        uint32_t TIM_ICFilter)
   7773          {
   7774            uint32_t tmpccmr2;
   7775            uint32_t tmpccer;
   7776          
   7777            /* Disable the Channel 4: Reset the CC4E Bit */
   7778            tmpccer = TIMx->CCER;
   7779            TIMx->CCER &= ~TIM_CCER_CC4E;
   7780            tmpccmr2 = TIMx->CCMR2;
   7781          
   7782            /* Select the Input */
   7783            tmpccmr2 &= ~TIM_CCMR2_CC4S;
   7784            tmpccmr2 |= (TIM_ICSelection << 8U);
   7785          
   7786            /* Set the filter */
   7787            tmpccmr2 &= ~TIM_CCMR2_IC4F;
   7788            tmpccmr2 |= ((TIM_ICFilter << 12U) & TIM_CCMR2_IC4F);
   7789          
   7790            /* Select the Polarity and set the CC4E Bit */
   7791            tmpccer &= ~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
   7792            tmpccer |= ((TIM_ICPolarity << 12U) & (TIM_CCER_CC4P | TIM_CCER_CC4NP));
   7793          
   7794            /* Write to TIMx CCMR2 and CCER registers */
   7795            TIMx->CCMR2 = tmpccmr2;
   7796            TIMx->CCER = tmpccer ;
   7797          }
   7798          
   7799          /**
   7800            * @brief  Selects the Input Trigger source
   7801            * @param  TIMx to select the TIM peripheral
   7802            * @param  InputTriggerSource The Input Trigger source.
   7803            *          This parameter can be one of the following values:
   7804            *            @arg TIM_TS_ITR0: Internal Trigger 0
   7805            *            @arg TIM_TS_ITR1: Internal Trigger 1
   7806            *            @arg TIM_TS_ITR2: Internal Trigger 2
   7807            *            @arg TIM_TS_ITR3: Internal Trigger 3
   7808            *            @arg TIM_TS_TI1F_ED: TI1 Edge Detector
   7809            *            @arg TIM_TS_TI1FP1: Filtered Timer Input 1
   7810            *            @arg TIM_TS_TI2FP2: Filtered Timer Input 2
   7811            *            @arg TIM_TS_ETRF: External Trigger input
   7812            * @retval None
   7813            */
   7814          static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint32_t InputTriggerSource)
   7815          {
   7816            uint32_t tmpsmcr;
   7817          
   7818            /* Get the TIMx SMCR register value */
   7819            tmpsmcr = TIMx->SMCR;
   7820            /* Reset the TS Bits */
   7821            tmpsmcr &= ~TIM_SMCR_TS;
   7822            /* Set the Input Trigger source and the slave mode*/
   7823            tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
   7824            /* Write to TIMx SMCR */
   7825            TIMx->SMCR = tmpsmcr;
   7826          }
   7827          /**
   7828            * @brief  Configures the TIMx External Trigger (ETR).
   7829            * @param  TIMx to select the TIM peripheral
   7830            * @param  TIM_ExtTRGPrescaler The external Trigger Prescaler.
   7831            *          This parameter can be one of the following values:
   7832            *            @arg TIM_ETRPRESCALER_DIV1: ETRP Prescaler OFF.
   7833            *            @arg TIM_ETRPRESCALER_DIV2: ETRP frequency divided by 2.
   7834            *            @arg TIM_ETRPRESCALER_DIV4: ETRP frequency divided by 4.
   7835            *            @arg TIM_ETRPRESCALER_DIV8: ETRP frequency divided by 8.
   7836            * @param  TIM_ExtTRGPolarity The external Trigger Polarity.
   7837            *          This parameter can be one of the following values:
   7838            *            @arg TIM_ETRPOLARITY_INVERTED: active low or falling edge active.
   7839            *            @arg TIM_ETRPOLARITY_NONINVERTED: active high or rising edge active.
   7840            * @param  ExtTRGFilter External Trigger Filter.
   7841            *          This parameter must be a value between 0x00 and 0x0F
   7842            * @retval None
   7843            */
   7844          void TIM_ETR_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ExtTRGPrescaler,
   7845                                 uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
   7846          {
   7847            uint32_t tmpsmcr;
   7848          
   7849            tmpsmcr = TIMx->SMCR;
   7850          
   7851            /* Reset the ETR Bits */
   7852            tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
   7853          
   7854            /* Set the Prescaler, the Filter value and the Polarity */
   7855            tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
   7856          
   7857            /* Write to TIMx SMCR */
   7858            TIMx->SMCR = tmpsmcr;
   7859          }
   7860          
   7861          /**
   7862            * @brief  Enables or disables the TIM Capture Compare Channel x.
   7863            * @param  TIMx to select the TIM peripheral
   7864            * @param  Channel specifies the TIM Channel
   7865            *          This parameter can be one of the following values:
   7866            *            @arg TIM_CHANNEL_1: TIM Channel 1
   7867            *            @arg TIM_CHANNEL_2: TIM Channel 2
   7868            *            @arg TIM_CHANNEL_3: TIM Channel 3
   7869            *            @arg TIM_CHANNEL_4: TIM Channel 4
   7870            *            @arg TIM_CHANNEL_5: TIM Channel 5 selected
   7871            *            @arg TIM_CHANNEL_6: TIM Channel 6 selected
   7872            * @param  ChannelState specifies the TIM Channel CCxE bit new state.
   7873            *          This parameter can be: TIM_CCx_ENABLE or TIM_CCx_DISABLE.
   7874            * @retval None
   7875            */
   7876          void TIM_CCxChannelCmd(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ChannelState)
   7877          {
   7878            uint32_t tmp;
   7879          
   7880            /* Check the parameters */
   7881            assert_param(IS_TIM_CC1_INSTANCE(TIMx));
   7882            assert_param(IS_TIM_CHANNELS(Channel));
   7883          
   7884            tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
   7885          
   7886            /* Reset the CCxE Bit */
   7887            TIMx->CCER &= ~tmp;
   7888          
   7889            /* Set or reset the CCxE Bit */
   7890            TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
   7891          }
   7892          
   7893          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   7894          /**
   7895            * @brief  Reset interrupt callbacks to the legacy weak callbacks.
   7896            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   7897            *                the configuration information for TIM module.
   7898            * @retval None
   7899            */
   7900          void TIM_ResetCallback(TIM_HandleTypeDef *htim)
   7901          {
   7902            /* Reset the TIM callback to the legacy weak callbacks */
   7903            htim->PeriodElapsedCallback             = HAL_TIM_PeriodElapsedCallback;
   7904            htim->PeriodElapsedHalfCpltCallback     = HAL_TIM_PeriodElapsedHalfCpltCallback;
   7905            htim->TriggerCallback                   = HAL_TIM_TriggerCallback;
   7906            htim->TriggerHalfCpltCallback           = HAL_TIM_TriggerHalfCpltCallback;
   7907            htim->IC_CaptureCallback                = HAL_TIM_IC_CaptureCallback;
   7908            htim->IC_CaptureHalfCpltCallback        = HAL_TIM_IC_CaptureHalfCpltCallback;
   7909            htim->OC_DelayElapsedCallback           = HAL_TIM_OC_DelayElapsedCallback;
   7910            htim->PWM_PulseFinishedCallback         = HAL_TIM_PWM_PulseFinishedCallback;
   7911            htim->PWM_PulseFinishedHalfCpltCallback = HAL_TIM_PWM_PulseFinishedHalfCpltCallback;
   7912            htim->ErrorCallback                     = HAL_TIM_ErrorCallback;
   7913            htim->CommutationCallback               = HAL_TIMEx_CommutCallback;
   7914            htim->CommutationHalfCpltCallback       = HAL_TIMEx_CommutHalfCpltCallback;
   7915            htim->BreakCallback                     = HAL_TIMEx_BreakCallback;
   7916            htim->Break2Callback                    = HAL_TIMEx_Break2Callback;
   7917          }
   7918          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   7919          
   7920          /**
   7921            * @}
   7922            */
   7923          
   7924          #endif /* HAL_TIM_MODULE_ENABLED */
   7925          /**
   7926            * @}
   7927            */
   7928          
   7929          /**
   7930            * @}
   7931            */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   HAL_TIM_Base_DeInit
         8   -> HAL_TIM_Base_MspDeInit
       0   HAL_TIM_Base_GetState
       8   HAL_TIM_Base_Init
         8   -> HAL_TIM_Base_MspInit
         8   -> TIM_Base_SetConfig
       0   HAL_TIM_Base_MspDeInit
       0   HAL_TIM_Base_MspInit
       4   HAL_TIM_Base_Start
      24   HAL_TIM_Base_Start_DMA
        24   -> HAL_DMA_Start_IT
       8   HAL_TIM_Base_Start_IT
       4   HAL_TIM_Base_Stop
       8   HAL_TIM_Base_Stop_DMA
         8   -> HAL_DMA_Abort_IT
       4   HAL_TIM_Base_Stop_IT
      32   HAL_TIM_ConfigClockSource
        32   -> TIM_ETR_SetConfig
        32   -> TIM_ITRx_SetConfig
        32   -> TIM_TI1_ConfigInputStage
        32   -> TIM_TI2_ConfigInputStage
      32   HAL_TIM_ConfigOCrefClear
        32   -> TIM_ETR_SetConfig
       0   HAL_TIM_ConfigTI1Input
       0   HAL_TIM_DMABurstState
      32   HAL_TIM_DMABurst_MultiReadStart
        32   -> HAL_DMA_Start_IT
      32   HAL_TIM_DMABurst_MultiWriteStart
        32   -> HAL_DMA_Start_IT
      32   HAL_TIM_DMABurst_ReadStart
        32   -> HAL_TIM_DMABurst_MultiReadStart
      16   HAL_TIM_DMABurst_ReadStop
        16   -> HAL_DMA_Abort_IT
      32   HAL_TIM_DMABurst_WriteStart
        32   -> HAL_TIM_DMABurst_MultiWriteStart
      16   HAL_TIM_DMABurst_WriteStop
        16   -> HAL_DMA_Abort_IT
       8   HAL_TIM_Encoder_DeInit
         8   -> HAL_TIM_Encoder_MspDeInit
       0   HAL_TIM_Encoder_GetState
      16   HAL_TIM_Encoder_Init
        16   -> HAL_TIM_Encoder_MspInit
        16   -> TIM_Base_SetConfig
       0   HAL_TIM_Encoder_MspDeInit
       0   HAL_TIM_Encoder_MspInit
      24   HAL_TIM_Encoder_Start
        24   -> TIM_CCxChannelCmd
      40   HAL_TIM_Encoder_Start_DMA
        40   -> HAL_DMA_Start_IT
        40   -> TIM_CCxChannelCmd
      24   HAL_TIM_Encoder_Start_IT
        24   -> TIM_CCxChannelCmd
      16   HAL_TIM_Encoder_Stop
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_Encoder_Stop_DMA
        16   -> HAL_DMA_Abort_IT
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_Encoder_Stop_IT
        16   -> TIM_CCxChannelCmd
       0   HAL_TIM_ErrorCallback
       8   HAL_TIM_GenerateEvent
       0   HAL_TIM_GetActiveChannel
       4   HAL_TIM_GetChannelState
       0   HAL_TIM_IC_CaptureCallback
       0   HAL_TIM_IC_CaptureHalfCpltCallback
      24   HAL_TIM_IC_ConfigChannel
        24   -> TIM_TI1_SetConfig
        24   -> TIM_TI2_SetConfig
        24   -> TIM_TI3_SetConfig
        24   -> TIM_TI4_SetConfig
       8   HAL_TIM_IC_DeInit
         8   -> HAL_TIM_IC_MspDeInit
       0   HAL_TIM_IC_GetState
       8   HAL_TIM_IC_Init
         8   -> HAL_TIM_IC_MspInit
         8   -> TIM_Base_SetConfig
       0   HAL_TIM_IC_MspDeInit
       0   HAL_TIM_IC_MspInit
      24   HAL_TIM_IC_Start
        24   -> TIM_CCxChannelCmd
      32   HAL_TIM_IC_Start_DMA
        32   -> HAL_DMA_Start_IT
        32   -> TIM_CCxChannelCmd
      32   HAL_TIM_IC_Start_IT
        32   -> TIM_CCxChannelCmd
      16   HAL_TIM_IC_Stop
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_IC_Stop_DMA
        16   -> HAL_DMA_Abort_IT
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_IC_Stop_IT
        16   -> TIM_CCxChannelCmd
      24   HAL_TIM_IRQHandler
        24   -> HAL_TIMEx_Break2Callback
        24   -> HAL_TIMEx_BreakCallback
        24   -> HAL_TIMEx_CommutCallback
        24   -> HAL_TIM_IC_CaptureCallback
        24   -> HAL_TIM_OC_DelayElapsedCallback
        24   -> HAL_TIM_PWM_PulseFinishedCallback
        24   -> HAL_TIM_PeriodElapsedCallback
        24   -> HAL_TIM_TriggerCallback
      24   HAL_TIM_OC_ConfigChannel
        24   -> TIM_OC1_SetConfig
        24   -> TIM_OC2_SetConfig
        24   -> TIM_OC3_SetConfig
        24   -> TIM_OC4_SetConfig
        24   -> TIM_OC5_SetConfig
        24   -> TIM_OC6_SetConfig
       8   HAL_TIM_OC_DeInit
         8   -> HAL_TIM_OC_MspDeInit
       0   HAL_TIM_OC_DelayElapsedCallback
       0   HAL_TIM_OC_GetState
       8   HAL_TIM_OC_Init
         8   -> HAL_TIM_OC_MspInit
         8   -> TIM_Base_SetConfig
       0   HAL_TIM_OC_MspDeInit
       0   HAL_TIM_OC_MspInit
      16   HAL_TIM_OC_Start
        16   -> TIM_CCxChannelCmd
      32   HAL_TIM_OC_Start_DMA
        32   -> HAL_DMA_Start_IT
        32   -> TIM_CCxChannelCmd
      24   HAL_TIM_OC_Start_IT
        24   -> TIM_CCxChannelCmd
      16   HAL_TIM_OC_Stop
        16   -> TIM_CCxChannelCmd
      24   HAL_TIM_OC_Stop_DMA
        24   -> HAL_DMA_Abort_IT
        24   -> TIM_CCxChannelCmd
      24   HAL_TIM_OC_Stop_IT
        24   -> TIM_CCxChannelCmd
      64   HAL_TIM_OnePulse_ConfigChannel
        64   -> TIM_OC1_SetConfig
        64   -> TIM_OC2_SetConfig
        64   -> TIM_TI1_SetConfig
        64   -> TIM_TI2_SetConfig
       8   HAL_TIM_OnePulse_DeInit
         8   -> HAL_TIM_OnePulse_MspDeInit
       0   HAL_TIM_OnePulse_GetState
      16   HAL_TIM_OnePulse_Init
        16   -> HAL_TIM_OnePulse_MspInit
        16   -> TIM_Base_SetConfig
       0   HAL_TIM_OnePulse_MspDeInit
       0   HAL_TIM_OnePulse_MspInit
      24   HAL_TIM_OnePulse_Start
        24   -> TIM_CCxChannelCmd
      24   HAL_TIM_OnePulse_Start_IT
        24   -> TIM_CCxChannelCmd
      16   HAL_TIM_OnePulse_Stop
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_OnePulse_Stop_IT
        16   -> TIM_CCxChannelCmd
      24   HAL_TIM_PWM_ConfigChannel
        24   -> TIM_OC1_SetConfig
        24   -> TIM_OC2_SetConfig
        24   -> TIM_OC3_SetConfig
        24   -> TIM_OC4_SetConfig
        24   -> TIM_OC5_SetConfig
        24   -> TIM_OC6_SetConfig
       8   HAL_TIM_PWM_DeInit
         8   -> HAL_TIM_PWM_MspDeInit
       0   HAL_TIM_PWM_GetState
       8   HAL_TIM_PWM_Init
         8   -> HAL_TIM_PWM_MspInit
         8   -> TIM_Base_SetConfig
       0   HAL_TIM_PWM_MspDeInit
       0   HAL_TIM_PWM_MspInit
       0   HAL_TIM_PWM_PulseFinishedCallback
       0   HAL_TIM_PWM_PulseFinishedHalfCpltCallback
      16   HAL_TIM_PWM_Start
        16   -> TIM_CCxChannelCmd
      32   HAL_TIM_PWM_Start_DMA
        32   -> HAL_DMA_Start_IT
        32   -> TIM_CCxChannelCmd
      24   HAL_TIM_PWM_Start_IT
        24   -> TIM_CCxChannelCmd
      16   HAL_TIM_PWM_Stop
        16   -> TIM_CCxChannelCmd
      24   HAL_TIM_PWM_Stop_DMA
        24   -> HAL_DMA_Abort_IT
        24   -> TIM_CCxChannelCmd
      24   HAL_TIM_PWM_Stop_IT
        24   -> TIM_CCxChannelCmd
       0   HAL_TIM_PeriodElapsedCallback
       0   HAL_TIM_PeriodElapsedHalfCpltCallback
       4   HAL_TIM_ReadCapturedValue
      16   HAL_TIM_SlaveConfigSynchro
        16   -> TIM_SlaveTimer_SetConfig
      16   HAL_TIM_SlaveConfigSynchro_IT
        16   -> TIM_SlaveTimer_SetConfig
       0   HAL_TIM_TriggerCallback
       0   HAL_TIM_TriggerHalfCpltCallback
       8   TIM_Base_SetConfig
      12   TIM_CCxChannelCmd
      16   TIM_DMACaptureCplt
        16   -> HAL_TIM_IC_CaptureCallback
      16   TIM_DMACaptureHalfCplt
        16   -> HAL_TIM_IC_CaptureHalfCpltCallback
      16   TIM_DMADelayPulseCplt
        16   -> HAL_TIM_PWM_PulseFinishedCallback
      16   TIM_DMADelayPulseHalfCplt
        16   -> HAL_TIM_PWM_PulseFinishedHalfCpltCallback
      16   TIM_DMAError
        16   -> HAL_TIM_ErrorCallback
      16   TIM_DMAPeriodElapsedCplt
        16   -> HAL_TIM_PeriodElapsedCallback
      16   TIM_DMAPeriodElapsedHalfCplt
        16   -> HAL_TIM_PeriodElapsedHalfCpltCallback
      16   TIM_DMATriggerCplt
        16   -> HAL_TIM_TriggerCallback
      16   TIM_DMATriggerHalfCplt
        16   -> HAL_TIM_TriggerHalfCpltCallback
       8   TIM_ETR_SetConfig
       0   TIM_ITRx_SetConfig
      16   TIM_OC1_SetConfig
      16   TIM_OC2_SetConfig
      20   TIM_OC3_SetConfig
      16   TIM_OC4_SetConfig
      16   TIM_OC5_SetConfig
      12   TIM_OC6_SetConfig
      32   TIM_SlaveTimer_SetConfig
        32   -> TIM_ETR_SetConfig
        32   -> TIM_TI1_ConfigInputStage
        32   -> TIM_TI2_ConfigInputStage
       8   TIM_TI1_ConfigInputStage
      20   TIM_TI1_SetConfig
       8   TIM_TI2_ConfigInputStage
      16   TIM_TI2_SetConfig
      16   TIM_TI3_SetConfig
      16   TIM_TI4_SetConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_2
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable12_5
       4  ??DataTable12_6
       4  ??DataTable12_7
       4  ??DataTable12_8
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable15_7
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_2
       4  ??DataTable17_3
       4  ??DataTable17_4
       4  ??DataTable17_5
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_2
       4  ??DataTable18_3
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable19_2
       4  ??DataTable19_3
       4  ??DataTable19_4
       4  ??DataTable19_5
       4  ??DataTable19_6
       4  ??DataTable19_7
       4  ??DataTable19_8
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_2
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable21_2
       4  ??DataTable21_3
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable22_2
       4  ??DataTable22_3
       4  ??DataTable22_4
       4  ??DataTable22_5
       4  ??DataTable22_6
       4  ??DataTable22_7
       4  ??DataTable22_8
       4  ??DataTable22_9
       4  ??DataTable24
       4  ??DataTable24_1
       4  ??DataTable24_2
       4  ??DataTable24_3
       4  ??DataTable25
       4  ??DataTable25_1
       4  ??DataTable25_2
       4  ??DataTable26
       4  ??DataTable26_1
       4  ??DataTable26_2
       4  ??DataTable26_3
       4  ??DataTable26_4
       4  ??DataTable26_5
       4  ??DataTable28
       4  ??DataTable28_1
       4  ??DataTable28_2
       4  ??DataTable29
       4  ??DataTable29_1
       4  ??DataTable29_2
       4  ??DataTable29_3
       4  ??DataTable29_4
       4  ??DataTable30
       4  ??DataTable30_1
       4  ??DataTable30_2
       4  ??DataTable30_3
       4  ??DataTable30_4
       4  ??DataTable31
       4  ??DataTable32
       4  ??DataTable33
       4  ??DataTable33_1
       4  ??DataTable33_2
       4  ??DataTable34
       4  ??DataTable34_1
       4  ??DataTable35
       4  ??DataTable35_1
       4  ??DataTable35_2
       4  ??DataTable36
       4  ??DataTable36_1
       4  ??DataTable36_2
       4  ??DataTable36_3
       4  ??DataTable36_4
       4  ??DataTable37
       4  ??DataTable37_1
       4  ??DataTable39
       4  ??DataTable39_1
       4  ??DataTable39_2
       4  ??DataTable40
       4  ??DataTable40_1
       4  ??DataTable40_2
       4  ??DataTable40_3
       4  ??DataTable42
       4  ??DataTable42_1
       4  ??DataTable43
       4  ??DataTable43_1
       4  ??DataTable44
       4  ??DataTable44_1
       4  ??DataTable44_10
       4  ??DataTable44_2
       4  ??DataTable44_3
       4  ??DataTable44_4
       4  ??DataTable44_5
       4  ??DataTable44_6
       4  ??DataTable44_7
       4  ??DataTable44_8
       4  ??DataTable44_9
       4  ??DataTable45
       4  ??DataTable45_1
       4  ??DataTable45_2
       4  ??DataTable45_3
       4  ??DataTable45_4
       4  ??DataTable45_5
       4  ??DataTable45_6
       4  ??DataTable46
       4  ??DataTable46_1
       4  ??DataTable48
       4  ??DataTable49
       4  ??DataTable49_1
       4  ??DataTable49_2
       4  ??DataTable49_3
       4  ??DataTable5
       4  ??DataTable53
       4  ??DataTable53_1
       4  ??DataTable53_2
       4  ??DataTable53_3
       4  ??DataTable53_4
       4  ??DataTable53_5
       4  ??DataTable53_6
       4  ??DataTable54
       4  ??DataTable55
       4  ??DataTable55_1
       4  ??DataTable55_2
       4  ??DataTable56
       4  ??DataTable56_1
       4  ??DataTable57
       4  ??DataTable57_1
       4  ??DataTable58
       4  ??DataTable58_1
       4  ??DataTable58_2
       4  ??DataTable59
       4  ??DataTable59_1
       4  ??DataTable60
       4  ??DataTable61
       4  ??DataTable61_1
       4  ??DataTable63
       4  ??DataTable64
       4  ??DataTable64_1
       4  ??DataTable64_10
       4  ??DataTable64_11
       4  ??DataTable64_12
       4  ??DataTable64_13
       4  ??DataTable64_14
       4  ??DataTable64_15
       4  ??DataTable64_2
       4  ??DataTable64_3
       4  ??DataTable64_4
       4  ??DataTable64_5
       4  ??DataTable64_6
       4  ??DataTable64_7
       4  ??DataTable64_8
       4  ??DataTable64_9
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable9
       4  ??DataTable9_1
     134  HAL_TIM_Base_DeInit
       6  HAL_TIM_Base_GetState
     100  HAL_TIM_Base_Init
       2  HAL_TIM_Base_MspDeInit
       2  HAL_TIM_Base_MspInit
     116  HAL_TIM_Base_Start
     208  HAL_TIM_Base_Start_DMA
     124  HAL_TIM_Base_Start_IT
      50  HAL_TIM_Base_Stop
      68  HAL_TIM_Base_Stop_DMA
      62  HAL_TIM_Base_Stop_IT
     256  HAL_TIM_ConfigClockSource
     440  HAL_TIM_ConfigOCrefClear
      20  HAL_TIM_ConfigTI1Input
       6  HAL_TIM_DMABurstState
     460  HAL_TIM_DMABurst_MultiReadStart
     460  HAL_TIM_DMABurst_MultiWriteStart
      36  HAL_TIM_DMABurst_ReadStart
     158  HAL_TIM_DMABurst_ReadStop
      36  HAL_TIM_DMABurst_WriteStart
     158  HAL_TIM_DMABurst_WriteStop
     106  HAL_TIM_Encoder_DeInit
       6  HAL_TIM_Encoder_GetState
     196  HAL_TIM_Encoder_Init
       2  HAL_TIM_Encoder_MspDeInit
       2  HAL_TIM_Encoder_MspInit
     254  HAL_TIM_Encoder_Start
     660  HAL_TIM_Encoder_Start_DMA
     302  HAL_TIM_Encoder_Start_IT
     272  HAL_TIM_Encoder_Stop
     340  HAL_TIM_Encoder_Stop_DMA
     316  HAL_TIM_Encoder_Stop_IT
       2  HAL_TIM_ErrorCallback
      46  HAL_TIM_GenerateEvent
       4  HAL_TIM_GetActiveChannel
      62  HAL_TIM_GetChannelState
       2  HAL_TIM_IC_CaptureCallback
       2  HAL_TIM_IC_CaptureHalfCpltCallback
     220  HAL_TIM_IC_ConfigChannel
     134  HAL_TIM_IC_DeInit
       6  HAL_TIM_IC_GetState
     100  HAL_TIM_IC_Init
       2  HAL_TIM_IC_MspDeInit
       2  HAL_TIM_IC_MspInit
     350  HAL_TIM_IC_Start
     680  HAL_TIM_IC_Start_DMA
     450  HAL_TIM_IC_Start_IT
     184  HAL_TIM_IC_Stop
     300  HAL_TIM_IC_Stop_DMA
     276  HAL_TIM_IC_Stop_IT
     396  HAL_TIM_IRQHandler
     128  HAL_TIM_OC_ConfigChannel
     134  HAL_TIM_OC_DeInit
       2  HAL_TIM_OC_DelayElapsedCallback
       6  HAL_TIM_OC_GetState
     100  HAL_TIM_OC_Init
       2  HAL_TIM_OC_MspDeInit
       2  HAL_TIM_OC_MspInit
     306  HAL_TIM_OC_Start
     674  HAL_TIM_OC_Start_DMA
     402  HAL_TIM_OC_Start_IT
     214  HAL_TIM_OC_Stop
     330  HAL_TIM_OC_Stop_DMA
     306  HAL_TIM_OC_Stop_IT
     300  HAL_TIM_OnePulse_ConfigChannel
     106  HAL_TIM_OnePulse_DeInit
       6  HAL_TIM_OnePulse_GetState
     116  HAL_TIM_OnePulse_Init
       2  HAL_TIM_OnePulse_MspDeInit
       2  HAL_TIM_OnePulse_MspInit
     180  HAL_TIM_OnePulse_Start
     204  HAL_TIM_OnePulse_Start_IT
     178  HAL_TIM_OnePulse_Stop
     202  HAL_TIM_OnePulse_Stop_IT
     356  HAL_TIM_PWM_ConfigChannel
     134  HAL_TIM_PWM_DeInit
       6  HAL_TIM_PWM_GetState
     100  HAL_TIM_PWM_Init
       2  HAL_TIM_PWM_MspDeInit
       2  HAL_TIM_PWM_MspInit
       2  HAL_TIM_PWM_PulseFinishedCallback
       2  HAL_TIM_PWM_PulseFinishedHalfCpltCallback
     306  HAL_TIM_PWM_Start
     674  HAL_TIM_PWM_Start_DMA
     402  HAL_TIM_PWM_Start_IT
     214  HAL_TIM_PWM_Stop
     330  HAL_TIM_PWM_Stop_DMA
     306  HAL_TIM_PWM_Stop_IT
       2  HAL_TIM_PeriodElapsedCallback
       2  HAL_TIM_PeriodElapsedHalfCpltCallback
      60  HAL_TIM_ReadCapturedValue
      94  HAL_TIM_SlaveConfigSynchro
      94  HAL_TIM_SlaveConfigSynchro_IT
       2  HAL_TIM_TriggerCallback
       2  HAL_TIM_TriggerHalfCpltCallback
     162  TIM_Base_SetConfig
      36  TIM_CCxChannelCmd
     150  TIM_DMACaptureCplt
      64  TIM_DMACaptureHalfCplt
     118  TIM_DMADelayPulseCplt
      64  TIM_DMADelayPulseHalfCplt
     102  TIM_DMAError
      28  TIM_DMAPeriodElapsedCplt
      14  TIM_DMAPeriodElapsedHalfCplt
      28  TIM_DMATriggerCplt
      14  TIM_DMATriggerHalfCplt
      22  TIM_ETR_SetConfig
      16  TIM_ITRx_SetConfig
     124  TIM_OC1_SetConfig
     116  TIM_OC2_SetConfig
     112  TIM_OC3_SetConfig
      86  TIM_OC4_SetConfig
      78  TIM_OC5_SetConfig
      82  TIM_OC6_SetConfig
     174  TIM_SlaveTimer_SetConfig
      36  TIM_TI1_ConfigInputStage
     100  TIM_TI1_SetConfig
      38  TIM_TI2_ConfigInputStage
      56  TIM_TI2_SetConfig
      54  TIM_TI3_SetConfig
      58  TIM_TI4_SetConfig

 
 18'314 bytes in section .text
 
 18'270 bytes of CODE memory (+ 44 bytes shared)

Errors: none
Warnings: none
