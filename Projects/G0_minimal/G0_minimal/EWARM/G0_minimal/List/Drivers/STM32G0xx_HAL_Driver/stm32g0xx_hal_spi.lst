###############################################################################
#
# IAR ANSI C/C++ Compiler V9.20.1.318/W64 for ARM         20/Aug/2025  15:41:48
# Copyright 1999-2021 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\Drivers\STM32G0xx_HAL_Driver\Src\stm32g0xx_hal_spi.c
#    Command line      =
#        -f
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM\G0_minimal\Obj\Drivers\STM32G0xx_HAL_Driver\stm32g0xx_hal_spi.o.rsp
#        (C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\Drivers\STM32G0xx_HAL_Driver\Src\stm32g0xx_hal_spi.c
#        -D USE_HAL_DRIVER -D STM32G0B1xx -lcN
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM\G0_minimal\List\Drivers\STM32G0xx_HAL_Driver
#        -o
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM\G0_minimal\Obj\Drivers\STM32G0xx_HAL_Driver
#        --debug --endian=little --cpu=Cortex-M0+ -e --fpu=None --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.0\arm\inc\c\DLib_Config_Full.h" -I
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM/../Core/Inc\ -I
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM/../ST67W6X/Target\
#        -I
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM/../ST67W6X/Drivers\
#        -I
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM/../Drivers/STM32G0xx_HAL_Driver/Inc\
#        -I
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM/../Drivers/STM32G0xx_HAL_Driver/Inc/Legacy\
#        -I
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM/../Drivers/CMSIS/Device/ST/STM32G0xx/Include\
#        -I
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM/../Drivers/CMSIS/Include\
#        -Ohz) --dependencies=n
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM\G0_minimal\Obj\Drivers\STM32G0xx_HAL_Driver\stm32g0xx_hal_spi.o.d
#    Locale            =  C
#    List file         =
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM\G0_minimal\List\Drivers\STM32G0xx_HAL_Driver\stm32g0xx_hal_spi.lst
#    Object file       =
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM\G0_minimal\Obj\Drivers\STM32G0xx_HAL_Driver\stm32g0xx_hal_spi.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\Drivers\STM32G0xx_HAL_Driver\Src\stm32g0xx_hal_spi.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32g0xx_hal_spi.c
      4            * @author  MCD Application Team
      5            * @brief   SPI HAL module driver.
      6            *          This file provides firmware functions to manage the following
      7            *          functionalities of the Serial Peripheral Interface (SPI) peripheral:
      8            *           + Initialization and de-initialization functions
      9            *           + IO operation functions
     10            *           + Peripheral Control functions
     11            *           + Peripheral State functions
     12            ******************************************************************************
     13            * @attention
     14            *
     15            * Copyright (c) 2018 STMicroelectronics.
     16            * All rights reserved.
     17            *
     18            * This software is licensed under terms that can be found in the LICENSE file
     19            * in the root directory of this software component.
     20            * If no LICENSE file comes with this software, it is provided AS-IS.
     21            *
     22            ******************************************************************************
     23            @verbatim
     24            ==============================================================================
     25                                  ##### How to use this driver #####
     26            ==============================================================================
     27              [..]
     28                The SPI HAL driver can be used as follows:
     29          
     30                (#) Declare a SPI_HandleTypeDef handle structure, for example:
     31                    SPI_HandleTypeDef  hspi;
     32          
     33                (#)Initialize the SPI low level resources by implementing the HAL_SPI_MspInit() API:
     34                    (##) Enable the SPIx interface clock
     35                    (##) SPI pins configuration
     36                        (+++) Enable the clock for the SPI GPIOs
     37                        (+++) Configure these SPI pins as alternate function push-pull
     38                    (##) NVIC configuration if you need to use interrupt process
     39                        (+++) Configure the SPIx interrupt priority
     40                        (+++) Enable the NVIC SPI IRQ handle
     41                    (##) DMA Configuration if you need to use DMA process
     42                        (+++) Declare a DMA_HandleTypeDef handle structure for the transmit or receive Stream/Channel
     43                        (+++) Enable the DMAx clock
     44                        (+++) Configure the DMA handle parameters
     45                        (+++) Configure the DMA Tx or Rx Stream/Channel
     46                        (+++) Associate the initialized hdma_tx(or _rx)  handle to the hspi DMA Tx or Rx handle
     47                        (+++) Configure the priority and enable the NVIC for the transfer complete interrupt on the DMA Tx or Rx Stream/Channel
     48          
     49                (#) Program the Mode, BidirectionalMode , Data size, Baudrate Prescaler, NSS
     50                    management, Clock polarity and phase, FirstBit and CRC configuration in the hspi Init structure.
     51          
     52                (#) Initialize the SPI registers by calling the HAL_SPI_Init() API:
     53                    (++) This API configures also the low level Hardware GPIO, CLOCK, CORTEX...etc)
     54                        by calling the customized HAL_SPI_MspInit() API.
     55               [..]
     56                 Circular mode restriction:
     57                (#) The DMA circular mode cannot be used when the SPI is configured in these modes:
     58                    (##) Master 2Lines RxOnly
     59                    (##) Master 1Line Rx
     60                (#) The CRC feature is not managed when the DMA circular mode is enabled
     61                (#) When the SPI DMA Pause/Stop features are used, we must use the following APIs
     62                    the HAL_SPI_DMAPause()/ HAL_SPI_DMAStop() only under the SPI callbacks
     63               [..]
     64                 Master Receive mode restriction:
     65                (#) In Master unidirectional receive-only mode (MSTR =1, BIDIMODE=0, RXONLY=1) or
     66                    bidirectional receive mode (MSTR=1, BIDIMODE=1, BIDIOE=0), to ensure that the SPI
     67                    does not initiate a new transfer the following procedure has to be respected:
     68                    (##) HAL_SPI_DeInit()
     69                    (##) HAL_SPI_Init()
     70               [..]
     71                 Callback registration:
     72          
     73                (#) The compilation flag USE_HAL_SPI_REGISTER_CALLBACKS when set to 1U
     74                    allows the user to configure dynamically the driver callbacks.
     75                    Use Functions HAL_SPI_RegisterCallback() to register an interrupt callback.
     76          
     77                    Function HAL_SPI_RegisterCallback() allows to register following callbacks:
     78                      (++) TxCpltCallback        : SPI Tx Completed callback
     79                      (++) RxCpltCallback        : SPI Rx Completed callback
     80                      (++) TxRxCpltCallback      : SPI TxRx Completed callback
     81                      (++) TxHalfCpltCallback    : SPI Tx Half Completed callback
     82                      (++) RxHalfCpltCallback    : SPI Rx Half Completed callback
     83                      (++) TxRxHalfCpltCallback  : SPI TxRx Half Completed callback
     84                      (++) ErrorCallback         : SPI Error callback
     85                      (++) AbortCpltCallback     : SPI Abort callback
     86                      (++) MspInitCallback       : SPI Msp Init callback
     87                      (++) MspDeInitCallback     : SPI Msp DeInit callback
     88                    This function takes as parameters the HAL peripheral handle, the Callback ID
     89                    and a pointer to the user callback function.
     90          
     91          
     92                (#) Use function HAL_SPI_UnRegisterCallback to reset a callback to the default
     93                    weak function.
     94                    HAL_SPI_UnRegisterCallback takes as parameters the HAL peripheral handle,
     95                    and the Callback ID.
     96                    This function allows to reset following callbacks:
     97                      (++) TxCpltCallback        : SPI Tx Completed callback
     98                      (++) RxCpltCallback        : SPI Rx Completed callback
     99                      (++) TxRxCpltCallback      : SPI TxRx Completed callback
    100                      (++) TxHalfCpltCallback    : SPI Tx Half Completed callback
    101                      (++) RxHalfCpltCallback    : SPI Rx Half Completed callback
    102                      (++) TxRxHalfCpltCallback  : SPI TxRx Half Completed callback
    103                      (++) ErrorCallback         : SPI Error callback
    104                      (++) AbortCpltCallback     : SPI Abort callback
    105                      (++) MspInitCallback       : SPI Msp Init callback
    106                      (++) MspDeInitCallback     : SPI Msp DeInit callback
    107          
    108                 [..]
    109                 By default, after the HAL_SPI_Init() and when the state is HAL_SPI_STATE_RESET
    110                 all callbacks are set to the corresponding weak functions:
    111                 examples HAL_SPI_MasterTxCpltCallback(), HAL_SPI_MasterRxCpltCallback().
    112                 Exception done for MspInit and MspDeInit functions that are
    113                 reset to the legacy weak functions in the HAL_SPI_Init()/ HAL_SPI_DeInit() only when
    114                 these callbacks are null (not registered beforehand).
    115                 If MspInit or MspDeInit are not null, the HAL_SPI_Init()/ HAL_SPI_DeInit()
    116                 keep and use the user MspInit/MspDeInit callbacks (registered beforehand) whatever the state.
    117          
    118                 [..]
    119                 Callbacks can be registered/unregistered in HAL_SPI_STATE_READY state only.
    120                 Exception done MspInit/MspDeInit functions that can be registered/unregistered
    121                 in HAL_SPI_STATE_READY or HAL_SPI_STATE_RESET state,
    122                 thus registered (user) MspInit/DeInit callbacks can be used during the Init/DeInit.
    123                 Then, the user first registers the MspInit/MspDeInit user callbacks
    124                 using HAL_SPI_RegisterCallback() before calling HAL_SPI_DeInit()
    125                 or HAL_SPI_Init() function.
    126          
    127                 [..]
    128                 When the compilation define USE_HAL_PPP_REGISTER_CALLBACKS is set to 0 or
    129                 not defined, the callback registering feature is not available
    130                 and weak (surcharged) callbacks are used.
    131          
    132               [..]
    133                 Using the HAL it is not possible to reach all supported SPI frequency with the different SPI Modes,
    134                 the following table resume the max SPI frequency reached with data size 8bits/16bits,
    135                   according to frequency of the APBx Peripheral Clock (fPCLK) used by the SPI instance.
    136          
    137            @endverbatim
    138          
    139            Additional table :
    140          
    141                 DataSize = SPI_DATASIZE_8BIT:
    142                 +----------------------------------------------------------------------------------------------+
    143                 |         |                | 2Lines Fullduplex   |     2Lines RxOnly    |         1Line        |
    144                 | Process | Transfer mode  |---------------------|----------------------|----------------------|
    145                 |         |                |  Master  |  Slave   |  Master   |  Slave   |  Master   |  Slave   |
    146                 |==============================================================================================|
    147                 |    T    |     Polling    | Fpclk/4  | Fpclk/8  |    NA     |    NA    |    NA     |   NA     |
    148                 |    X    |----------------|----------|----------|-----------|----------|-----------|----------|
    149                 |    /    |     Interrupt  | Fpclk/4  | Fpclk/16 |    NA     |    NA    |    NA     |   NA     |
    150                 |    R    |----------------|----------|----------|-----------|----------|-----------|----------|
    151                 |    X    |       DMA      | Fpclk/2  | Fpclk/2  |    NA     |    NA    |    NA     |   NA     |
    152                 |=========|================|==========|==========|===========|==========|===========|==========|
    153                 |         |     Polling    | Fpclk/4  | Fpclk/8  | Fpclk/16  | Fpclk/8  | Fpclk/8   | Fpclk/8  |
    154                 |         |----------------|----------|----------|-----------|----------|-----------|----------|
    155                 |    R    |     Interrupt  | Fpclk/8  | Fpclk/16 | Fpclk/8   | Fpclk/8  | Fpclk/8   | Fpclk/4  |
    156                 |    X    |----------------|----------|----------|-----------|----------|-----------|----------|
    157                 |         |       DMA      | Fpclk/4  | Fpclk/2  | Fpclk/2   | Fpclk/16 | Fpclk/2   | Fpclk/16 |
    158                 |=========|================|==========|==========|===========|==========|===========|==========|
    159                 |         |     Polling    | Fpclk/8  | Fpclk/2  |     NA    |    NA    | Fpclk/8   | Fpclk/8  |
    160                 |         |----------------|----------|----------|-----------|----------|-----------|----------|
    161                 |    T    |     Interrupt  | Fpclk/2  | Fpclk/4  |     NA    |    NA    | Fpclk/16  | Fpclk/8  |
    162                 |    X    |----------------|----------|----------|-----------|----------|-----------|----------|
    163                 |         |       DMA      | Fpclk/2  | Fpclk/2  |     NA    |    NA    | Fpclk/8   | Fpclk/16 |
    164                 +----------------------------------------------------------------------------------------------+
    165          
    166                 DataSize = SPI_DATASIZE_16BIT:
    167                 +----------------------------------------------------------------------------------------------+
    168                 |         |                | 2Lines Fullduplex   |     2Lines RxOnly    |         1Line        |
    169                 | Process | Transfer mode  |---------------------|----------------------|----------------------|
    170                 |         |                |  Master  |  Slave   |  Master   |  Slave   |  Master   |  Slave   |
    171                 |==============================================================================================|
    172                 |    T    |     Polling    | Fpclk/4  | Fpclk/8  |    NA     |    NA    |    NA     |   NA     |
    173                 |    X    |----------------|----------|----------|-----------|----------|-----------|----------|
    174                 |    /    |     Interrupt  | Fpclk/4  | Fpclk/16 |    NA     |    NA    |    NA     |   NA     |
    175                 |    R    |----------------|----------|----------|-----------|----------|-----------|----------|
    176                 |    X    |       DMA      | Fpclk/2  | Fpclk/2  |    NA     |    NA    |    NA     |   NA     |
    177                 |=========|================|==========|==========|===========|==========|===========|==========|
    178                 |         |     Polling    | Fpclk/4  | Fpclk/8  | Fpclk/16  | Fpclk/8  | Fpclk/8   | Fpclk/8  |
    179                 |         |----------------|----------|----------|-----------|----------|-----------|----------|
    180                 |    R    |     Interrupt  | Fpclk/8  | Fpclk/16 | Fpclk/8   | Fpclk/8  | Fpclk/8   | Fpclk/4  |
    181                 |    X    |----------------|----------|----------|-----------|----------|-----------|----------|
    182                 |         |       DMA      | Fpclk/4  | Fpclk/2  | Fpclk/2   | Fpclk/16 | Fpclk/2   | Fpclk/16 |
    183                 |=========|================|==========|==========|===========|==========|===========|==========|
    184                 |         |     Polling    | Fpclk/8  | Fpclk/2  |     NA    |    NA    | Fpclk/8   | Fpclk/8  |
    185                 |         |----------------|----------|----------|-----------|----------|-----------|----------|
    186                 |    T    |     Interrupt  | Fpclk/2  | Fpclk/4  |     NA    |    NA    | Fpclk/16  | Fpclk/8  |
    187                 |    X    |----------------|----------|----------|-----------|----------|-----------|----------|
    188                 |         |       DMA      | Fpclk/2  | Fpclk/2  |     NA    |    NA    | Fpclk/8   | Fpclk/16 |
    189                 +----------------------------------------------------------------------------------------------+
    190                 @note The max SPI frequency depend on SPI data size (4bits, 5bits,..., 8bits,...15bits, 16bits),
    191                       SPI mode(2 Lines fullduplex, 2 lines RxOnly, 1 line TX/RX) and Process mode (Polling, IT, DMA).
    192                 @note
    193                      (#) TX/RX processes are HAL_SPI_TransmitReceive(), HAL_SPI_TransmitReceive_IT() and HAL_SPI_TransmitReceive_DMA()
    194                      (#) RX processes are HAL_SPI_Receive(), HAL_SPI_Receive_IT() and HAL_SPI_Receive_DMA()
    195                      (#) TX processes are HAL_SPI_Transmit(), HAL_SPI_Transmit_IT() and HAL_SPI_Transmit_DMA()
    196          
    197            */
    198          
    199          /* Includes ------------------------------------------------------------------*/
    200          #include "stm32g0xx_hal.h"
    201          
    202          /** @addtogroup STM32G0xx_HAL_Driver
    203            * @{
    204            */
    205          
    206          /** @defgroup SPI SPI
    207            * @brief SPI HAL module driver
    208            * @{
    209            */
    210          #ifdef HAL_SPI_MODULE_ENABLED
    211          
    212          /* Private typedef -----------------------------------------------------------*/
    213          /* Private defines -----------------------------------------------------------*/
    214          /** @defgroup SPI_Private_Constants SPI Private Constants
    215            * @{
    216            */
    217          #define SPI_DEFAULT_TIMEOUT 100U
    218          /**
    219            * @}
    220            */
    221          
    222          /* Private macros ------------------------------------------------------------*/
    223          /* Private variables ---------------------------------------------------------*/
    224          /* Private function prototypes -----------------------------------------------*/
    225          /** @defgroup SPI_Private_Functions SPI Private Functions
    226            * @{
    227            */
    228          static void SPI_DMATransmitCplt(DMA_HandleTypeDef *hdma);
    229          static void SPI_DMAReceiveCplt(DMA_HandleTypeDef *hdma);
    230          static void SPI_DMATransmitReceiveCplt(DMA_HandleTypeDef *hdma);
    231          static void SPI_DMAHalfTransmitCplt(DMA_HandleTypeDef *hdma);
    232          static void SPI_DMAHalfReceiveCplt(DMA_HandleTypeDef *hdma);
    233          static void SPI_DMAHalfTransmitReceiveCplt(DMA_HandleTypeDef *hdma);
    234          static void SPI_DMAError(DMA_HandleTypeDef *hdma);
    235          static void SPI_DMAAbortOnError(DMA_HandleTypeDef *hdma);
    236          static void SPI_DMATxAbortCallback(DMA_HandleTypeDef *hdma);
    237          static void SPI_DMARxAbortCallback(DMA_HandleTypeDef *hdma);
    238          static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, FlagStatus State,
    239                                                                 uint32_t Timeout, uint32_t Tickstart);
    240          static HAL_StatusTypeDef SPI_WaitFifoStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Fifo, uint32_t State,
    241                                                                 uint32_t Timeout, uint32_t Tickstart);
    242          static void SPI_TxISR_8BIT(struct __SPI_HandleTypeDef *hspi);
    243          static void SPI_TxISR_16BIT(struct __SPI_HandleTypeDef *hspi);
    244          static void SPI_RxISR_8BIT(struct __SPI_HandleTypeDef *hspi);
    245          static void SPI_RxISR_16BIT(struct __SPI_HandleTypeDef *hspi);
    246          static void SPI_2linesRxISR_8BIT(struct __SPI_HandleTypeDef *hspi);
    247          static void SPI_2linesTxISR_8BIT(struct __SPI_HandleTypeDef *hspi);
    248          static void SPI_2linesTxISR_16BIT(struct __SPI_HandleTypeDef *hspi);
    249          static void SPI_2linesRxISR_16BIT(struct __SPI_HandleTypeDef *hspi);
    250          #if (USE_SPI_CRC != 0U)
    251          static void SPI_RxISR_8BITCRC(struct __SPI_HandleTypeDef *hspi);
    252          static void SPI_RxISR_16BITCRC(struct __SPI_HandleTypeDef *hspi);
    253          static void SPI_2linesRxISR_8BITCRC(struct __SPI_HandleTypeDef *hspi);
    254          static void SPI_2linesRxISR_16BITCRC(struct __SPI_HandleTypeDef *hspi);
    255          #endif /* USE_SPI_CRC */
    256          static void SPI_AbortRx_ISR(SPI_HandleTypeDef *hspi);
    257          static void SPI_AbortTx_ISR(SPI_HandleTypeDef *hspi);
    258          static void SPI_CloseRxTx_ISR(SPI_HandleTypeDef *hspi);
    259          static void SPI_CloseRx_ISR(SPI_HandleTypeDef *hspi);
    260          static void SPI_CloseTx_ISR(SPI_HandleTypeDef *hspi);
    261          static HAL_StatusTypeDef SPI_EndRxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart);
    262          static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart);
    263          /**
    264            * @}
    265            */
    266          
    267          /* Exported functions --------------------------------------------------------*/
    268          /** @defgroup SPI_Exported_Functions SPI Exported Functions
    269            * @{
    270            */
    271          
    272          /** @defgroup SPI_Exported_Functions_Group1 Initialization and de-initialization functions
    273            *  @brief    Initialization and Configuration functions
    274            *
    275          @verbatim
    276           ===============================================================================
    277                        ##### Initialization and de-initialization functions #####
    278           ===============================================================================
    279              [..]  This subsection provides a set of functions allowing to initialize and
    280                    de-initialize the SPIx peripheral:
    281          
    282                (+) User must implement HAL_SPI_MspInit() function in which he configures
    283                    all related peripherals resources (CLOCK, GPIO, DMA, IT and NVIC ).
    284          
    285                (+) Call the function HAL_SPI_Init() to configure the selected device with
    286                    the selected configuration:
    287                  (++) Mode
    288                  (++) Direction
    289                  (++) Data Size
    290                  (++) Clock Polarity and Phase
    291                  (++) NSS Management
    292                  (++) BaudRate Prescaler
    293                  (++) FirstBit
    294                  (++) TIMode
    295                  (++) CRC Calculation
    296                  (++) CRC Polynomial if CRC enabled
    297                  (++) CRC Length, used only with Data8 and Data16
    298                  (++) FIFO reception threshold
    299          
    300                (+) Call the function HAL_SPI_DeInit() to restore the default configuration
    301                    of the selected SPIx peripheral.
    302          
    303          @endverbatim
    304            * @{
    305            */
    306          
    307          /**
    308            * @brief  Initialize the SPI according to the specified parameters
    309            *         in the SPI_InitTypeDef and initialize the associated handle.
    310            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
    311            *               the configuration information for SPI module.
    312            * @retval HAL status
    313            */
    314          HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
    315          {
    316            uint32_t frxth;
    317          
    318            /* Check the SPI handle allocation */
    319            if (hspi == NULL)
    320            {
    321              return HAL_ERROR;
    322            }
    323          
    324            /* Check the parameters */
    325            assert_param(IS_SPI_ALL_INSTANCE(hspi->Instance));
    326            assert_param(IS_SPI_MODE(hspi->Init.Mode));
    327            assert_param(IS_SPI_DIRECTION(hspi->Init.Direction));
    328            assert_param(IS_SPI_DATASIZE(hspi->Init.DataSize));
    329            assert_param(IS_SPI_NSS(hspi->Init.NSS));
    330            assert_param(IS_SPI_NSSP(hspi->Init.NSSPMode));
    331            assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
    332            assert_param(IS_SPI_FIRST_BIT(hspi->Init.FirstBit));
    333            assert_param(IS_SPI_TIMODE(hspi->Init.TIMode));
    334            if (hspi->Init.TIMode == SPI_TIMODE_DISABLE)
    335            {
    336              assert_param(IS_SPI_CPOL(hspi->Init.CLKPolarity));
    337              assert_param(IS_SPI_CPHA(hspi->Init.CLKPhase));
    338          
    339              if (hspi->Init.Mode == SPI_MODE_MASTER)
    340              {
    341                assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
    342              }
    343              else
    344              {
    345                /* Baudrate prescaler not use in Motoraola Slave mode. force to default value */
    346                hspi->Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
    347              }
    348            }
    349            else
    350            {
    351              assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
    352          
    353              /* Force polarity and phase to TI protocaol requirements */
    354              hspi->Init.CLKPolarity = SPI_POLARITY_LOW;
    355              hspi->Init.CLKPhase    = SPI_PHASE_1EDGE;
    356            }
    357          #if (USE_SPI_CRC != 0U)
    358            assert_param(IS_SPI_CRC_CALCULATION(hspi->Init.CRCCalculation));
    359            if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
    360            {
    361              assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
    362              assert_param(IS_SPI_CRC_LENGTH(hspi->Init.CRCLength));
    363            }
    364          #else
    365            hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
    366          #endif /* USE_SPI_CRC */
    367          
    368            if (hspi->State == HAL_SPI_STATE_RESET)
    369            {
    370              /* Allocate lock resource and initialize it */
    371              hspi->Lock = HAL_UNLOCKED;
    372          
    373          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
    374              /* Init the SPI Callback settings */
    375              hspi->TxCpltCallback       = HAL_SPI_TxCpltCallback;       /* Legacy weak TxCpltCallback       */
    376              hspi->RxCpltCallback       = HAL_SPI_RxCpltCallback;       /* Legacy weak RxCpltCallback       */
    377              hspi->TxRxCpltCallback     = HAL_SPI_TxRxCpltCallback;     /* Legacy weak TxRxCpltCallback     */
    378              hspi->TxHalfCpltCallback   = HAL_SPI_TxHalfCpltCallback;   /* Legacy weak TxHalfCpltCallback   */
    379              hspi->RxHalfCpltCallback   = HAL_SPI_RxHalfCpltCallback;   /* Legacy weak RxHalfCpltCallback   */
    380              hspi->TxRxHalfCpltCallback = HAL_SPI_TxRxHalfCpltCallback; /* Legacy weak TxRxHalfCpltCallback */
    381              hspi->ErrorCallback        = HAL_SPI_ErrorCallback;        /* Legacy weak ErrorCallback        */
    382              hspi->AbortCpltCallback    = HAL_SPI_AbortCpltCallback;    /* Legacy weak AbortCpltCallback    */
    383          
    384              if (hspi->MspInitCallback == NULL)
    385              {
    386                hspi->MspInitCallback = HAL_SPI_MspInit; /* Legacy weak MspInit  */
    387              }
    388          
    389              /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    390              hspi->MspInitCallback(hspi);
    391          #else
    392              /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    393              HAL_SPI_MspInit(hspi);
    394          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
    395            }
    396          
    397            hspi->State = HAL_SPI_STATE_BUSY;
    398          
    399            /* Disable the selected SPI peripheral */
    400            __HAL_SPI_DISABLE(hspi);
    401          
    402            /* Align by default the rs fifo threshold on the data size */
    403            if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
    404            {
    405              frxth = SPI_RXFIFO_THRESHOLD_HF;
    406            }
    407            else
    408            {
    409              frxth = SPI_RXFIFO_THRESHOLD_QF;
    410            }
    411          
    412            /* CRC calculation is valid only for 16Bit and 8 Bit */
    413            if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
    414            {
    415              /* CRC must be disabled */
    416              hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
    417            }
    418          
    419            /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
    420            /* Configure : SPI Mode, Communication Mode, Clock polarity and phase, NSS management,
    421            Communication speed, First bit and CRC calculation state */
    422            WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
    423                                            (hspi->Init.Direction & (SPI_CR1_RXONLY | SPI_CR1_BIDIMODE)) |
    424                                            (hspi->Init.CLKPolarity & SPI_CR1_CPOL) |
    425                                            (hspi->Init.CLKPhase & SPI_CR1_CPHA) |
    426                                            (hspi->Init.NSS & SPI_CR1_SSM) |
    427                                            (hspi->Init.BaudRatePrescaler & SPI_CR1_BR_Msk) |
    428                                            (hspi->Init.FirstBit  & SPI_CR1_LSBFIRST) |
    429                                            (hspi->Init.CRCCalculation & SPI_CR1_CRCEN)));
    430          #if (USE_SPI_CRC != 0U)
    431            /*---------------------------- SPIx CRCL Configuration -------------------*/
    432            if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
    433            {
    434              /* Align the CRC Length on the data size */
    435              if (hspi->Init.CRCLength == SPI_CRC_LENGTH_DATASIZE)
    436              {
    437                /* CRC Length aligned on the data size : value set by default */
    438                if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
    439                {
    440                  hspi->Init.CRCLength = SPI_CRC_LENGTH_16BIT;
    441                }
    442                else
    443                {
    444                  hspi->Init.CRCLength = SPI_CRC_LENGTH_8BIT;
    445                }
    446              }
    447          
    448              /* Configure : CRC Length */
    449              if (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
    450              {
    451                SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCL);
    452              }
    453            }
    454          #endif /* USE_SPI_CRC */
    455          
    456            /* Configure : NSS management, TI Mode, NSS Pulse, Data size and Rx Fifo threshold */
    457            WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) |
    458                                            (hspi->Init.TIMode & SPI_CR2_FRF) |
    459                                            (hspi->Init.NSSPMode & SPI_CR2_NSSP) |
    460                                            (hspi->Init.DataSize & SPI_CR2_DS_Msk) |
    461                                            (frxth & SPI_CR2_FRXTH)));
    462          
    463          #if (USE_SPI_CRC != 0U)
    464            /*---------------------------- SPIx CRCPOLY Configuration ------------------*/
    465            /* Configure : CRC Polynomial */
    466            if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
    467            {
    468              WRITE_REG(hspi->Instance->CRCPR, (hspi->Init.CRCPolynomial & SPI_CRCPR_CRCPOLY_Msk));
    469            }
    470          #endif /* USE_SPI_CRC */
    471          
    472          #if defined(SPI_I2SCFGR_I2SMOD)
    473            /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
    474            CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
    475          #endif /* SPI_I2SCFGR_I2SMOD */
    476          
    477            hspi->ErrorCode = HAL_SPI_ERROR_NONE;
    478            hspi->State     = HAL_SPI_STATE_READY;
    479          
    480            return HAL_OK;
    481          }
    482          
    483          /**
    484            * @brief  De-Initialize the SPI peripheral.
    485            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
    486            *               the configuration information for SPI module.
    487            * @retval HAL status
    488            */
    489          HAL_StatusTypeDef HAL_SPI_DeInit(SPI_HandleTypeDef *hspi)
    490          {
    491            /* Check the SPI handle allocation */
    492            if (hspi == NULL)
    493            {
    494              return HAL_ERROR;
    495            }
    496          
    497            /* Check SPI Instance parameter */
    498            assert_param(IS_SPI_ALL_INSTANCE(hspi->Instance));
    499          
    500            hspi->State = HAL_SPI_STATE_BUSY;
    501          
    502            /* Disable the SPI Peripheral Clock */
    503            __HAL_SPI_DISABLE(hspi);
    504          
    505          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
    506            if (hspi->MspDeInitCallback == NULL)
    507            {
    508              hspi->MspDeInitCallback = HAL_SPI_MspDeInit; /* Legacy weak MspDeInit  */
    509            }
    510          
    511            /* DeInit the low level hardware: GPIO, CLOCK, NVIC... */
    512            hspi->MspDeInitCallback(hspi);
    513          #else
    514            /* DeInit the low level hardware: GPIO, CLOCK, NVIC... */
    515            HAL_SPI_MspDeInit(hspi);
    516          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
    517          
    518            hspi->ErrorCode = HAL_SPI_ERROR_NONE;
    519            hspi->State = HAL_SPI_STATE_RESET;
    520          
    521            /* Release Lock */
    522            __HAL_UNLOCK(hspi);
    523          
    524            return HAL_OK;
    525          }
    526          
    527          /**
    528            * @brief  Initialize the SPI MSP.
    529            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
    530            *               the configuration information for SPI module.
    531            * @retval None
    532            */
    533          __weak void HAL_SPI_MspInit(SPI_HandleTypeDef *hspi)
    534          {
    535            /* Prevent unused argument(s) compilation warning */
    536            UNUSED(hspi);
    537          
    538            /* NOTE : This function should not be modified, when the callback is needed,
    539                      the HAL_SPI_MspInit should be implemented in the user file
    540             */
    541          }
    542          
    543          /**
    544            * @brief  De-Initialize the SPI MSP.
    545            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
    546            *               the configuration information for SPI module.
    547            * @retval None
    548            */
    549          __weak void HAL_SPI_MspDeInit(SPI_HandleTypeDef *hspi)
    550          {
    551            /* Prevent unused argument(s) compilation warning */
    552            UNUSED(hspi);
    553          
    554            /* NOTE : This function should not be modified, when the callback is needed,
    555                      the HAL_SPI_MspDeInit should be implemented in the user file
    556             */
    557          }
    558          
    559          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
    560          /**
    561            * @brief  Register a User SPI Callback
    562            *         To be used instead of the weak predefined callback
    563            * @param  hspi Pointer to a SPI_HandleTypeDef structure that contains
    564            *                the configuration information for the specified SPI.
    565            * @param  CallbackID ID of the callback to be registered
    566            * @param  pCallback pointer to the Callback function
    567            * @retval HAL status
    568            */
    569          HAL_StatusTypeDef HAL_SPI_RegisterCallback(SPI_HandleTypeDef *hspi, HAL_SPI_CallbackIDTypeDef CallbackID,
    570                                                     pSPI_CallbackTypeDef pCallback)
    571          {
    572            HAL_StatusTypeDef status = HAL_OK;
    573          
    574            if (pCallback == NULL)
    575            {
    576              /* Update the error code */
    577              hspi->ErrorCode |= HAL_SPI_ERROR_INVALID_CALLBACK;
    578          
    579              return HAL_ERROR;
    580            }
    581            /* Process locked */
    582            __HAL_LOCK(hspi);
    583          
    584            if (HAL_SPI_STATE_READY == hspi->State)
    585            {
    586              switch (CallbackID)
    587              {
    588                case HAL_SPI_TX_COMPLETE_CB_ID :
    589                  hspi->TxCpltCallback = pCallback;
    590                  break;
    591          
    592                case HAL_SPI_RX_COMPLETE_CB_ID :
    593                  hspi->RxCpltCallback = pCallback;
    594                  break;
    595          
    596                case HAL_SPI_TX_RX_COMPLETE_CB_ID :
    597                  hspi->TxRxCpltCallback = pCallback;
    598                  break;
    599          
    600                case HAL_SPI_TX_HALF_COMPLETE_CB_ID :
    601                  hspi->TxHalfCpltCallback = pCallback;
    602                  break;
    603          
    604                case HAL_SPI_RX_HALF_COMPLETE_CB_ID :
    605                  hspi->RxHalfCpltCallback = pCallback;
    606                  break;
    607          
    608                case HAL_SPI_TX_RX_HALF_COMPLETE_CB_ID :
    609                  hspi->TxRxHalfCpltCallback = pCallback;
    610                  break;
    611          
    612                case HAL_SPI_ERROR_CB_ID :
    613                  hspi->ErrorCallback = pCallback;
    614                  break;
    615          
    616                case HAL_SPI_ABORT_CB_ID :
    617                  hspi->AbortCpltCallback = pCallback;
    618                  break;
    619          
    620                case HAL_SPI_MSPINIT_CB_ID :
    621                  hspi->MspInitCallback = pCallback;
    622                  break;
    623          
    624                case HAL_SPI_MSPDEINIT_CB_ID :
    625                  hspi->MspDeInitCallback = pCallback;
    626                  break;
    627          
    628                default :
    629                  /* Update the error code */
    630                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_INVALID_CALLBACK);
    631          
    632                  /* Return error status */
    633                  status =  HAL_ERROR;
    634                  break;
    635              }
    636            }
    637            else if (HAL_SPI_STATE_RESET == hspi->State)
    638            {
    639              switch (CallbackID)
    640              {
    641                case HAL_SPI_MSPINIT_CB_ID :
    642                  hspi->MspInitCallback = pCallback;
    643                  break;
    644          
    645                case HAL_SPI_MSPDEINIT_CB_ID :
    646                  hspi->MspDeInitCallback = pCallback;
    647                  break;
    648          
    649                default :
    650                  /* Update the error code */
    651                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_INVALID_CALLBACK);
    652          
    653                  /* Return error status */
    654                  status =  HAL_ERROR;
    655                  break;
    656              }
    657            }
    658            else
    659            {
    660              /* Update the error code */
    661              SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_INVALID_CALLBACK);
    662          
    663              /* Return error status */
    664              status =  HAL_ERROR;
    665            }
    666          
    667            /* Release Lock */
    668            __HAL_UNLOCK(hspi);
    669            return status;
    670          }
    671          
    672          /**
    673            * @brief  Unregister an SPI Callback
    674            *         SPI callback is redirected to the weak predefined callback
    675            * @param  hspi Pointer to a SPI_HandleTypeDef structure that contains
    676            *                the configuration information for the specified SPI.
    677            * @param  CallbackID ID of the callback to be unregistered
    678            * @retval HAL status
    679            */
    680          HAL_StatusTypeDef HAL_SPI_UnRegisterCallback(SPI_HandleTypeDef *hspi, HAL_SPI_CallbackIDTypeDef CallbackID)
    681          {
    682            HAL_StatusTypeDef status = HAL_OK;
    683          
    684            /* Process locked */
    685            __HAL_LOCK(hspi);
    686          
    687            if (HAL_SPI_STATE_READY == hspi->State)
    688            {
    689              switch (CallbackID)
    690              {
    691                case HAL_SPI_TX_COMPLETE_CB_ID :
    692                  hspi->TxCpltCallback = HAL_SPI_TxCpltCallback;             /* Legacy weak TxCpltCallback       */
    693                  break;
    694          
    695                case HAL_SPI_RX_COMPLETE_CB_ID :
    696                  hspi->RxCpltCallback = HAL_SPI_RxCpltCallback;             /* Legacy weak RxCpltCallback       */
    697                  break;
    698          
    699                case HAL_SPI_TX_RX_COMPLETE_CB_ID :
    700                  hspi->TxRxCpltCallback = HAL_SPI_TxRxCpltCallback;         /* Legacy weak TxRxCpltCallback     */
    701                  break;
    702          
    703                case HAL_SPI_TX_HALF_COMPLETE_CB_ID :
    704                  hspi->TxHalfCpltCallback = HAL_SPI_TxHalfCpltCallback;     /* Legacy weak TxHalfCpltCallback   */
    705                  break;
    706          
    707                case HAL_SPI_RX_HALF_COMPLETE_CB_ID :
    708                  hspi->RxHalfCpltCallback = HAL_SPI_RxHalfCpltCallback;     /* Legacy weak RxHalfCpltCallback   */
    709                  break;
    710          
    711                case HAL_SPI_TX_RX_HALF_COMPLETE_CB_ID :
    712                  hspi->TxRxHalfCpltCallback = HAL_SPI_TxRxHalfCpltCallback; /* Legacy weak TxRxHalfCpltCallback */
    713                  break;
    714          
    715                case HAL_SPI_ERROR_CB_ID :
    716                  hspi->ErrorCallback = HAL_SPI_ErrorCallback;               /* Legacy weak ErrorCallback        */
    717                  break;
    718          
    719                case HAL_SPI_ABORT_CB_ID :
    720                  hspi->AbortCpltCallback = HAL_SPI_AbortCpltCallback;       /* Legacy weak AbortCpltCallback    */
    721                  break;
    722          
    723                case HAL_SPI_MSPINIT_CB_ID :
    724                  hspi->MspInitCallback = HAL_SPI_MspInit;                   /* Legacy weak MspInit              */
    725                  break;
    726          
    727                case HAL_SPI_MSPDEINIT_CB_ID :
    728                  hspi->MspDeInitCallback = HAL_SPI_MspDeInit;               /* Legacy weak MspDeInit            */
    729                  break;
    730          
    731                default :
    732                  /* Update the error code */
    733                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_INVALID_CALLBACK);
    734          
    735                  /* Return error status */
    736                  status =  HAL_ERROR;
    737                  break;
    738              }
    739            }
    740            else if (HAL_SPI_STATE_RESET == hspi->State)
    741            {
    742              switch (CallbackID)
    743              {
    744                case HAL_SPI_MSPINIT_CB_ID :
    745                  hspi->MspInitCallback = HAL_SPI_MspInit;                   /* Legacy weak MspInit              */
    746                  break;
    747          
    748                case HAL_SPI_MSPDEINIT_CB_ID :
    749                  hspi->MspDeInitCallback = HAL_SPI_MspDeInit;               /* Legacy weak MspDeInit            */
    750                  break;
    751          
    752                default :
    753                  /* Update the error code */
    754                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_INVALID_CALLBACK);
    755          
    756                  /* Return error status */
    757                  status =  HAL_ERROR;
    758                  break;
    759              }
    760            }
    761            else
    762            {
    763              /* Update the error code */
    764              SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_INVALID_CALLBACK);
    765          
    766              /* Return error status */
    767              status =  HAL_ERROR;
    768            }
    769          
    770            /* Release Lock */
    771            __HAL_UNLOCK(hspi);
    772            return status;
    773          }
    774          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
    775          /**
    776            * @}
    777            */
    778          
    779          /** @defgroup SPI_Exported_Functions_Group2 IO operation functions
    780            *  @brief   Data transfers functions
    781            *
    782          @verbatim
    783            ==============================================================================
    784                                ##### IO operation functions #####
    785           ===============================================================================
    786           [..]
    787              This subsection provides a set of functions allowing to manage the SPI
    788              data transfers.
    789          
    790              [..] The SPI supports master and slave mode :
    791          
    792              (#) There are two modes of transfer:
    793                 (++) Blocking mode: The communication is performed in polling mode.
    794                      The HAL status of all data processing is returned by the same function
    795                      after finishing transfer.
    796                 (++) No-Blocking mode: The communication is performed using Interrupts
    797                      or DMA, These APIs return the HAL status.
    798                      The end of the data processing will be indicated through the
    799                      dedicated SPI IRQ when using Interrupt mode or the DMA IRQ when
    800                      using DMA mode.
    801                      The HAL_SPI_TxCpltCallback(), HAL_SPI_RxCpltCallback() and HAL_SPI_TxRxCpltCallback() user callbacks
    802                      will be executed respectively at the end of the transmit or Receive process
    803                      The HAL_SPI_ErrorCallback()user callback will be executed when a communication error is detected
    804          
    805              (#) APIs provided for these 2 transfer modes (Blocking mode or Non blocking mode using either Interrupt or DMA)
    806                  exist for 1Line (simplex) and 2Lines (full duplex) modes.
    807          
    808          @endverbatim
    809            * @{
    810            */
    811          
    812          /**
    813            * @brief  Transmit an amount of data in blocking mode.
    814            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
    815            *               the configuration information for SPI module.
    816            * @param  pData pointer to data buffer
    817            * @param  Size amount of data to be sent
    818            * @param  Timeout Timeout duration
    819            * @retval HAL status
    820            */
    821          HAL_StatusTypeDef HAL_SPI_Transmit(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    822          {
    823            uint32_t tickstart;
    824            HAL_StatusTypeDef errorcode = HAL_OK;
    825            uint16_t initial_TxXferCount;
    826          
    827            /* Check Direction parameter */
    828            assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));
    829          
    830            /* Process Locked */
    831            __HAL_LOCK(hspi);
    832          
    833            /* Init tickstart for timeout management*/
    834            tickstart = HAL_GetTick();
    835            initial_TxXferCount = Size;
    836          
    837            if (hspi->State != HAL_SPI_STATE_READY)
    838            {
    839              errorcode = HAL_BUSY;
    840              goto error;
    841            }
    842          
    843            if ((pData == NULL) || (Size == 0U))
    844            {
    845              errorcode = HAL_ERROR;
    846              goto error;
    847            }
    848          
    849            /* Set the transaction information */
    850            hspi->State       = HAL_SPI_STATE_BUSY_TX;
    851            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
    852            hspi->pTxBuffPtr  = (uint8_t *)pData;
    853            hspi->TxXferSize  = Size;
    854            hspi->TxXferCount = Size;
    855          
    856            /*Init field not used in handle to zero */
    857            hspi->pRxBuffPtr  = (uint8_t *)NULL;
    858            hspi->RxXferSize  = 0U;
    859            hspi->RxXferCount = 0U;
    860            hspi->TxISR       = NULL;
    861            hspi->RxISR       = NULL;
    862          
    863            /* Configure communication direction : 1Line */
    864            if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
    865            {
    866              /* Disable SPI Peripheral before set 1Line direction (BIDIOE bit) */
    867              __HAL_SPI_DISABLE(hspi);
    868              SPI_1LINE_TX(hspi);
    869            }
    870          
    871          #if (USE_SPI_CRC != 0U)
    872            /* Reset CRC Calculation */
    873            if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
    874            {
    875              SPI_RESET_CRC(hspi);
    876            }
    877          #endif /* USE_SPI_CRC */
    878          
    879            /* Check if the SPI is already enabled */
    880            if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
    881            {
    882              /* Enable SPI peripheral */
    883              __HAL_SPI_ENABLE(hspi);
    884            }
    885          
    886            /* Transmit data in 16 Bit mode */
    887            if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
    888            {
    889              if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
    890              {
    891                hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
    892                hspi->pTxBuffPtr += sizeof(uint16_t);
    893                hspi->TxXferCount--;
    894              }
    895              /* Transmit data in 16 Bit mode */
    896              while (hspi->TxXferCount > 0U)
    897              {
    898                /* Wait until TXE flag is set to send data */
    899                if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
    900                {
    901                  hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
    902                  hspi->pTxBuffPtr += sizeof(uint16_t);
    903                  hspi->TxXferCount--;
    904                }
    905                else
    906                {
    907                  /* Timeout management */
    908                  if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
    909                  {
    910                    errorcode = HAL_TIMEOUT;
    911                    hspi->State = HAL_SPI_STATE_READY;
    912                    goto error;
    913                  }
    914                }
    915              }
    916            }
    917            /* Transmit data in 8 Bit mode */
    918            else
    919            {
    920              if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
    921              {
    922                *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
    923                hspi->pTxBuffPtr += sizeof(uint8_t);
    924                hspi->TxXferCount--;
    925              }
    926              while (hspi->TxXferCount > 0U)
    927              {
    928                /* Wait until TXE flag is set to send data */
    929                if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
    930                {
    931                  *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
    932                  hspi->pTxBuffPtr += sizeof(uint8_t);
    933                  hspi->TxXferCount--;
    934                }
    935                else
    936                {
    937                  /* Timeout management */
    938                  if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
    939                  {
    940                    errorcode = HAL_TIMEOUT;
    941                    hspi->State = HAL_SPI_STATE_READY;
    942                    goto error;
    943                  }
    944                }
    945              }
    946            }
    947          #if (USE_SPI_CRC != 0U)
    948            /* Enable CRC Transmission */
    949            if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
    950            {
    951              SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
    952            }
    953          #endif /* USE_SPI_CRC */
    954          
    955            /* Check the end of the transaction */
    956            if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
    957            {
    958              hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
    959            }
    960          
    961            /* Clear overrun flag in 2 Lines communication mode because received is not read */
    962            if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
    963            {
    964              __HAL_SPI_CLEAR_OVRFLAG(hspi);
    965            }
    966          
    967            if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
    968            {
    969              errorcode = HAL_ERROR;
    970            }
    971            else
    972            {
    973              hspi->State = HAL_SPI_STATE_READY;
    974            }
    975          
    976          error:
    977            /* Process Unlocked */
    978            __HAL_UNLOCK(hspi);
    979            return errorcode;
    980          }
    981          
    982          /**
    983            * @brief  Receive an amount of data in blocking mode.
    984            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
    985            *               the configuration information for SPI module.
    986            * @param  pData pointer to data buffer
    987            * @param  Size amount of data to be received
    988            * @param  Timeout Timeout duration
    989            * @retval HAL status
    990            */
    991          HAL_StatusTypeDef HAL_SPI_Receive(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    992          {
    993          #if (USE_SPI_CRC != 0U)
    994            __IO uint32_t tmpreg = 0U;
    995            __IO uint8_t  *ptmpreg8;
    996            __IO uint8_t  tmpreg8 = 0;
    997          #endif /* USE_SPI_CRC */
    998            uint32_t tickstart;
    999            HAL_StatusTypeDef errorcode = HAL_OK;
   1000          
   1001            if (hspi->State != HAL_SPI_STATE_READY)
   1002            {
   1003              errorcode = HAL_BUSY;
   1004              goto error;
   1005            }
   1006          
   1007            if ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
   1008            {
   1009              hspi->State = HAL_SPI_STATE_BUSY_RX;
   1010              /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */
   1011              return HAL_SPI_TransmitReceive(hspi, pData, pData, Size, Timeout);
   1012            }
   1013          
   1014            /* Process Locked */
   1015            __HAL_LOCK(hspi);
   1016          
   1017            /* Init tickstart for timeout management*/
   1018            tickstart = HAL_GetTick();
   1019          
   1020            if ((pData == NULL) || (Size == 0U))
   1021            {
   1022              errorcode = HAL_ERROR;
   1023              goto error;
   1024            }
   1025          
   1026            /* Set the transaction information */
   1027            hspi->State       = HAL_SPI_STATE_BUSY_RX;
   1028            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   1029            hspi->pRxBuffPtr  = (uint8_t *)pData;
   1030            hspi->RxXferSize  = Size;
   1031            hspi->RxXferCount = Size;
   1032          
   1033            /*Init field not used in handle to zero */
   1034            hspi->pTxBuffPtr  = (uint8_t *)NULL;
   1035            hspi->TxXferSize  = 0U;
   1036            hspi->TxXferCount = 0U;
   1037            hspi->RxISR       = NULL;
   1038            hspi->TxISR       = NULL;
   1039          
   1040          #if (USE_SPI_CRC != 0U)
   1041            /* Reset CRC Calculation */
   1042            if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   1043            {
   1044              SPI_RESET_CRC(hspi);
   1045              /* this is done to handle the CRCNEXT before the latest data */
   1046              hspi->RxXferCount--;
   1047            }
   1048          #endif /* USE_SPI_CRC */
   1049          
   1050            /* Set the Rx Fifo threshold */
   1051            if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
   1052            {
   1053              /* Set RX Fifo threshold according the reception data length: 16bit */
   1054              CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   1055            }
   1056            else
   1057            {
   1058              /* Set RX Fifo threshold according the reception data length: 8bit */
   1059              SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   1060            }
   1061          
   1062            /* Configure communication direction: 1Line */
   1063            if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
   1064            {
   1065              /* Disable SPI Peripheral before set 1Line direction (BIDIOE bit) */
   1066              __HAL_SPI_DISABLE(hspi);
   1067              SPI_1LINE_RX(hspi);
   1068            }
   1069          
   1070            /* Check if the SPI is already enabled */
   1071            if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
   1072            {
   1073              /* Enable SPI peripheral */
   1074              __HAL_SPI_ENABLE(hspi);
   1075            }
   1076          
   1077            /* Receive data in 8 Bit mode */
   1078            if (hspi->Init.DataSize <= SPI_DATASIZE_8BIT)
   1079            {
   1080              /* Transfer loop */
   1081              while (hspi->RxXferCount > 0U)
   1082              {
   1083                /* Check the RXNE flag */
   1084                if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE))
   1085                {
   1086                  /* read the received data */
   1087                  (* (uint8_t *)hspi->pRxBuffPtr) = *(__IO uint8_t *)&hspi->Instance->DR;
   1088                  hspi->pRxBuffPtr += sizeof(uint8_t);
   1089                  hspi->RxXferCount--;
   1090                }
   1091                else
   1092                {
   1093                  /* Timeout management */
   1094                  if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
   1095                  {
   1096                    errorcode = HAL_TIMEOUT;
   1097                    hspi->State = HAL_SPI_STATE_READY;
   1098                    goto error;
   1099                  }
   1100                }
   1101              }
   1102            }
   1103            else
   1104            {
   1105              /* Transfer loop */
   1106              while (hspi->RxXferCount > 0U)
   1107              {
   1108                /* Check the RXNE flag */
   1109                if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE))
   1110                {
   1111                  *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
   1112                  hspi->pRxBuffPtr += sizeof(uint16_t);
   1113                  hspi->RxXferCount--;
   1114                }
   1115                else
   1116                {
   1117                  /* Timeout management */
   1118                  if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
   1119                  {
   1120                    errorcode = HAL_TIMEOUT;
   1121                    hspi->State = HAL_SPI_STATE_READY;
   1122                    goto error;
   1123                  }
   1124                }
   1125              }
   1126            }
   1127          
   1128          #if (USE_SPI_CRC != 0U)
   1129            /* Handle the CRC Transmission */
   1130            if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   1131            {
   1132              /* freeze the CRC before the latest data */
   1133              SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   1134          
   1135              /* Read the latest data */
   1136              if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
   1137              {
   1138                /* the latest data has not been received */
   1139                errorcode = HAL_TIMEOUT;
   1140                goto error;
   1141              }
   1142          
   1143              /* Receive last data in 16 Bit mode */
   1144              if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
   1145              {
   1146                *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
   1147              }
   1148              /* Receive last data in 8 Bit mode */
   1149              else
   1150              {
   1151                (*(uint8_t *)hspi->pRxBuffPtr) = *(__IO uint8_t *)&hspi->Instance->DR;
   1152              }
   1153          
   1154              /* Wait the CRC data */
   1155              if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
   1156              {
   1157                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   1158                errorcode = HAL_TIMEOUT;
   1159                goto error;
   1160              }
   1161          
   1162              /* Read CRC to Flush DR and RXNE flag */
   1163              if (hspi->Init.DataSize == SPI_DATASIZE_16BIT)
   1164              {
   1165                /* Read 16bit CRC */
   1166                tmpreg = READ_REG(hspi->Instance->DR);
   1167                /* To avoid GCC warning */
   1168                UNUSED(tmpreg);
   1169              }
   1170              else
   1171              {
   1172                /* Initialize the 8bit temporary pointer */
   1173                ptmpreg8 = (__IO uint8_t *)&hspi->Instance->DR;
   1174                /* Read 8bit CRC */
   1175                tmpreg8 = *ptmpreg8;
   1176                /* To avoid GCC warning */
   1177                UNUSED(tmpreg8);
   1178          
   1179                if ((hspi->Init.DataSize == SPI_DATASIZE_8BIT) && (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT))
   1180                {
   1181                  if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
   1182                  {
   1183                    /* Error on the CRC reception */
   1184                    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   1185                    errorcode = HAL_TIMEOUT;
   1186                    goto error;
   1187                  }
   1188                  /* Read 8bit CRC again in case of 16bit CRC in 8bit Data mode */
   1189                  tmpreg8 = *ptmpreg8;
   1190                  /* To avoid GCC warning */
   1191                  UNUSED(tmpreg8);
   1192                }
   1193              }
   1194            }
   1195          #endif /* USE_SPI_CRC */
   1196          
   1197            /* Check the end of the transaction */
   1198            if (SPI_EndRxTransaction(hspi, Timeout, tickstart) != HAL_OK)
   1199            {
   1200              hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
   1201            }
   1202          
   1203          #if (USE_SPI_CRC != 0U)
   1204            /* Check if CRC error occurred */
   1205            if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR))
   1206            {
   1207              SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   1208              __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
   1209            }
   1210          #endif /* USE_SPI_CRC */
   1211          
   1212            if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
   1213            {
   1214              errorcode = HAL_ERROR;
   1215            }
   1216            else
   1217            {
   1218              hspi->State = HAL_SPI_STATE_READY;
   1219            }
   1220          
   1221          error :
   1222            __HAL_UNLOCK(hspi);
   1223            return errorcode;
   1224          }
   1225          
   1226          /**
   1227            * @brief  Transmit and Receive an amount of data in blocking mode.
   1228            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   1229            *               the configuration information for SPI module.
   1230            * @param  pTxData pointer to transmission data buffer
   1231            * @param  pRxData pointer to reception data buffer
   1232            * @param  Size amount of data to be sent and received
   1233            * @param  Timeout Timeout duration
   1234            * @retval HAL status
   1235            */
   1236          HAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size,
   1237                                                    uint32_t Timeout)
   1238          {
   1239            uint16_t             initial_TxXferCount;
   1240            uint32_t             tmp_mode;
   1241            HAL_SPI_StateTypeDef tmp_state;
   1242            uint32_t             tickstart;
   1243          #if (USE_SPI_CRC != 0U)
   1244            __IO uint32_t tmpreg = 0U;
   1245            uint32_t             spi_cr1;
   1246            uint32_t             spi_cr2;
   1247            __IO uint8_t  *ptmpreg8;
   1248            __IO uint8_t  tmpreg8 = 0;
   1249          #endif /* USE_SPI_CRC */
   1250          
   1251            /* Variable used to alternate Rx and Tx during transfer */
   1252            uint32_t             txallowed = 1U;
   1253            HAL_StatusTypeDef    errorcode = HAL_OK;
   1254          
   1255            /* Check Direction parameter */
   1256            assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
   1257          
   1258            /* Process Locked */
   1259            __HAL_LOCK(hspi);
   1260          
   1261            /* Init tickstart for timeout management*/
   1262            tickstart = HAL_GetTick();
   1263          
   1264            /* Init temporary variables */
   1265            tmp_state           = hspi->State;
   1266            tmp_mode            = hspi->Init.Mode;
   1267            initial_TxXferCount = Size;
   1268          #if (USE_SPI_CRC != 0U)
   1269            spi_cr1             = READ_REG(hspi->Instance->CR1);
   1270            spi_cr2             = READ_REG(hspi->Instance->CR2);
   1271          #endif /* USE_SPI_CRC */
   1272          
   1273            if (!((tmp_state == HAL_SPI_STATE_READY) || \
   1274                  ((tmp_mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp_state == HAL_SPI_STATE_BUSY_RX))))
   1275            {
   1276              errorcode = HAL_BUSY;
   1277              goto error;
   1278            }
   1279          
   1280            if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
   1281            {
   1282              errorcode = HAL_ERROR;
   1283              goto error;
   1284            }
   1285          
   1286            /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
   1287            if (hspi->State != HAL_SPI_STATE_BUSY_RX)
   1288            {
   1289              hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
   1290            }
   1291          
   1292            /* Set the transaction information */
   1293            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   1294            hspi->pRxBuffPtr  = (uint8_t *)pRxData;
   1295            hspi->RxXferCount = Size;
   1296            hspi->RxXferSize  = Size;
   1297            hspi->pTxBuffPtr  = (uint8_t *)pTxData;
   1298            hspi->TxXferCount = Size;
   1299            hspi->TxXferSize  = Size;
   1300          
   1301            /*Init field not used in handle to zero */
   1302            hspi->RxISR       = NULL;
   1303            hspi->TxISR       = NULL;
   1304          
   1305          #if (USE_SPI_CRC != 0U)
   1306            /* Reset CRC Calculation */
   1307            if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   1308            {
   1309              SPI_RESET_CRC(hspi);
   1310            }
   1311          #endif /* USE_SPI_CRC */
   1312          
   1313            /* Set the Rx Fifo threshold */
   1314            if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
   1315            {
   1316              /* Set fiforxthreshold according the reception data length: 16bit */
   1317              CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   1318            }
   1319            else
   1320            {
   1321              /* Set fiforxthreshold according the reception data length: 8bit */
   1322              SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   1323            }
   1324          
   1325            /* Check if the SPI is already enabled */
   1326            if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
   1327            {
   1328              /* Enable SPI peripheral */
   1329              __HAL_SPI_ENABLE(hspi);
   1330            }
   1331          
   1332            /* Transmit and Receive data in 16 Bit mode */
   1333            if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
   1334            {
   1335              if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
   1336              {
   1337                hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
   1338                hspi->pTxBuffPtr += sizeof(uint16_t);
   1339                hspi->TxXferCount--;
   1340          
   1341          #if (USE_SPI_CRC != 0U)
   1342                /* Enable CRC Transmission */
   1343                if ((hspi->TxXferCount == 0U) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
   1344                {
   1345                  /* Set NSS Soft to received correctly the CRC on slave mode with NSS pulse activated */
   1346                  if ((READ_BIT(spi_cr1, SPI_CR1_MSTR) == 0U) && (READ_BIT(spi_cr2, SPI_CR2_NSSP) == SPI_CR2_NSSP))
   1347                  {
   1348                    SET_BIT(hspi->Instance->CR1, SPI_CR1_SSM);
   1349                  }
   1350                  SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   1351                }
   1352          #endif /* USE_SPI_CRC */
   1353          
   1354              }
   1355              while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
   1356              {
   1357                /* Check TXE flag */
   1358                if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
   1359                {
   1360                  hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
   1361                  hspi->pTxBuffPtr += sizeof(uint16_t);
   1362                  hspi->TxXferCount--;
   1363                  /* Next Data is a reception (Rx). Tx not allowed */
   1364                  txallowed = 0U;
   1365          
   1366          #if (USE_SPI_CRC != 0U)
   1367                  /* Enable CRC Transmission */
   1368                  if ((hspi->TxXferCount == 0U) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
   1369                  {
   1370                    /* Set NSS Soft to received correctly the CRC on slave mode with NSS pulse activated */
   1371                    if ((READ_BIT(spi_cr1, SPI_CR1_MSTR) == 0U) && (READ_BIT(spi_cr2, SPI_CR2_NSSP) == SPI_CR2_NSSP))
   1372                    {
   1373                      SET_BIT(hspi->Instance->CR1, SPI_CR1_SSM);
   1374                    }
   1375                    SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   1376                  }
   1377          #endif /* USE_SPI_CRC */
   1378                }
   1379          
   1380                /* Check RXNE flag */
   1381                if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
   1382                {
   1383                  *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
   1384                  hspi->pRxBuffPtr += sizeof(uint16_t);
   1385                  hspi->RxXferCount--;
   1386                  /* Next Data is a Transmission (Tx). Tx is allowed */
   1387                  txallowed = 1U;
   1388                }
   1389                if (((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY))
   1390                {
   1391                  errorcode = HAL_TIMEOUT;
   1392                  hspi->State = HAL_SPI_STATE_READY;
   1393                  goto error;
   1394                }
   1395              }
   1396            }
   1397            /* Transmit and Receive data in 8 Bit mode */
   1398            else
   1399            {
   1400              if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
   1401              {
   1402                *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
   1403                hspi->pTxBuffPtr += sizeof(uint8_t);
   1404                hspi->TxXferCount--;
   1405          
   1406          #if (USE_SPI_CRC != 0U)
   1407                /* Enable CRC Transmission */
   1408                if ((hspi->TxXferCount == 0U) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
   1409                {
   1410                  /* Set NSS Soft to received correctly the CRC on slave mode with NSS pulse activated */
   1411                  if ((READ_BIT(spi_cr1, SPI_CR1_MSTR) == 0U) && (READ_BIT(spi_cr2, SPI_CR2_NSSP) == SPI_CR2_NSSP))
   1412                  {
   1413                    SET_BIT(hspi->Instance->CR1, SPI_CR1_SSM);
   1414                  }
   1415                  SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   1416                }
   1417          #endif /* USE_SPI_CRC */
   1418              }
   1419              while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
   1420              {
   1421                /* Check TXE flag */
   1422                if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
   1423                {
   1424                  *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
   1425                  hspi->pTxBuffPtr++;
   1426                  hspi->TxXferCount--;
   1427                  /* Next Data is a reception (Rx). Tx not allowed */
   1428                  txallowed = 0U;
   1429          
   1430          #if (USE_SPI_CRC != 0U)
   1431                  /* Enable CRC Transmission */
   1432                  if ((hspi->TxXferCount == 0U) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
   1433                  {
   1434                    /* Set NSS Soft to received correctly the CRC on slave mode with NSS pulse activated */
   1435                    if ((READ_BIT(spi_cr1, SPI_CR1_MSTR) == 0U) && (READ_BIT(spi_cr2, SPI_CR2_NSSP) == SPI_CR2_NSSP))
   1436                    {
   1437                      SET_BIT(hspi->Instance->CR1, SPI_CR1_SSM);
   1438                    }
   1439                    SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   1440                  }
   1441          #endif /* USE_SPI_CRC */
   1442                }
   1443          
   1444                /* Wait until RXNE flag is reset */
   1445                if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
   1446                {
   1447                  (*(uint8_t *)hspi->pRxBuffPtr) = *(__IO uint8_t *)&hspi->Instance->DR;
   1448                  hspi->pRxBuffPtr++;
   1449                  hspi->RxXferCount--;
   1450                  /* Next Data is a Transmission (Tx). Tx is allowed */
   1451                  txallowed = 1U;
   1452                }
   1453                if ((((HAL_GetTick() - tickstart) >=  Timeout) && ((Timeout != HAL_MAX_DELAY))) || (Timeout == 0U))
   1454                {
   1455                  errorcode = HAL_TIMEOUT;
   1456                  hspi->State = HAL_SPI_STATE_READY;
   1457                  goto error;
   1458                }
   1459              }
   1460            }
   1461          
   1462          #if (USE_SPI_CRC != 0U)
   1463            /* Read CRC from DR to close CRC calculation process */
   1464            if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   1465            {
   1466              /* Wait until TXE flag */
   1467              if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
   1468              {
   1469                /* Error on the CRC reception */
   1470                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   1471                errorcode = HAL_TIMEOUT;
   1472                goto error;
   1473              }
   1474              /* Read CRC */
   1475              if (hspi->Init.DataSize == SPI_DATASIZE_16BIT)
   1476              {
   1477                /* Read 16bit CRC */
   1478                tmpreg = READ_REG(hspi->Instance->DR);
   1479                /* To avoid GCC warning */
   1480                UNUSED(tmpreg);
   1481              }
   1482              else
   1483              {
   1484                /* Initialize the 8bit temporary pointer */
   1485                ptmpreg8 = (__IO uint8_t *)&hspi->Instance->DR;
   1486                /* Read 8bit CRC */
   1487                tmpreg8 = *ptmpreg8;
   1488                /* To avoid GCC warning */
   1489                UNUSED(tmpreg8);
   1490          
   1491                if (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
   1492                {
   1493                  if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
   1494                  {
   1495                    /* Error on the CRC reception */
   1496                    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   1497                    errorcode = HAL_TIMEOUT;
   1498                    goto error;
   1499                  }
   1500                  /* Read 8bit CRC again in case of 16bit CRC in 8bit Data mode */
   1501                  tmpreg8 = *ptmpreg8;
   1502                  /* To avoid GCC warning */
   1503                  UNUSED(tmpreg8);
   1504                }
   1505              }
   1506            }
   1507          
   1508            /* Check if CRC error occurred */
   1509            if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR))
   1510            {
   1511              SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   1512              /* Clear CRC Flag */
   1513              __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
   1514          
   1515              errorcode = HAL_ERROR;
   1516            }
   1517          #endif /* USE_SPI_CRC */
   1518          
   1519            /* Check the end of the transaction */
   1520            if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
   1521            {
   1522              errorcode = HAL_ERROR;
   1523              hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
   1524            }
   1525          
   1526            if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
   1527            {
   1528              errorcode = HAL_ERROR;
   1529            }
   1530            else
   1531            {
   1532              hspi->State = HAL_SPI_STATE_READY;
   1533            }
   1534            
   1535          error :
   1536            __HAL_UNLOCK(hspi);
   1537            return errorcode;
   1538          }
   1539          
   1540          /**
   1541            * @brief  Transmit an amount of data in non-blocking mode with Interrupt.
   1542            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   1543            *               the configuration information for SPI module.
   1544            * @param  pData pointer to data buffer
   1545            * @param  Size amount of data to be sent
   1546            * @retval HAL status
   1547            */
   1548          HAL_StatusTypeDef HAL_SPI_Transmit_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
   1549          {
   1550            HAL_StatusTypeDef errorcode = HAL_OK;
   1551          
   1552            /* Check Direction parameter */
   1553            assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));
   1554          
   1555          
   1556            if ((pData == NULL) || (Size == 0U))
   1557            {
   1558              errorcode = HAL_ERROR;
   1559              goto error;
   1560            }
   1561          
   1562            if (hspi->State != HAL_SPI_STATE_READY)
   1563            {
   1564              errorcode = HAL_BUSY;
   1565              goto error;
   1566            }
   1567          
   1568            /* Process Locked */
   1569            __HAL_LOCK(hspi);
   1570          
   1571            /* Set the transaction information */
   1572            hspi->State       = HAL_SPI_STATE_BUSY_TX;
   1573            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   1574            hspi->pTxBuffPtr  = (uint8_t *)pData;
   1575            hspi->TxXferSize  = Size;
   1576            hspi->TxXferCount = Size;
   1577          
   1578            /* Init field not used in handle to zero */
   1579            hspi->pRxBuffPtr  = (uint8_t *)NULL;
   1580            hspi->RxXferSize  = 0U;
   1581            hspi->RxXferCount = 0U;
   1582            hspi->RxISR       = NULL;
   1583          
   1584            /* Set the function for IT treatment */
   1585            if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
   1586            {
   1587              hspi->TxISR = SPI_TxISR_16BIT;
   1588            }
   1589            else
   1590            {
   1591              hspi->TxISR = SPI_TxISR_8BIT;
   1592            }
   1593          
   1594            /* Configure communication direction : 1Line */
   1595            if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
   1596            {
   1597              /* Disable SPI Peripheral before set 1Line direction (BIDIOE bit) */
   1598              __HAL_SPI_DISABLE(hspi);
   1599              SPI_1LINE_TX(hspi);
   1600            }
   1601          
   1602          #if (USE_SPI_CRC != 0U)
   1603            /* Reset CRC Calculation */
   1604            if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   1605            {
   1606              SPI_RESET_CRC(hspi);
   1607            }
   1608          #endif /* USE_SPI_CRC */
   1609          
   1610            /* Check if the SPI is already enabled */
   1611            if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
   1612            {
   1613              /* Enable SPI peripheral */
   1614              __HAL_SPI_ENABLE(hspi);
   1615            }
   1616          
   1617            /* Process Unlocked */
   1618            __HAL_UNLOCK(hspi);
   1619            /* Enable TXE and ERR interrupt */
   1620            __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_ERR));
   1621          
   1622          error :
   1623            return errorcode;
   1624          }
   1625          
   1626          /**
   1627            * @brief  Receive an amount of data in non-blocking mode with Interrupt.
   1628            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   1629            *               the configuration information for SPI module.
   1630            * @param  pData pointer to data buffer
   1631            * @param  Size amount of data to be sent
   1632            * @retval HAL status
   1633            */
   1634          HAL_StatusTypeDef HAL_SPI_Receive_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
   1635          {
   1636            HAL_StatusTypeDef errorcode = HAL_OK;
   1637          
   1638          
   1639            if (hspi->State != HAL_SPI_STATE_READY)
   1640            {
   1641              errorcode = HAL_BUSY;
   1642              goto error;
   1643            }
   1644          
   1645            if ((hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->Init.Mode == SPI_MODE_MASTER))
   1646            {
   1647              hspi->State = HAL_SPI_STATE_BUSY_RX;
   1648              /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */
   1649              return HAL_SPI_TransmitReceive_IT(hspi, pData, pData, Size);
   1650            }
   1651          
   1652          
   1653            if ((pData == NULL) || (Size == 0U))
   1654            {
   1655              errorcode = HAL_ERROR;
   1656              goto error;
   1657            }
   1658          
   1659            /* Process Locked */
   1660            __HAL_LOCK(hspi);
   1661          
   1662            /* Set the transaction information */
   1663            hspi->State       = HAL_SPI_STATE_BUSY_RX;
   1664            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   1665            hspi->pRxBuffPtr  = (uint8_t *)pData;
   1666            hspi->RxXferSize  = Size;
   1667            hspi->RxXferCount = Size;
   1668          
   1669            /* Init field not used in handle to zero */
   1670            hspi->pTxBuffPtr  = (uint8_t *)NULL;
   1671            hspi->TxXferSize  = 0U;
   1672            hspi->TxXferCount = 0U;
   1673            hspi->TxISR       = NULL;
   1674          
   1675            /* Check the data size to adapt Rx threshold and the set the function for IT treatment */
   1676            if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
   1677            {
   1678              /* Set RX Fifo threshold according the reception data length: 16 bit */
   1679              CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   1680              hspi->RxISR = SPI_RxISR_16BIT;
   1681            }
   1682            else
   1683            {
   1684              /* Set RX Fifo threshold according the reception data length: 8 bit */
   1685              SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   1686              hspi->RxISR = SPI_RxISR_8BIT;
   1687            }
   1688          
   1689            /* Configure communication direction : 1Line */
   1690            if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
   1691            {
   1692              /* Disable SPI Peripheral before set 1Line direction (BIDIOE bit) */
   1693              __HAL_SPI_DISABLE(hspi);
   1694              SPI_1LINE_RX(hspi);
   1695            }
   1696          
   1697          #if (USE_SPI_CRC != 0U)
   1698            /* Reset CRC Calculation */
   1699            if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   1700            {
   1701              hspi->CRCSize = 1U;
   1702              if ((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT))
   1703              {
   1704                hspi->CRCSize = 2U;
   1705              }
   1706              SPI_RESET_CRC(hspi);
   1707            }
   1708            else
   1709            {
   1710              hspi->CRCSize = 0U;
   1711            }
   1712          #endif /* USE_SPI_CRC */
   1713          
   1714            /* Note : The SPI must be enabled after unlocking current process
   1715                      to avoid the risk of SPI interrupt handle execution before current
   1716                      process unlock */
   1717          
   1718            /* Check if the SPI is already enabled */
   1719            if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
   1720            {
   1721              /* Enable SPI peripheral */
   1722              __HAL_SPI_ENABLE(hspi);
   1723            }
   1724          
   1725            /* Process Unlocked */
   1726            __HAL_UNLOCK(hspi);
   1727            /* Enable RXNE and ERR interrupt */
   1728            __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
   1729          
   1730          error :
   1731            return errorcode;
   1732          }
   1733          
   1734          /**
   1735            * @brief  Transmit and Receive an amount of data in non-blocking mode with Interrupt.
   1736            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   1737            *               the configuration information for SPI module.
   1738            * @param  pTxData pointer to transmission data buffer
   1739            * @param  pRxData pointer to reception data buffer
   1740            * @param  Size amount of data to be sent and received
   1741            * @retval HAL status
   1742            */
   1743          HAL_StatusTypeDef HAL_SPI_TransmitReceive_IT(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size)
   1744          {
   1745            uint32_t             tmp_mode;
   1746            HAL_SPI_StateTypeDef tmp_state;
   1747            HAL_StatusTypeDef    errorcode = HAL_OK;
   1748          
   1749            /* Check Direction parameter */
   1750            assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
   1751          
   1752            /* Init temporary variables */
   1753            tmp_state           = hspi->State;
   1754            tmp_mode            = hspi->Init.Mode;
   1755          
   1756            if (!((tmp_state == HAL_SPI_STATE_READY) || \
   1757                  ((tmp_mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp_state == HAL_SPI_STATE_BUSY_RX))))
   1758            {
   1759              errorcode = HAL_BUSY;
   1760              goto error;
   1761            }
   1762          
   1763            if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
   1764            {
   1765              errorcode = HAL_ERROR;
   1766              goto error;
   1767            }
   1768          
   1769            /* Process locked */
   1770            __HAL_LOCK(hspi);
   1771          
   1772            /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
   1773            if (hspi->State != HAL_SPI_STATE_BUSY_RX)
   1774            {
   1775              hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
   1776            }
   1777          
   1778            /* Set the transaction information */
   1779            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   1780            hspi->pTxBuffPtr  = (uint8_t *)pTxData;
   1781            hspi->TxXferSize  = Size;
   1782            hspi->TxXferCount = Size;
   1783            hspi->pRxBuffPtr  = (uint8_t *)pRxData;
   1784            hspi->RxXferSize  = Size;
   1785            hspi->RxXferCount = Size;
   1786          
   1787            /* Set the function for IT treatment */
   1788            if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
   1789            {
   1790              hspi->RxISR     = SPI_2linesRxISR_16BIT;
   1791              hspi->TxISR     = SPI_2linesTxISR_16BIT;
   1792            }
   1793            else
   1794            {
   1795              hspi->RxISR     = SPI_2linesRxISR_8BIT;
   1796              hspi->TxISR     = SPI_2linesTxISR_8BIT;
   1797            }
   1798          
   1799          #if (USE_SPI_CRC != 0U)
   1800            /* Reset CRC Calculation */
   1801            if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   1802            {
   1803              hspi->CRCSize = 1U;
   1804              if ((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT))
   1805              {
   1806                hspi->CRCSize = 2U;
   1807              }
   1808              SPI_RESET_CRC(hspi);
   1809            }
   1810            else
   1811            {
   1812              hspi->CRCSize = 0U;
   1813            }
   1814          #endif /* USE_SPI_CRC */
   1815          
   1816            /* Check if packing mode is enabled and if there is more than 2 data to receive */
   1817            if ((hspi->Init.DataSize > SPI_DATASIZE_8BIT) || (Size >= 2U))
   1818            {
   1819              /* Set RX Fifo threshold according the reception data length: 16 bit */
   1820              CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   1821            }
   1822            else
   1823            {
   1824              /* Set RX Fifo threshold according the reception data length: 8 bit */
   1825              SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   1826            }
   1827          
   1828          
   1829            /* Check if the SPI is already enabled */
   1830            if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
   1831            {
   1832              /* Enable SPI peripheral */
   1833              __HAL_SPI_ENABLE(hspi);
   1834            }
   1835          
   1836            /* Process Unlocked */
   1837            __HAL_UNLOCK(hspi);
   1838            /* Enable TXE, RXNE and ERR interrupt */
   1839            __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
   1840          
   1841          error :
   1842            return errorcode;
   1843          }
   1844          
   1845          /**
   1846            * @brief  Transmit an amount of data in non-blocking mode with DMA.
   1847            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   1848            *               the configuration information for SPI module.
   1849            * @param  pData pointer to data buffer
   1850            * @param  Size amount of data to be sent
   1851            * @retval HAL status
   1852            */
   1853          HAL_StatusTypeDef HAL_SPI_Transmit_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
   1854          {
   1855            HAL_StatusTypeDef errorcode = HAL_OK;
   1856          
   1857            /* Check tx dma handle */
   1858            assert_param(IS_SPI_DMA_HANDLE(hspi->hdmatx));
   1859          
   1860            /* Check Direction parameter */
   1861            assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));
   1862          
   1863            /* Process Locked */
   1864            __HAL_LOCK(hspi);
   1865          
   1866            if (hspi->State != HAL_SPI_STATE_READY)
   1867            {
   1868              errorcode = HAL_BUSY;
   1869              goto error;
   1870            }
   1871          
   1872            if ((pData == NULL) || (Size == 0U))
   1873            {
   1874              errorcode = HAL_ERROR;
   1875              goto error;
   1876            }
   1877          
   1878            /* Set the transaction information */
   1879            hspi->State       = HAL_SPI_STATE_BUSY_TX;
   1880            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   1881            hspi->pTxBuffPtr  = (uint8_t *)pData;
   1882            hspi->TxXferSize  = Size;
   1883            hspi->TxXferCount = Size;
   1884          
   1885            /* Init field not used in handle to zero */
   1886            hspi->pRxBuffPtr  = (uint8_t *)NULL;
   1887            hspi->TxISR       = NULL;
   1888            hspi->RxISR       = NULL;
   1889            hspi->RxXferSize  = 0U;
   1890            hspi->RxXferCount = 0U;
   1891          
   1892            /* Configure communication direction : 1Line */
   1893            if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
   1894            {
   1895              /* Disable SPI Peripheral before set 1Line direction (BIDIOE bit) */
   1896              __HAL_SPI_DISABLE(hspi);
   1897              SPI_1LINE_TX(hspi);
   1898            }
   1899          
   1900          #if (USE_SPI_CRC != 0U)
   1901            /* Reset CRC Calculation */
   1902            if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   1903            {
   1904              SPI_RESET_CRC(hspi);
   1905            }
   1906          #endif /* USE_SPI_CRC */
   1907          
   1908            /* Set the SPI TxDMA Half transfer complete callback */
   1909            hspi->hdmatx->XferHalfCpltCallback = SPI_DMAHalfTransmitCplt;
   1910          
   1911            /* Set the SPI TxDMA transfer complete callback */
   1912            hspi->hdmatx->XferCpltCallback = SPI_DMATransmitCplt;
   1913          
   1914            /* Set the DMA error callback */
   1915            hspi->hdmatx->XferErrorCallback = SPI_DMAError;
   1916          
   1917            /* Set the DMA AbortCpltCallback */
   1918            hspi->hdmatx->XferAbortCallback = NULL;
   1919          
   1920            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
   1921            /* Packing mode is enabled only if the DMA setting is HALWORD */
   1922            if ((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD))
   1923            {
   1924              /* Check the even/odd of the data size + crc if enabled */
   1925              if ((hspi->TxXferCount & 0x1U) == 0U)
   1926              {
   1927                CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
   1928                hspi->TxXferCount = (hspi->TxXferCount >> 1U);
   1929              }
   1930              else
   1931              {
   1932                SET_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
   1933                hspi->TxXferCount = (hspi->TxXferCount >> 1U) + 1U;
   1934              }
   1935            }
   1936          
   1937            /* Enable the Tx DMA Stream/Channel */
   1938            if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR,
   1939                                           hspi->TxXferCount))
   1940            {
   1941              /* Update SPI error code */
   1942              SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
   1943              errorcode = HAL_ERROR;
   1944          
   1945              goto error;
   1946            }
   1947          
   1948            /* Check if the SPI is already enabled */
   1949            if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
   1950            {
   1951              /* Enable SPI peripheral */
   1952              __HAL_SPI_ENABLE(hspi);
   1953            }
   1954          
   1955            /* Enable the SPI Error Interrupt Bit */
   1956            __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
   1957          
   1958            /* Enable Tx DMA Request */
   1959            SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
   1960          
   1961          error :
   1962            /* Process Unlocked */
   1963            __HAL_UNLOCK(hspi);
   1964            return errorcode;
   1965          }
   1966          
   1967          /**
   1968            * @brief  Receive an amount of data in non-blocking mode with DMA.
   1969            * @note   In case of MASTER mode and SPI_DIRECTION_2LINES direction, hdmatx shall be defined.
   1970            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   1971            *               the configuration information for SPI module.
   1972            * @param  pData pointer to data buffer
   1973            * @note   When the CRC feature is enabled the pData Length must be Size + 1.
   1974            * @param  Size amount of data to be sent
   1975            * @retval HAL status
   1976            */
   1977          HAL_StatusTypeDef HAL_SPI_Receive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
   1978          {
   1979            HAL_StatusTypeDef errorcode = HAL_OK;
   1980          
   1981            /* Check rx dma handle */
   1982            assert_param(IS_SPI_DMA_HANDLE(hspi->hdmarx));
   1983          
   1984            if (hspi->State != HAL_SPI_STATE_READY)
   1985            {
   1986              errorcode = HAL_BUSY;
   1987              goto error;
   1988            }
   1989          
   1990            if ((hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->Init.Mode == SPI_MODE_MASTER))
   1991            {
   1992              hspi->State = HAL_SPI_STATE_BUSY_RX;
   1993          
   1994              /* Check tx dma handle */
   1995              assert_param(IS_SPI_DMA_HANDLE(hspi->hdmatx));
   1996          
   1997              /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */
   1998              return HAL_SPI_TransmitReceive_DMA(hspi, pData, pData, Size);
   1999            }
   2000          
   2001            /* Process Locked */
   2002            __HAL_LOCK(hspi);
   2003          
   2004            if ((pData == NULL) || (Size == 0U))
   2005            {
   2006              errorcode = HAL_ERROR;
   2007              goto error;
   2008            }
   2009          
   2010            /* Set the transaction information */
   2011            hspi->State       = HAL_SPI_STATE_BUSY_RX;
   2012            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   2013            hspi->pRxBuffPtr  = (uint8_t *)pData;
   2014            hspi->RxXferSize  = Size;
   2015            hspi->RxXferCount = Size;
   2016          
   2017            /*Init field not used in handle to zero */
   2018            hspi->RxISR       = NULL;
   2019            hspi->TxISR       = NULL;
   2020            hspi->TxXferSize  = 0U;
   2021            hspi->TxXferCount = 0U;
   2022          
   2023            /* Configure communication direction : 1Line */
   2024            if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
   2025            {
   2026              /* Disable SPI Peripheral before set 1Line direction (BIDIOE bit) */
   2027              __HAL_SPI_DISABLE(hspi);
   2028              SPI_1LINE_RX(hspi);
   2029            }
   2030          
   2031          #if (USE_SPI_CRC != 0U)
   2032            /* Reset CRC Calculation */
   2033            if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   2034            {
   2035              SPI_RESET_CRC(hspi);
   2036            }
   2037          #endif /* USE_SPI_CRC */
   2038          
   2039          
   2040            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
   2041            if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
   2042            {
   2043              /* Set RX Fifo threshold according the reception data length: 16bit */
   2044              CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   2045            }
   2046            else
   2047            {
   2048              /* Set RX Fifo threshold according the reception data length: 8bit */
   2049              SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   2050          
   2051              if (hspi->hdmarx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
   2052              {
   2053                /* Set RX Fifo threshold according the reception data length: 16bit */
   2054                CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   2055          
   2056                if ((hspi->RxXferCount & 0x1U) == 0x0U)
   2057                {
   2058                  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
   2059                  hspi->RxXferCount = hspi->RxXferCount >> 1U;
   2060                }
   2061                else
   2062                {
   2063                  SET_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
   2064                  hspi->RxXferCount = (hspi->RxXferCount >> 1U) + 1U;
   2065                }
   2066              }
   2067            }
   2068          
   2069            /* Set the SPI RxDMA Half transfer complete callback */
   2070            hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
   2071          
   2072            /* Set the SPI Rx DMA transfer complete callback */
   2073            hspi->hdmarx->XferCpltCallback = SPI_DMAReceiveCplt;
   2074          
   2075            /* Set the DMA error callback */
   2076            hspi->hdmarx->XferErrorCallback = SPI_DMAError;
   2077          
   2078            /* Set the DMA AbortCpltCallback */
   2079            hspi->hdmarx->XferAbortCallback = NULL;
   2080          
   2081            /* Enable the Rx DMA Stream/Channel  */
   2082            if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr,
   2083                                           hspi->RxXferCount))
   2084            {
   2085              /* Update SPI error code */
   2086              SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
   2087              errorcode = HAL_ERROR;
   2088          
   2089              goto error;
   2090            }
   2091          
   2092            /* Check if the SPI is already enabled */
   2093            if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
   2094            {
   2095              /* Enable SPI peripheral */
   2096              __HAL_SPI_ENABLE(hspi);
   2097            }
   2098          
   2099            /* Enable the SPI Error Interrupt Bit */
   2100            __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
   2101          
   2102            /* Enable Rx DMA Request */
   2103            SET_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
   2104          
   2105          error:
   2106            /* Process Unlocked */
   2107            __HAL_UNLOCK(hspi);
   2108            return errorcode;
   2109          }
   2110          
   2111          /**
   2112            * @brief  Transmit and Receive an amount of data in non-blocking mode with DMA.
   2113            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2114            *               the configuration information for SPI module.
   2115            * @param  pTxData pointer to transmission data buffer
   2116            * @param  pRxData pointer to reception data buffer
   2117            * @note   When the CRC feature is enabled the pRxData Length must be Size + 1
   2118            * @param  Size amount of data to be sent
   2119            * @retval HAL status
   2120            */
   2121          HAL_StatusTypeDef HAL_SPI_TransmitReceive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData,
   2122                                                        uint16_t Size)
   2123          {
   2124            uint32_t             tmp_mode;
   2125            HAL_SPI_StateTypeDef tmp_state;
   2126            HAL_StatusTypeDef errorcode = HAL_OK;
   2127          
   2128            /* Check rx & tx dma handles */
   2129            assert_param(IS_SPI_DMA_HANDLE(hspi->hdmarx));
   2130            assert_param(IS_SPI_DMA_HANDLE(hspi->hdmatx));
   2131          
   2132            /* Check Direction parameter */
   2133            assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
   2134          
   2135            /* Process locked */
   2136            __HAL_LOCK(hspi);
   2137          
   2138            /* Init temporary variables */
   2139            tmp_state           = hspi->State;
   2140            tmp_mode            = hspi->Init.Mode;
   2141          
   2142            if (!((tmp_state == HAL_SPI_STATE_READY) ||
   2143                  ((tmp_mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp_state == HAL_SPI_STATE_BUSY_RX))))
   2144            {
   2145              errorcode = HAL_BUSY;
   2146              goto error;
   2147            }
   2148          
   2149            if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
   2150            {
   2151              errorcode = HAL_ERROR;
   2152              goto error;
   2153            }
   2154          
   2155            /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
   2156            if (hspi->State != HAL_SPI_STATE_BUSY_RX)
   2157            {
   2158              hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
   2159            }
   2160          
   2161            /* Set the transaction information */
   2162            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   2163            hspi->pTxBuffPtr  = (uint8_t *)pTxData;
   2164            hspi->TxXferSize  = Size;
   2165            hspi->TxXferCount = Size;
   2166            hspi->pRxBuffPtr  = (uint8_t *)pRxData;
   2167            hspi->RxXferSize  = Size;
   2168            hspi->RxXferCount = Size;
   2169          
   2170            /* Init field not used in handle to zero */
   2171            hspi->RxISR       = NULL;
   2172            hspi->TxISR       = NULL;
   2173          
   2174          #if (USE_SPI_CRC != 0U)
   2175            /* Reset CRC Calculation */
   2176            if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   2177            {
   2178              SPI_RESET_CRC(hspi);
   2179            }
   2180          #endif /* USE_SPI_CRC */
   2181          
   2182            /* Reset the threshold bit */
   2183            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX | SPI_CR2_LDMARX);
   2184          
   2185            /* The packing mode management is enabled by the DMA settings according the spi data size */
   2186            if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
   2187            {
   2188              /* Set fiforxthreshold according the reception data length: 16bit */
   2189              CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   2190            }
   2191            else
   2192            {
   2193              /* Set RX Fifo threshold according the reception data length: 8bit */
   2194              SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   2195          
   2196              if (hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
   2197              {
   2198                if ((hspi->TxXferSize & 0x1U) == 0x0U)
   2199                {
   2200                  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
   2201                  hspi->TxXferCount = hspi->TxXferCount >> 1U;
   2202                }
   2203                else
   2204                {
   2205                  SET_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
   2206                  hspi->TxXferCount = (hspi->TxXferCount >> 1U) + 1U;
   2207                }
   2208              }
   2209          
   2210              if (hspi->hdmarx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
   2211              {
   2212                /* Set RX Fifo threshold according the reception data length: 16bit */
   2213                CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   2214          
   2215                if ((hspi->RxXferCount & 0x1U) == 0x0U)
   2216                {
   2217                  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
   2218                  hspi->RxXferCount = hspi->RxXferCount >> 1U;
   2219                }
   2220                else
   2221                {
   2222                  SET_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
   2223                  hspi->RxXferCount = (hspi->RxXferCount >> 1U) + 1U;
   2224                }
   2225              }
   2226            }
   2227          
   2228            /* Check if we are in Rx only or in Rx/Tx Mode and configure the DMA transfer complete callback */
   2229            if (hspi->State == HAL_SPI_STATE_BUSY_RX)
   2230            {
   2231              /* Set the SPI Rx DMA Half transfer complete callback */
   2232              hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
   2233              hspi->hdmarx->XferCpltCallback     = SPI_DMAReceiveCplt;
   2234            }
   2235            else
   2236            {
   2237              /* Set the SPI Tx/Rx DMA Half transfer complete callback */
   2238              hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfTransmitReceiveCplt;
   2239              hspi->hdmarx->XferCpltCallback     = SPI_DMATransmitReceiveCplt;
   2240            }
   2241          
   2242            /* Set the DMA error callback */
   2243            hspi->hdmarx->XferErrorCallback = SPI_DMAError;
   2244          
   2245            /* Set the DMA AbortCpltCallback */
   2246            hspi->hdmarx->XferAbortCallback = NULL;
   2247          
   2248            /* Enable the Rx DMA Stream/Channel  */
   2249            if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr,
   2250                                           hspi->RxXferCount))
   2251            {
   2252              /* Update SPI error code */
   2253              SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
   2254              errorcode = HAL_ERROR;
   2255          
   2256              goto error;
   2257            }
   2258          
   2259            /* Enable Rx DMA Request */
   2260            SET_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
   2261          
   2262            /* Set the SPI Tx DMA transfer complete callback as NULL because the communication closing
   2263            is performed in DMA reception complete callback  */
   2264            hspi->hdmatx->XferHalfCpltCallback = NULL;
   2265            hspi->hdmatx->XferCpltCallback     = NULL;
   2266            hspi->hdmatx->XferErrorCallback    = NULL;
   2267            hspi->hdmatx->XferAbortCallback    = NULL;
   2268          
   2269            /* Enable the Tx DMA Stream/Channel  */
   2270            if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR,
   2271                                           hspi->TxXferCount))
   2272            {
   2273              /* Update SPI error code */
   2274              SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
   2275              errorcode = HAL_ERROR;
   2276          
   2277              goto error;
   2278            }
   2279          
   2280            /* Check if the SPI is already enabled */
   2281            if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
   2282            {
   2283              /* Enable SPI peripheral */
   2284              __HAL_SPI_ENABLE(hspi);
   2285            }
   2286            /* Enable the SPI Error Interrupt Bit */
   2287            __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
   2288          
   2289            /* Enable Tx DMA Request */
   2290            SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
   2291          
   2292          error :
   2293            /* Process Unlocked */
   2294            __HAL_UNLOCK(hspi);
   2295            return errorcode;
   2296          }
   2297          
   2298          /**
   2299            * @brief  Abort ongoing transfer (blocking mode).
   2300            * @param  hspi SPI handle.
   2301            * @note   This procedure could be used for aborting any ongoing transfer (Tx and Rx),
   2302            *         started in Interrupt or DMA mode.
   2303            *         This procedure performs following operations :
   2304            *           - Disable SPI Interrupts (depending of transfer direction)
   2305            *           - Disable the DMA transfer in the peripheral register (if enabled)
   2306            *           - Abort DMA transfer by calling HAL_DMA_Abort (in case of transfer in DMA mode)
   2307            *           - Set handle State to READY
   2308            * @note   This procedure is executed in blocking mode : when exiting function, Abort is considered as completed.
   2309            * @retval HAL status
   2310            */
   2311          HAL_StatusTypeDef HAL_SPI_Abort(SPI_HandleTypeDef *hspi)
   2312          {
   2313            HAL_StatusTypeDef errorcode;
   2314            __IO uint32_t count;
   2315            __IO uint32_t resetcount;
   2316          
   2317            /* Initialized local variable  */
   2318            errorcode = HAL_OK;
   2319            resetcount = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
   2320            count = resetcount;
   2321          
   2322            /* Clear ERRIE interrupt to avoid error interrupts generation during Abort procedure */
   2323            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_ERRIE);
   2324          
   2325            /* Disable TXEIE, RXNEIE and ERRIE(mode fault event, overrun error, TI frame error) interrupts */
   2326            if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXEIE))
   2327            {
   2328              hspi->TxISR = SPI_AbortTx_ISR;
   2329              /* Wait HAL_SPI_STATE_ABORT state */
   2330              do
   2331              {
   2332                if (count == 0U)
   2333                {
   2334                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
   2335                  break;
   2336                }
   2337                count--;
   2338              } while (hspi->State != HAL_SPI_STATE_ABORT);
   2339              /* Reset Timeout Counter */
   2340              count = resetcount;
   2341            }
   2342          
   2343            if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXNEIE))
   2344            {
   2345              hspi->RxISR = SPI_AbortRx_ISR;
   2346              /* Wait HAL_SPI_STATE_ABORT state */
   2347              do
   2348              {
   2349                if (count == 0U)
   2350                {
   2351                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
   2352                  break;
   2353                }
   2354                count--;
   2355              } while (hspi->State != HAL_SPI_STATE_ABORT);
   2356              /* Reset Timeout Counter */
   2357              count = resetcount;
   2358            }
   2359          
   2360            /* Disable the SPI DMA Tx request if enabled */
   2361            if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXDMAEN))
   2362            {
   2363              /* Abort the SPI DMA Tx Stream/Channel : use blocking DMA Abort API (no callback) */
   2364              if (hspi->hdmatx != NULL)
   2365              {
   2366                /* Set the SPI DMA Abort callback :
   2367                will lead to call HAL_SPI_AbortCpltCallback() at end of DMA abort procedure */
   2368                hspi->hdmatx->XferAbortCallback = NULL;
   2369          
   2370                /* Abort DMA Tx Handle linked to SPI Peripheral */
   2371                if (HAL_DMA_Abort(hspi->hdmatx) != HAL_OK)
   2372                {
   2373                  hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
   2374                }
   2375          
   2376                /* Disable Tx DMA Request */
   2377                CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXDMAEN));
   2378          
   2379                if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, HAL_GetTick()) != HAL_OK)
   2380                {
   2381                  hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
   2382                }
   2383          
   2384                /* Disable SPI Peripheral */
   2385                __HAL_SPI_DISABLE(hspi);
   2386          
   2387                /* Empty the FRLVL fifo */
   2388                if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, SPI_DEFAULT_TIMEOUT, HAL_GetTick()) != HAL_OK)
   2389                {
   2390                  hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
   2391                }
   2392              }
   2393            }
   2394          
   2395            /* Disable the SPI DMA Rx request if enabled */
   2396            if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXDMAEN))
   2397            {
   2398              /* Abort the SPI DMA Rx Stream/Channel : use blocking DMA Abort API (no callback) */
   2399              if (hspi->hdmarx != NULL)
   2400              {
   2401                /* Set the SPI DMA Abort callback :
   2402                will lead to call HAL_SPI_AbortCpltCallback() at end of DMA abort procedure */
   2403                hspi->hdmarx->XferAbortCallback = NULL;
   2404          
   2405                /* Abort DMA Rx Handle linked to SPI Peripheral */
   2406                if (HAL_DMA_Abort(hspi->hdmarx) != HAL_OK)
   2407                {
   2408                  hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
   2409                }
   2410          
   2411                /* Disable peripheral */
   2412                __HAL_SPI_DISABLE(hspi);
   2413          
   2414                /* Control the BSY flag */
   2415                if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, SPI_DEFAULT_TIMEOUT, HAL_GetTick()) != HAL_OK)
   2416                {
   2417                  hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
   2418                }
   2419          
   2420                /* Empty the FRLVL fifo */
   2421                if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, SPI_DEFAULT_TIMEOUT, HAL_GetTick()) != HAL_OK)
   2422                {
   2423                  hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
   2424                }
   2425          
   2426                /* Disable Rx DMA Request */
   2427                CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_RXDMAEN));
   2428              }
   2429            }
   2430            /* Reset Tx and Rx transfer counters */
   2431            hspi->RxXferCount = 0U;
   2432            hspi->TxXferCount = 0U;
   2433          
   2434            /* Check error during Abort procedure */
   2435            if (hspi->ErrorCode == HAL_SPI_ERROR_ABORT)
   2436            {
   2437              /* return HAL_Error in case of error during Abort procedure */
   2438              errorcode = HAL_ERROR;
   2439            }
   2440            else
   2441            {
   2442              /* Reset errorCode */
   2443              hspi->ErrorCode = HAL_SPI_ERROR_NONE;
   2444            }
   2445          
   2446            /* Clear the Error flags in the SR register */
   2447            __HAL_SPI_CLEAR_OVRFLAG(hspi);
   2448            __HAL_SPI_CLEAR_FREFLAG(hspi);
   2449          
   2450            /* Restore hspi->state to ready */
   2451            hspi->State = HAL_SPI_STATE_READY;
   2452          
   2453            return errorcode;
   2454          }
   2455          
   2456          /**
   2457            * @brief  Abort ongoing transfer (Interrupt mode).
   2458            * @param  hspi SPI handle.
   2459            * @note   This procedure could be used for aborting any ongoing transfer (Tx and Rx),
   2460            *         started in Interrupt or DMA mode.
   2461            *         This procedure performs following operations :
   2462            *           - Disable SPI Interrupts (depending of transfer direction)
   2463            *           - Disable the DMA transfer in the peripheral register (if enabled)
   2464            *           - Abort DMA transfer by calling HAL_DMA_Abort_IT (in case of transfer in DMA mode)
   2465            *           - Set handle State to READY
   2466            *           - At abort completion, call user abort complete callback
   2467            * @note   This procedure is executed in Interrupt mode, meaning that abort procedure could be
   2468            *         considered as completed only when user abort complete callback is executed (not when exiting function).
   2469            * @retval HAL status
   2470            */
   2471          HAL_StatusTypeDef HAL_SPI_Abort_IT(SPI_HandleTypeDef *hspi)
   2472          {
   2473            HAL_StatusTypeDef errorcode;
   2474            uint32_t abortcplt ;
   2475            __IO uint32_t count;
   2476            __IO uint32_t resetcount;
   2477          
   2478            /* Initialized local variable  */
   2479            errorcode = HAL_OK;
   2480            abortcplt = 1U;
   2481            resetcount = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
   2482            count = resetcount;
   2483          
   2484            /* Clear ERRIE interrupt to avoid error interrupts generation during Abort procedure */
   2485            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_ERRIE);
   2486          
   2487            /* Change Rx and Tx Irq Handler to Disable TXEIE, RXNEIE and ERRIE interrupts */
   2488            if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXEIE))
   2489            {
   2490              hspi->TxISR = SPI_AbortTx_ISR;
   2491              /* Wait HAL_SPI_STATE_ABORT state */
   2492              do
   2493              {
   2494                if (count == 0U)
   2495                {
   2496                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
   2497                  break;
   2498                }
   2499                count--;
   2500              } while (hspi->State != HAL_SPI_STATE_ABORT);
   2501              /* Reset Timeout Counter */
   2502              count = resetcount;
   2503            }
   2504          
   2505            if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXNEIE))
   2506            {
   2507              hspi->RxISR = SPI_AbortRx_ISR;
   2508              /* Wait HAL_SPI_STATE_ABORT state */
   2509              do
   2510              {
   2511                if (count == 0U)
   2512                {
   2513                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
   2514                  break;
   2515                }
   2516                count--;
   2517              } while (hspi->State != HAL_SPI_STATE_ABORT);
   2518              /* Reset Timeout Counter */
   2519              count = resetcount;
   2520            }
   2521          
   2522            /* If DMA Tx and/or DMA Rx Handles are associated to SPI Handle, DMA Abort complete callbacks should be initialised
   2523               before any call to DMA Abort functions */
   2524            /* DMA Tx Handle is valid */
   2525            if (hspi->hdmatx != NULL)
   2526            {
   2527              /* Set DMA Abort Complete callback if UART DMA Tx request if enabled.
   2528                 Otherwise, set it to NULL */
   2529              if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXDMAEN))
   2530              {
   2531                hspi->hdmatx->XferAbortCallback = SPI_DMATxAbortCallback;
   2532              }
   2533              else
   2534              {
   2535                hspi->hdmatx->XferAbortCallback = NULL;
   2536              }
   2537            }
   2538            /* DMA Rx Handle is valid */
   2539            if (hspi->hdmarx != NULL)
   2540            {
   2541              /* Set DMA Abort Complete callback if UART DMA Rx request if enabled.
   2542                 Otherwise, set it to NULL */
   2543              if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXDMAEN))
   2544              {
   2545                hspi->hdmarx->XferAbortCallback = SPI_DMARxAbortCallback;
   2546              }
   2547              else
   2548              {
   2549                hspi->hdmarx->XferAbortCallback = NULL;
   2550              }
   2551            }
   2552          
   2553            /* Disable the SPI DMA Tx request if enabled */
   2554            if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXDMAEN))
   2555            {
   2556              /* Abort the SPI DMA Tx Stream/Channel */
   2557              if (hspi->hdmatx != NULL)
   2558              {
   2559                /* Abort DMA Tx Handle linked to SPI Peripheral */
   2560                if (HAL_DMA_Abort_IT(hspi->hdmatx) != HAL_OK)
   2561                {
   2562                  hspi->hdmatx->XferAbortCallback = NULL;
   2563                  hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
   2564                }
   2565                else
   2566                {
   2567                  abortcplt = 0U;
   2568                }
   2569              }
   2570            }
   2571            /* Disable the SPI DMA Rx request if enabled */
   2572            if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXDMAEN))
   2573            {
   2574              /* Abort the SPI DMA Rx Stream/Channel */
   2575              if (hspi->hdmarx != NULL)
   2576              {
   2577                /* Abort DMA Rx Handle linked to SPI Peripheral */
   2578                if (HAL_DMA_Abort_IT(hspi->hdmarx) !=  HAL_OK)
   2579                {
   2580                  hspi->hdmarx->XferAbortCallback = NULL;
   2581                  hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
   2582                }
   2583                else
   2584                {
   2585                  abortcplt = 0U;
   2586                }
   2587              }
   2588            }
   2589          
   2590            if (abortcplt == 1U)
   2591            {
   2592              /* Reset Tx and Rx transfer counters */
   2593              hspi->RxXferCount = 0U;
   2594              hspi->TxXferCount = 0U;
   2595          
   2596              /* Check error during Abort procedure */
   2597              if (hspi->ErrorCode == HAL_SPI_ERROR_ABORT)
   2598              {
   2599                /* return HAL_Error in case of error during Abort procedure */
   2600                errorcode = HAL_ERROR;
   2601              }
   2602              else
   2603              {
   2604                /* Reset errorCode */
   2605                hspi->ErrorCode = HAL_SPI_ERROR_NONE;
   2606              }
   2607          
   2608              /* Clear the Error flags in the SR register */
   2609              __HAL_SPI_CLEAR_OVRFLAG(hspi);
   2610              __HAL_SPI_CLEAR_FREFLAG(hspi);
   2611          
   2612              /* Restore hspi->State to Ready */
   2613              hspi->State = HAL_SPI_STATE_READY;
   2614          
   2615              /* As no DMA to be aborted, call directly user Abort complete callback */
   2616          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   2617              hspi->AbortCpltCallback(hspi);
   2618          #else
   2619              HAL_SPI_AbortCpltCallback(hspi);
   2620          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   2621            }
   2622          
   2623            return errorcode;
   2624          }
   2625          
   2626          /**
   2627            * @brief  Pause the DMA Transfer.
   2628            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2629            *               the configuration information for the specified SPI module.
   2630            * @retval HAL status
   2631            */
   2632          HAL_StatusTypeDef HAL_SPI_DMAPause(SPI_HandleTypeDef *hspi)
   2633          {
   2634            /* Process Locked */
   2635            __HAL_LOCK(hspi);
   2636          
   2637            /* Disable the SPI DMA Tx & Rx requests */
   2638            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
   2639          
   2640            /* Process Unlocked */
   2641            __HAL_UNLOCK(hspi);
   2642          
   2643            return HAL_OK;
   2644          }
   2645          
   2646          /**
   2647            * @brief  Resume the DMA Transfer.
   2648            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2649            *               the configuration information for the specified SPI module.
   2650            * @retval HAL status
   2651            */
   2652          HAL_StatusTypeDef HAL_SPI_DMAResume(SPI_HandleTypeDef *hspi)
   2653          {
   2654            /* Process Locked */
   2655            __HAL_LOCK(hspi);
   2656          
   2657            /* Enable the SPI DMA Tx & Rx requests */
   2658            SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
   2659          
   2660            /* Process Unlocked */
   2661            __HAL_UNLOCK(hspi);
   2662          
   2663            return HAL_OK;
   2664          }
   2665          
   2666          /**
   2667            * @brief  Stop the DMA Transfer.
   2668            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2669            *               the configuration information for the specified SPI module.
   2670            * @retval HAL status
   2671            */
   2672          HAL_StatusTypeDef HAL_SPI_DMAStop(SPI_HandleTypeDef *hspi)
   2673          {
   2674            HAL_StatusTypeDef errorcode = HAL_OK;
   2675            /* The Lock is not implemented on this API to allow the user application
   2676               to call the HAL SPI API under callbacks HAL_SPI_TxCpltCallback() or HAL_SPI_RxCpltCallback() or HAL_SPI_TxRxCpltCallback():
   2677               when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated
   2678               and the correspond call back is executed HAL_SPI_TxCpltCallback() or HAL_SPI_RxCpltCallback() or HAL_SPI_TxRxCpltCallback()
   2679               */
   2680          
   2681            /* Abort the SPI DMA tx Stream/Channel  */
   2682            if (hspi->hdmatx != NULL)
   2683            {
   2684              if (HAL_OK != HAL_DMA_Abort(hspi->hdmatx))
   2685              {
   2686                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
   2687                errorcode = HAL_ERROR;
   2688              }
   2689            }
   2690            /* Abort the SPI DMA rx Stream/Channel  */
   2691            if (hspi->hdmarx != NULL)
   2692            {
   2693              if (HAL_OK != HAL_DMA_Abort(hspi->hdmarx))
   2694              {
   2695                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
   2696                errorcode = HAL_ERROR;
   2697              }
   2698            }
   2699          
   2700            /* Disable the SPI DMA Tx & Rx requests */
   2701            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
   2702            hspi->State = HAL_SPI_STATE_READY;
   2703            return errorcode;
   2704          }
   2705          
   2706          /**
   2707            * @brief  Handle SPI interrupt request.
   2708            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2709            *               the configuration information for the specified SPI module.
   2710            * @retval None
   2711            */
   2712          void HAL_SPI_IRQHandler(SPI_HandleTypeDef *hspi)
   2713          {
   2714            uint32_t itsource = hspi->Instance->CR2;
   2715            uint32_t itflag   = hspi->Instance->SR;
   2716          
   2717            /* SPI in mode Receiver ----------------------------------------------------*/
   2718            if ((SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) == RESET) &&
   2719                (SPI_CHECK_FLAG(itflag, SPI_FLAG_RXNE) != RESET) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_RXNE) != RESET))
   2720            {
   2721              hspi->RxISR(hspi);
   2722              return;
   2723            }
   2724          
   2725            /* SPI in mode Transmitter -------------------------------------------------*/
   2726            if ((SPI_CHECK_FLAG(itflag, SPI_FLAG_TXE) != RESET) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_TXE) != RESET))
   2727            {
   2728              hspi->TxISR(hspi);
   2729              return;
   2730            }
   2731          
   2732            /* SPI in Error Treatment --------------------------------------------------*/
   2733            if (((SPI_CHECK_FLAG(itflag, SPI_FLAG_MODF) != RESET) || (SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) != RESET)
   2734                 || (SPI_CHECK_FLAG(itflag, SPI_FLAG_FRE) != RESET)) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_ERR) != RESET))
   2735            {
   2736              /* SPI Overrun error interrupt occurred ----------------------------------*/
   2737              if (SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) != RESET)
   2738              {
   2739                if (hspi->State != HAL_SPI_STATE_BUSY_TX)
   2740                {
   2741                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_OVR);
   2742                  __HAL_SPI_CLEAR_OVRFLAG(hspi);
   2743                }
   2744                else
   2745                {
   2746                  __HAL_SPI_CLEAR_OVRFLAG(hspi);
   2747                  return;
   2748                }
   2749              }
   2750          
   2751              /* SPI Mode Fault error interrupt occurred -------------------------------*/
   2752              if (SPI_CHECK_FLAG(itflag, SPI_FLAG_MODF) != RESET)
   2753              {
   2754                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_MODF);
   2755                __HAL_SPI_CLEAR_MODFFLAG(hspi);
   2756              }
   2757          
   2758              /* SPI Frame error interrupt occurred ------------------------------------*/
   2759              if (SPI_CHECK_FLAG(itflag, SPI_FLAG_FRE) != RESET)
   2760              {
   2761                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FRE);
   2762                __HAL_SPI_CLEAR_FREFLAG(hspi);
   2763              }
   2764          
   2765              if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
   2766              {
   2767                /* Disable all interrupts */
   2768                __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE | SPI_IT_TXE | SPI_IT_ERR);
   2769          
   2770                hspi->State = HAL_SPI_STATE_READY;
   2771                /* Disable the SPI DMA requests if enabled */
   2772                if ((HAL_IS_BIT_SET(itsource, SPI_CR2_TXDMAEN)) || (HAL_IS_BIT_SET(itsource, SPI_CR2_RXDMAEN)))
   2773                {
   2774                  CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN));
   2775          
   2776                  /* Abort the SPI DMA Rx channel */
   2777                  if (hspi->hdmarx != NULL)
   2778                  {
   2779                    /* Set the SPI DMA Abort callback :
   2780                    will lead to call HAL_SPI_ErrorCallback() at end of DMA abort procedure */
   2781                    hspi->hdmarx->XferAbortCallback = SPI_DMAAbortOnError;
   2782                    if (HAL_OK != HAL_DMA_Abort_IT(hspi->hdmarx))
   2783                    {
   2784                      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
   2785                    }
   2786                  }
   2787                  /* Abort the SPI DMA Tx channel */
   2788                  if (hspi->hdmatx != NULL)
   2789                  {
   2790                    /* Set the SPI DMA Abort callback :
   2791                    will lead to call HAL_SPI_ErrorCallback() at end of DMA abort procedure */
   2792                    hspi->hdmatx->XferAbortCallback = SPI_DMAAbortOnError;
   2793                    if (HAL_OK != HAL_DMA_Abort_IT(hspi->hdmatx))
   2794                    {
   2795                      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
   2796                    }
   2797                  }
   2798                }
   2799                else
   2800                {
   2801                  /* Call user error callback */
   2802          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   2803                  hspi->ErrorCallback(hspi);
   2804          #else
   2805                  HAL_SPI_ErrorCallback(hspi);
   2806          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   2807                }
   2808              }
   2809              return;
   2810            }
   2811          }
   2812          
   2813          /**
   2814            * @brief  Tx Transfer completed callback.
   2815            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2816            *               the configuration information for SPI module.
   2817            * @retval None
   2818            */
   2819          __weak void HAL_SPI_TxCpltCallback(SPI_HandleTypeDef *hspi)
   2820          {
   2821            /* Prevent unused argument(s) compilation warning */
   2822            UNUSED(hspi);
   2823          
   2824            /* NOTE : This function should not be modified, when the callback is needed,
   2825                      the HAL_SPI_TxCpltCallback should be implemented in the user file
   2826             */
   2827          }
   2828          
   2829          /**
   2830            * @brief  Rx Transfer completed callback.
   2831            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2832            *               the configuration information for SPI module.
   2833            * @retval None
   2834            */
   2835          __weak void HAL_SPI_RxCpltCallback(SPI_HandleTypeDef *hspi)
   2836          {
   2837            /* Prevent unused argument(s) compilation warning */
   2838            UNUSED(hspi);
   2839          
   2840            /* NOTE : This function should not be modified, when the callback is needed,
   2841                      the HAL_SPI_RxCpltCallback should be implemented in the user file
   2842             */
   2843          }
   2844          
   2845          /**
   2846            * @brief  Tx and Rx Transfer completed callback.
   2847            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2848            *               the configuration information for SPI module.
   2849            * @retval None
   2850            */
   2851          __weak void HAL_SPI_TxRxCpltCallback(SPI_HandleTypeDef *hspi)
   2852          {
   2853            /* Prevent unused argument(s) compilation warning */
   2854            UNUSED(hspi);
   2855          
   2856            /* NOTE : This function should not be modified, when the callback is needed,
   2857                      the HAL_SPI_TxRxCpltCallback should be implemented in the user file
   2858             */
   2859          }
   2860          
   2861          /**
   2862            * @brief  Tx Half Transfer completed callback.
   2863            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2864            *               the configuration information for SPI module.
   2865            * @retval None
   2866            */
   2867          __weak void HAL_SPI_TxHalfCpltCallback(SPI_HandleTypeDef *hspi)
   2868          {
   2869            /* Prevent unused argument(s) compilation warning */
   2870            UNUSED(hspi);
   2871          
   2872            /* NOTE : This function should not be modified, when the callback is needed,
   2873                      the HAL_SPI_TxHalfCpltCallback should be implemented in the user file
   2874             */
   2875          }
   2876          
   2877          /**
   2878            * @brief  Rx Half Transfer completed callback.
   2879            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2880            *               the configuration information for SPI module.
   2881            * @retval None
   2882            */
   2883          __weak void HAL_SPI_RxHalfCpltCallback(SPI_HandleTypeDef *hspi)
   2884          {
   2885            /* Prevent unused argument(s) compilation warning */
   2886            UNUSED(hspi);
   2887          
   2888            /* NOTE : This function should not be modified, when the callback is needed,
   2889                      the HAL_SPI_RxHalfCpltCallback() should be implemented in the user file
   2890             */
   2891          }
   2892          
   2893          /**
   2894            * @brief  Tx and Rx Half Transfer callback.
   2895            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2896            *               the configuration information for SPI module.
   2897            * @retval None
   2898            */
   2899          __weak void HAL_SPI_TxRxHalfCpltCallback(SPI_HandleTypeDef *hspi)
   2900          {
   2901            /* Prevent unused argument(s) compilation warning */
   2902            UNUSED(hspi);
   2903          
   2904            /* NOTE : This function should not be modified, when the callback is needed,
   2905                      the HAL_SPI_TxRxHalfCpltCallback() should be implemented in the user file
   2906             */
   2907          }
   2908          
   2909          /**
   2910            * @brief  SPI error callback.
   2911            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2912            *               the configuration information for SPI module.
   2913            * @retval None
   2914            */
   2915          __weak void HAL_SPI_ErrorCallback(SPI_HandleTypeDef *hspi)
   2916          {
   2917            /* Prevent unused argument(s) compilation warning */
   2918            UNUSED(hspi);
   2919          
   2920            /* NOTE : This function should not be modified, when the callback is needed,
   2921                      the HAL_SPI_ErrorCallback should be implemented in the user file
   2922             */
   2923            /* NOTE : The ErrorCode parameter in the hspi handle is updated by the SPI processes
   2924                      and user can use HAL_SPI_GetError() API to check the latest error occurred
   2925             */
   2926          }
   2927          
   2928          /**
   2929            * @brief  SPI Abort Complete callback.
   2930            * @param  hspi SPI handle.
   2931            * @retval None
   2932            */
   2933          __weak void HAL_SPI_AbortCpltCallback(SPI_HandleTypeDef *hspi)
   2934          {
   2935            /* Prevent unused argument(s) compilation warning */
   2936            UNUSED(hspi);
   2937          
   2938            /* NOTE : This function should not be modified, when the callback is needed,
   2939                      the HAL_SPI_AbortCpltCallback can be implemented in the user file.
   2940             */
   2941          }
   2942          
   2943          /**
   2944            * @}
   2945            */
   2946          
   2947          /** @defgroup SPI_Exported_Functions_Group3 Peripheral State and Errors functions
   2948            * @brief   SPI control functions
   2949            *
   2950          @verbatim
   2951           ===============================================================================
   2952                                ##### Peripheral State and Errors functions #####
   2953           ===============================================================================
   2954              [..]
   2955              This subsection provides a set of functions allowing to control the SPI.
   2956               (+) HAL_SPI_GetState() API can be helpful to check in run-time the state of the SPI peripheral
   2957               (+) HAL_SPI_GetError() check in run-time Errors occurring during communication
   2958          @endverbatim
   2959            * @{
   2960            */
   2961          
   2962          /**
   2963            * @brief  Return the SPI handle state.
   2964            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2965            *               the configuration information for SPI module.
   2966            * @retval SPI state
   2967            */
   2968          HAL_SPI_StateTypeDef HAL_SPI_GetState(SPI_HandleTypeDef *hspi)
   2969          {
   2970            /* Return SPI handle state */
   2971            return hspi->State;
   2972          }
   2973          
   2974          /**
   2975            * @brief  Return the SPI error code.
   2976            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2977            *               the configuration information for SPI module.
   2978            * @retval SPI error code in bitmap format
   2979            */
   2980          uint32_t HAL_SPI_GetError(SPI_HandleTypeDef *hspi)
   2981          {
   2982            /* Return SPI ErrorCode */
   2983            return hspi->ErrorCode;
   2984          }
   2985          
   2986          /**
   2987            * @}
   2988            */
   2989          
   2990          /**
   2991            * @}
   2992            */
   2993          
   2994          /** @addtogroup SPI_Private_Functions
   2995            * @brief   Private functions
   2996            * @{
   2997            */
   2998          
   2999          /**
   3000            * @brief  DMA SPI transmit process complete callback.
   3001            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
   3002            *               the configuration information for the specified DMA module.
   3003            * @retval None
   3004            */
   3005          static void SPI_DMATransmitCplt(DMA_HandleTypeDef *hdma)
   3006          {
   3007            SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
   3008            uint32_t tickstart;
   3009          
   3010            /* Init tickstart for timeout management*/
   3011            tickstart = HAL_GetTick();
   3012          
   3013            /* DMA Normal Mode */
   3014            if ((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
   3015            {
   3016              /* Disable ERR interrupt */
   3017              __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
   3018          
   3019              /* Disable Tx DMA Request */
   3020              CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
   3021          
   3022              /* Check the end of the transaction */
   3023              if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
   3024              {
   3025                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   3026              }
   3027          
   3028              /* Clear overrun flag in 2 Lines communication mode because received data is not read */
   3029              if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
   3030              {
   3031                __HAL_SPI_CLEAR_OVRFLAG(hspi);
   3032              }
   3033          
   3034              hspi->TxXferCount = 0U;
   3035              hspi->State = HAL_SPI_STATE_READY;
   3036          
   3037              if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
   3038              {
   3039                /* Call user error callback */
   3040          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   3041                hspi->ErrorCallback(hspi);
   3042          #else
   3043                HAL_SPI_ErrorCallback(hspi);
   3044          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   3045                return;
   3046              }
   3047            }
   3048            /* Call user Tx complete callback */
   3049          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   3050            hspi->TxCpltCallback(hspi);
   3051          #else
   3052            HAL_SPI_TxCpltCallback(hspi);
   3053          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   3054          }
   3055          
   3056          /**
   3057            * @brief  DMA SPI receive process complete callback.
   3058            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
   3059            *               the configuration information for the specified DMA module.
   3060            * @retval None
   3061            */
   3062          static void SPI_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
   3063          {
   3064            SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
   3065            uint32_t tickstart;
   3066          #if (USE_SPI_CRC != 0U)
   3067            __IO uint32_t tmpreg = 0U;
   3068            __IO uint8_t  *ptmpreg8;
   3069            __IO uint8_t  tmpreg8 = 0;
   3070          #endif /* USE_SPI_CRC */
   3071          
   3072            /* Init tickstart for timeout management*/
   3073            tickstart = HAL_GetTick();
   3074          
   3075            /* DMA Normal Mode */
   3076            if ((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
   3077            {
   3078              /* Disable ERR interrupt */
   3079              __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
   3080          
   3081          #if (USE_SPI_CRC != 0U)
   3082              /* CRC handling */
   3083              if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   3084              {
   3085                /* Wait until RXNE flag */
   3086                if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
   3087                {
   3088                  /* Error on the CRC reception */
   3089                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   3090                }
   3091                /* Read CRC */
   3092                if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
   3093                {
   3094                  /* Read 16bit CRC */
   3095                  tmpreg = READ_REG(hspi->Instance->DR);
   3096                  /* To avoid GCC warning */
   3097                  UNUSED(tmpreg);
   3098                }
   3099                else
   3100                {
   3101                  /* Initialize the 8bit temporary pointer */
   3102                  ptmpreg8 = (__IO uint8_t *)&hspi->Instance->DR;
   3103                  /* Read 8bit CRC */
   3104                  tmpreg8 = *ptmpreg8;
   3105                  /* To avoid GCC warning */
   3106                  UNUSED(tmpreg8);
   3107          
   3108                  if (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
   3109                  {
   3110                    if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
   3111                    {
   3112                      /* Error on the CRC reception */
   3113                      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   3114                    }
   3115                    /* Read 8bit CRC again in case of 16bit CRC in 8bit Data mode */
   3116                    tmpreg8 = *ptmpreg8;
   3117                    /* To avoid GCC warning */
   3118                    UNUSED(tmpreg8);
   3119                  }
   3120                }
   3121              }
   3122          #endif /* USE_SPI_CRC */
   3123          
   3124              /* Check if we are in Master RX 2 line mode */
   3125              if ((hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->Init.Mode == SPI_MODE_MASTER))
   3126              {
   3127                /* Disable Rx/Tx DMA Request (done by default to handle the case master rx direction 2 lines) */
   3128                CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
   3129              }
   3130              else
   3131              {
   3132                /* Normal case */
   3133                CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
   3134              }
   3135          
   3136              /* Check the end of the transaction */
   3137              if (SPI_EndRxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
   3138              {
   3139                hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
   3140              }
   3141          
   3142              hspi->RxXferCount = 0U;
   3143              hspi->State = HAL_SPI_STATE_READY;
   3144          
   3145          #if (USE_SPI_CRC != 0U)
   3146              /* Check if CRC error occurred */
   3147              if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR))
   3148              {
   3149                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   3150                __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
   3151              }
   3152          #endif /* USE_SPI_CRC */
   3153          
   3154              if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
   3155              {
   3156                /* Call user error callback */
   3157          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   3158                hspi->ErrorCallback(hspi);
   3159          #else
   3160                HAL_SPI_ErrorCallback(hspi);
   3161          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   3162                return;
   3163              }
   3164            }
   3165            /* Call user Rx complete callback */
   3166          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   3167            hspi->RxCpltCallback(hspi);
   3168          #else
   3169            HAL_SPI_RxCpltCallback(hspi);
   3170          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   3171          }
   3172          
   3173          /**
   3174            * @brief  DMA SPI transmit receive process complete callback.
   3175            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
   3176            *               the configuration information for the specified DMA module.
   3177            * @retval None
   3178            */
   3179          static void SPI_DMATransmitReceiveCplt(DMA_HandleTypeDef *hdma)
   3180          {
   3181            SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
   3182            uint32_t tickstart;
   3183          #if (USE_SPI_CRC != 0U)
   3184            __IO uint32_t tmpreg = 0U;
   3185            __IO uint8_t  *ptmpreg8;
   3186            __IO uint8_t  tmpreg8 = 0;
   3187          #endif /* USE_SPI_CRC */
   3188          
   3189            /* Init tickstart for timeout management*/
   3190            tickstart = HAL_GetTick();
   3191          
   3192            /* DMA Normal Mode */
   3193            if ((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
   3194            {
   3195              /* Disable ERR interrupt */
   3196              __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
   3197          
   3198          #if (USE_SPI_CRC != 0U)
   3199              /* CRC handling */
   3200              if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   3201              {
   3202                if ((hspi->Init.DataSize == SPI_DATASIZE_8BIT) && (hspi->Init.CRCLength == SPI_CRC_LENGTH_8BIT))
   3203                {
   3204                  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_QUARTER_FULL, SPI_DEFAULT_TIMEOUT,
   3205                                                    tickstart) != HAL_OK)
   3206                  {
   3207                    /* Error on the CRC reception */
   3208                    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   3209                  }
   3210                  /* Initialize the 8bit temporary pointer */
   3211                  ptmpreg8 = (__IO uint8_t *)&hspi->Instance->DR;
   3212                  /* Read 8bit CRC */
   3213                  tmpreg8 = *ptmpreg8;
   3214                  /* To avoid GCC warning */
   3215                  UNUSED(tmpreg8);
   3216                }
   3217                else
   3218                {
   3219                  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_HALF_FULL, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
   3220                  {
   3221                    /* Error on the CRC reception */
   3222                    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   3223                  }
   3224                  /* Read CRC to Flush DR and RXNE flag */
   3225                  tmpreg = READ_REG(hspi->Instance->DR);
   3226                  /* To avoid GCC warning */
   3227                  UNUSED(tmpreg);
   3228                }
   3229              }
   3230          #endif /* USE_SPI_CRC */
   3231          
   3232              /* Check the end of the transaction */
   3233              if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
   3234              {
   3235                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   3236              }
   3237          
   3238              /* Disable Rx/Tx DMA Request */
   3239              CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
   3240          
   3241              hspi->TxXferCount = 0U;
   3242              hspi->RxXferCount = 0U;
   3243              hspi->State = HAL_SPI_STATE_READY;
   3244          
   3245          #if (USE_SPI_CRC != 0U)
   3246              /* Check if CRC error occurred */
   3247              if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR))
   3248              {
   3249                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   3250                __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
   3251              }
   3252          #endif /* USE_SPI_CRC */
   3253          
   3254              if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
   3255              {
   3256                /* Call user error callback */
   3257          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   3258                hspi->ErrorCallback(hspi);
   3259          #else
   3260                HAL_SPI_ErrorCallback(hspi);
   3261          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   3262                return;
   3263              }
   3264            }
   3265            /* Call user TxRx complete callback */
   3266          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   3267            hspi->TxRxCpltCallback(hspi);
   3268          #else
   3269            HAL_SPI_TxRxCpltCallback(hspi);
   3270          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   3271          }
   3272          
   3273          /**
   3274            * @brief  DMA SPI half transmit process complete callback.
   3275            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
   3276            *               the configuration information for the specified DMA module.
   3277            * @retval None
   3278            */
   3279          static void SPI_DMAHalfTransmitCplt(DMA_HandleTypeDef *hdma)
   3280          {
   3281            SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
   3282          
   3283            /* Call user Tx half complete callback */
   3284          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   3285            hspi->TxHalfCpltCallback(hspi);
   3286          #else
   3287            HAL_SPI_TxHalfCpltCallback(hspi);
   3288          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   3289          }
   3290          
   3291          /**
   3292            * @brief  DMA SPI half receive process complete callback
   3293            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
   3294            *               the configuration information for the specified DMA module.
   3295            * @retval None
   3296            */
   3297          static void SPI_DMAHalfReceiveCplt(DMA_HandleTypeDef *hdma)
   3298          {
   3299            SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
   3300          
   3301            /* Call user Rx half complete callback */
   3302          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   3303            hspi->RxHalfCpltCallback(hspi);
   3304          #else
   3305            HAL_SPI_RxHalfCpltCallback(hspi);
   3306          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   3307          }
   3308          
   3309          /**
   3310            * @brief  DMA SPI half transmit receive process complete callback.
   3311            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
   3312            *               the configuration information for the specified DMA module.
   3313            * @retval None
   3314            */
   3315          static void SPI_DMAHalfTransmitReceiveCplt(DMA_HandleTypeDef *hdma)
   3316          {
   3317            SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
   3318          
   3319            /* Call user TxRx half complete callback */
   3320          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   3321            hspi->TxRxHalfCpltCallback(hspi);
   3322          #else
   3323            HAL_SPI_TxRxHalfCpltCallback(hspi);
   3324          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   3325          }
   3326          
   3327          /**
   3328            * @brief  DMA SPI communication error callback.
   3329            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
   3330            *               the configuration information for the specified DMA module.
   3331            * @retval None
   3332            */
   3333          static void SPI_DMAError(DMA_HandleTypeDef *hdma)
   3334          {
   3335            SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
   3336          
   3337            /* Stop the disable DMA transfer on SPI side */
   3338            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
   3339          
   3340            SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
   3341            hspi->State = HAL_SPI_STATE_READY;
   3342            /* Call user error callback */
   3343          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   3344            hspi->ErrorCallback(hspi);
   3345          #else
   3346            HAL_SPI_ErrorCallback(hspi);
   3347          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   3348          }
   3349          
   3350          /**
   3351            * @brief  DMA SPI communication abort callback, when initiated by HAL services on Error
   3352            *         (To be called at end of DMA Abort procedure following error occurrence).
   3353            * @param  hdma DMA handle.
   3354            * @retval None
   3355            */
   3356          static void SPI_DMAAbortOnError(DMA_HandleTypeDef *hdma)
   3357          {
   3358            SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
   3359            hspi->RxXferCount = 0U;
   3360            hspi->TxXferCount = 0U;
   3361          
   3362            /* Call user error callback */
   3363          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   3364            hspi->ErrorCallback(hspi);
   3365          #else
   3366            HAL_SPI_ErrorCallback(hspi);
   3367          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   3368          }
   3369          
   3370          /**
   3371            * @brief  DMA SPI Tx communication abort callback, when initiated by user
   3372            *         (To be called at end of DMA Tx Abort procedure following user abort request).
   3373            * @note   When this callback is executed, User Abort complete call back is called only if no
   3374            *         Abort still ongoing for Rx DMA Handle.
   3375            * @param  hdma DMA handle.
   3376            * @retval None
   3377            */
   3378          static void SPI_DMATxAbortCallback(DMA_HandleTypeDef *hdma)
   3379          {
   3380            SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
   3381          
   3382            hspi->hdmatx->XferAbortCallback = NULL;
   3383          
   3384            /* Disable Tx DMA Request */
   3385            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
   3386          
   3387            if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, HAL_GetTick()) != HAL_OK)
   3388            {
   3389              hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
   3390            }
   3391          
   3392            /* Disable SPI Peripheral */
   3393            __HAL_SPI_DISABLE(hspi);
   3394          
   3395            /* Empty the FRLVL fifo */
   3396            if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, SPI_DEFAULT_TIMEOUT, HAL_GetTick()) != HAL_OK)
   3397            {
   3398              hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
   3399            }
   3400          
   3401            /* Check if an Abort process is still ongoing */
   3402            if (hspi->hdmarx != NULL)
   3403            {
   3404              if (hspi->hdmarx->XferAbortCallback != NULL)
   3405              {
   3406                return;
   3407              }
   3408            }
   3409          
   3410            /* No Abort process still ongoing : All DMA Stream/Channel are aborted, call user Abort Complete callback */
   3411            hspi->RxXferCount = 0U;
   3412            hspi->TxXferCount = 0U;
   3413          
   3414            /* Check no error during Abort procedure */
   3415            if (hspi->ErrorCode != HAL_SPI_ERROR_ABORT)
   3416            {
   3417              /* Reset errorCode */
   3418              hspi->ErrorCode = HAL_SPI_ERROR_NONE;
   3419            }
   3420          
   3421            /* Clear the Error flags in the SR register */
   3422            __HAL_SPI_CLEAR_OVRFLAG(hspi);
   3423            __HAL_SPI_CLEAR_FREFLAG(hspi);
   3424          
   3425            /* Restore hspi->State to Ready */
   3426            hspi->State  = HAL_SPI_STATE_READY;
   3427          
   3428            /* Call user Abort complete callback */
   3429          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   3430            hspi->AbortCpltCallback(hspi);
   3431          #else
   3432            HAL_SPI_AbortCpltCallback(hspi);
   3433          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   3434          }
   3435          
   3436          /**
   3437            * @brief  DMA SPI Rx communication abort callback, when initiated by user
   3438            *         (To be called at end of DMA Rx Abort procedure following user abort request).
   3439            * @note   When this callback is executed, User Abort complete call back is called only if no
   3440            *         Abort still ongoing for Tx DMA Handle.
   3441            * @param  hdma DMA handle.
   3442            * @retval None
   3443            */
   3444          static void SPI_DMARxAbortCallback(DMA_HandleTypeDef *hdma)
   3445          {
   3446            SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
   3447          
   3448            /* Disable SPI Peripheral */
   3449            __HAL_SPI_DISABLE(hspi);
   3450          
   3451            hspi->hdmarx->XferAbortCallback = NULL;
   3452          
   3453            /* Disable Rx DMA Request */
   3454            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
   3455          
   3456            /* Control the BSY flag */
   3457            if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, SPI_DEFAULT_TIMEOUT, HAL_GetTick()) != HAL_OK)
   3458            {
   3459              hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
   3460            }
   3461          
   3462            /* Empty the FRLVL fifo */
   3463            if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, SPI_DEFAULT_TIMEOUT, HAL_GetTick()) != HAL_OK)
   3464            {
   3465              hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
   3466            }
   3467          
   3468            /* Check if an Abort process is still ongoing */
   3469            if (hspi->hdmatx != NULL)
   3470            {
   3471              if (hspi->hdmatx->XferAbortCallback != NULL)
   3472              {
   3473                return;
   3474              }
   3475            }
   3476          
   3477            /* No Abort process still ongoing : All DMA Stream/Channel are aborted, call user Abort Complete callback */
   3478            hspi->RxXferCount = 0U;
   3479            hspi->TxXferCount = 0U;
   3480          
   3481            /* Check no error during Abort procedure */
   3482            if (hspi->ErrorCode != HAL_SPI_ERROR_ABORT)
   3483            {
   3484              /* Reset errorCode */
   3485              hspi->ErrorCode = HAL_SPI_ERROR_NONE;
   3486            }
   3487          
   3488            /* Clear the Error flags in the SR register */
   3489            __HAL_SPI_CLEAR_OVRFLAG(hspi);
   3490            __HAL_SPI_CLEAR_FREFLAG(hspi);
   3491          
   3492            /* Restore hspi->State to Ready */
   3493            hspi->State  = HAL_SPI_STATE_READY;
   3494          
   3495            /* Call user Abort complete callback */
   3496          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   3497            hspi->AbortCpltCallback(hspi);
   3498          #else
   3499            HAL_SPI_AbortCpltCallback(hspi);
   3500          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   3501          }
   3502          
   3503          /**
   3504            * @brief  Rx 8-bit handler for Transmit and Receive in Interrupt mode.
   3505            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3506            *               the configuration information for SPI module.
   3507            * @retval None
   3508            */
   3509          static void SPI_2linesRxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
   3510          {
   3511            /* Receive data in packing mode */
   3512            if (hspi->RxXferCount > 1U)
   3513            {
   3514              *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)(hspi->Instance->DR);
   3515              hspi->pRxBuffPtr += sizeof(uint16_t);
   3516              hspi->RxXferCount -= 2U;
   3517              if (hspi->RxXferCount == 1U)
   3518              {
   3519                /* Set RX Fifo threshold according the reception data length: 8bit */
   3520                SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   3521              }
   3522            }
   3523            /* Receive data in 8 Bit mode */
   3524            else
   3525            {
   3526              *hspi->pRxBuffPtr = *((__IO uint8_t *)&hspi->Instance->DR);
   3527              hspi->pRxBuffPtr++;
   3528              hspi->RxXferCount--;
   3529            }
   3530          
   3531            /* Check end of the reception */
   3532            if (hspi->RxXferCount == 0U)
   3533            {
   3534          #if (USE_SPI_CRC != 0U)
   3535              if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   3536              {
   3537                SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   3538                hspi->RxISR =  SPI_2linesRxISR_8BITCRC;
   3539                return;
   3540              }
   3541          #endif /* USE_SPI_CRC */
   3542          
   3543              /* Disable RXNE  and ERR interrupt */
   3544              __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
   3545          
   3546              if (hspi->TxXferCount == 0U)
   3547              {
   3548                SPI_CloseRxTx_ISR(hspi);
   3549              }
   3550            }
   3551          }
   3552          
   3553          #if (USE_SPI_CRC != 0U)
   3554          /**
   3555            * @brief  Rx 8-bit handler for Transmit and Receive in Interrupt mode.
   3556            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3557            *               the configuration information for SPI module.
   3558            * @retval None
   3559            */
   3560          static void SPI_2linesRxISR_8BITCRC(struct __SPI_HandleTypeDef *hspi)
   3561          {
   3562            __IO uint8_t  *ptmpreg8;
   3563            __IO uint8_t  tmpreg8 = 0;
   3564          
   3565            /* Initialize the 8bit temporary pointer */
   3566            ptmpreg8 = (__IO uint8_t *)&hspi->Instance->DR;
   3567            /* Read 8bit CRC to flush Data Register */
   3568            tmpreg8 = *ptmpreg8;
   3569            /* To avoid GCC warning */
   3570            UNUSED(tmpreg8);
   3571          
   3572            hspi->CRCSize--;
   3573          
   3574            /* Check end of the reception */
   3575            if (hspi->CRCSize == 0U)
   3576            {
   3577              /* Disable RXNE and ERR interrupt */
   3578              __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
   3579          
   3580              if (hspi->TxXferCount == 0U)
   3581              {
   3582                SPI_CloseRxTx_ISR(hspi);
   3583              }
   3584            }
   3585          }
   3586          #endif /* USE_SPI_CRC */
   3587          
   3588          /**
   3589            * @brief  Tx 8-bit handler for Transmit and Receive in Interrupt mode.
   3590            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3591            *               the configuration information for SPI module.
   3592            * @retval None
   3593            */
   3594          static void SPI_2linesTxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
   3595          {
   3596            /* Transmit data in packing Bit mode */
   3597            if (hspi->TxXferCount >= 2U)
   3598            {
   3599              hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
   3600              hspi->pTxBuffPtr += sizeof(uint16_t);
   3601              hspi->TxXferCount -= 2U;
   3602            }
   3603            /* Transmit data in 8 Bit mode */
   3604            else
   3605            {
   3606              *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
   3607              hspi->pTxBuffPtr++;
   3608              hspi->TxXferCount--;
   3609            }
   3610          
   3611            /* Check the end of the transmission */
   3612            if (hspi->TxXferCount == 0U)
   3613            {
   3614          #if (USE_SPI_CRC != 0U)
   3615              if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   3616              {
   3617                /* Set CRC Next Bit to send CRC */
   3618                SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   3619                /* Disable TXE interrupt */
   3620                __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
   3621                return;
   3622              }
   3623          #endif /* USE_SPI_CRC */
   3624          
   3625              /* Disable TXE interrupt */
   3626              __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
   3627          
   3628              if (hspi->RxXferCount == 0U)
   3629              {
   3630                SPI_CloseRxTx_ISR(hspi);
   3631              }
   3632            }
   3633          }
   3634          
   3635          /**
   3636            * @brief  Rx 16-bit handler for Transmit and Receive in Interrupt mode.
   3637            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3638            *               the configuration information for SPI module.
   3639            * @retval None
   3640            */
   3641          static void SPI_2linesRxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
   3642          {
   3643            /* Receive data in 16 Bit mode */
   3644            *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)(hspi->Instance->DR);
   3645            hspi->pRxBuffPtr += sizeof(uint16_t);
   3646            hspi->RxXferCount--;
   3647          
   3648            if (hspi->RxXferCount == 0U)
   3649            {
   3650          #if (USE_SPI_CRC != 0U)
   3651              if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   3652              {
   3653                hspi->RxISR =  SPI_2linesRxISR_16BITCRC;
   3654                return;
   3655              }
   3656          #endif /* USE_SPI_CRC */
   3657          
   3658              /* Disable RXNE interrupt */
   3659              __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE);
   3660          
   3661              if (hspi->TxXferCount == 0U)
   3662              {
   3663                SPI_CloseRxTx_ISR(hspi);
   3664              }
   3665            }
   3666          }
   3667          
   3668          #if (USE_SPI_CRC != 0U)
   3669          /**
   3670            * @brief  Manage the CRC 16-bit receive for Transmit and Receive in Interrupt mode.
   3671            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3672            *               the configuration information for SPI module.
   3673            * @retval None
   3674            */
   3675          static void SPI_2linesRxISR_16BITCRC(struct __SPI_HandleTypeDef *hspi)
   3676          {
   3677            __IO uint32_t tmpreg = 0U;
   3678          
   3679            /* Read 16bit CRC to flush Data Register */
   3680            tmpreg = READ_REG(hspi->Instance->DR);
   3681            /* To avoid GCC warning */
   3682            UNUSED(tmpreg);
   3683          
   3684            /* Disable RXNE interrupt */
   3685            __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE);
   3686          
   3687            SPI_CloseRxTx_ISR(hspi);
   3688          }
   3689          #endif /* USE_SPI_CRC */
   3690          
   3691          /**
   3692            * @brief  Tx 16-bit handler for Transmit and Receive in Interrupt mode.
   3693            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3694            *               the configuration information for SPI module.
   3695            * @retval None
   3696            */
   3697          static void SPI_2linesTxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
   3698          {
   3699            /* Transmit data in 16 Bit mode */
   3700            hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
   3701            hspi->pTxBuffPtr += sizeof(uint16_t);
   3702            hspi->TxXferCount--;
   3703          
   3704            /* Enable CRC Transmission */
   3705            if (hspi->TxXferCount == 0U)
   3706            {
   3707          #if (USE_SPI_CRC != 0U)
   3708              if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   3709              {
   3710                /* Set CRC Next Bit to send CRC */
   3711                SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   3712                /* Disable TXE interrupt */
   3713                __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
   3714                return;
   3715              }
   3716          #endif /* USE_SPI_CRC */
   3717          
   3718              /* Disable TXE interrupt */
   3719              __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
   3720          
   3721              if (hspi->RxXferCount == 0U)
   3722              {
   3723                SPI_CloseRxTx_ISR(hspi);
   3724              }
   3725            }
   3726          }
   3727          
   3728          #if (USE_SPI_CRC != 0U)
   3729          /**
   3730            * @brief  Manage the CRC 8-bit receive in Interrupt context.
   3731            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3732            *               the configuration information for SPI module.
   3733            * @retval None
   3734            */
   3735          static void SPI_RxISR_8BITCRC(struct __SPI_HandleTypeDef *hspi)
   3736          {
   3737            __IO uint8_t  *ptmpreg8;
   3738            __IO uint8_t  tmpreg8 = 0;
   3739          
   3740            /* Initialize the 8bit temporary pointer */
   3741            ptmpreg8 = (__IO uint8_t *)&hspi->Instance->DR;
   3742            /* Read 8bit CRC to flush Data Register */
   3743            tmpreg8 = *ptmpreg8;
   3744            /* To avoid GCC warning */
   3745            UNUSED(tmpreg8);
   3746          
   3747            hspi->CRCSize--;
   3748          
   3749            if (hspi->CRCSize == 0U)
   3750            {
   3751              SPI_CloseRx_ISR(hspi);
   3752            }
   3753          }
   3754          #endif /* USE_SPI_CRC */
   3755          
   3756          /**
   3757            * @brief  Manage the receive 8-bit in Interrupt context.
   3758            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3759            *               the configuration information for SPI module.
   3760            * @retval None
   3761            */
   3762          static void SPI_RxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
   3763          {
   3764            *hspi->pRxBuffPtr = (*(__IO uint8_t *)&hspi->Instance->DR);
   3765            hspi->pRxBuffPtr++;
   3766            hspi->RxXferCount--;
   3767          
   3768          #if (USE_SPI_CRC != 0U)
   3769            /* Enable CRC Transmission */
   3770            if ((hspi->RxXferCount == 1U) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
   3771            {
   3772              SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   3773            }
   3774          #endif /* USE_SPI_CRC */
   3775          
   3776            if (hspi->RxXferCount == 0U)
   3777            {
   3778          #if (USE_SPI_CRC != 0U)
   3779              if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   3780              {
   3781                hspi->RxISR =  SPI_RxISR_8BITCRC;
   3782                return;
   3783              }
   3784          #endif /* USE_SPI_CRC */
   3785              SPI_CloseRx_ISR(hspi);
   3786            }
   3787          }
   3788          
   3789          #if (USE_SPI_CRC != 0U)
   3790          /**
   3791            * @brief  Manage the CRC 16-bit receive in Interrupt context.
   3792            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3793            *               the configuration information for SPI module.
   3794            * @retval None
   3795            */
   3796          static void SPI_RxISR_16BITCRC(struct __SPI_HandleTypeDef *hspi)
   3797          {
   3798            __IO uint32_t tmpreg = 0U;
   3799          
   3800            /* Read 16bit CRC to flush Data Register */
   3801            tmpreg = READ_REG(hspi->Instance->DR);
   3802            /* To avoid GCC warning */
   3803            UNUSED(tmpreg);
   3804          
   3805            /* Disable RXNE and ERR interrupt */
   3806            __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
   3807          
   3808            SPI_CloseRx_ISR(hspi);
   3809          }
   3810          #endif /* USE_SPI_CRC */
   3811          
   3812          /**
   3813            * @brief  Manage the 16-bit receive in Interrupt context.
   3814            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3815            *               the configuration information for SPI module.
   3816            * @retval None
   3817            */
   3818          static void SPI_RxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
   3819          {
   3820            *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)(hspi->Instance->DR);
   3821            hspi->pRxBuffPtr += sizeof(uint16_t);
   3822            hspi->RxXferCount--;
   3823          
   3824          #if (USE_SPI_CRC != 0U)
   3825            /* Enable CRC Transmission */
   3826            if ((hspi->RxXferCount == 1U) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
   3827            {
   3828              SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   3829            }
   3830          #endif /* USE_SPI_CRC */
   3831          
   3832            if (hspi->RxXferCount == 0U)
   3833            {
   3834          #if (USE_SPI_CRC != 0U)
   3835              if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   3836              {
   3837                hspi->RxISR = SPI_RxISR_16BITCRC;
   3838                return;
   3839              }
   3840          #endif /* USE_SPI_CRC */
   3841              SPI_CloseRx_ISR(hspi);
   3842            }
   3843          }
   3844          
   3845          /**
   3846            * @brief  Handle the data 8-bit transmit in Interrupt mode.
   3847            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3848            *               the configuration information for SPI module.
   3849            * @retval None
   3850            */
   3851          static void SPI_TxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
   3852          {
   3853            *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
   3854            hspi->pTxBuffPtr++;
   3855            hspi->TxXferCount--;
   3856          
   3857            if (hspi->TxXferCount == 0U)
   3858            {
   3859          #if (USE_SPI_CRC != 0U)
   3860              if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   3861              {
   3862                /* Enable CRC Transmission */
   3863                SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   3864              }
   3865          #endif /* USE_SPI_CRC */
   3866              SPI_CloseTx_ISR(hspi);
   3867            }
   3868          }
   3869          
   3870          /**
   3871            * @brief  Handle the data 16-bit transmit in Interrupt mode.
   3872            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3873            *               the configuration information for SPI module.
   3874            * @retval None
   3875            */
   3876          static void SPI_TxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
   3877          {
   3878            /* Transmit data in 16 Bit mode */
   3879            hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
   3880            hspi->pTxBuffPtr += sizeof(uint16_t);
   3881            hspi->TxXferCount--;
   3882          
   3883            if (hspi->TxXferCount == 0U)
   3884            {
   3885          #if (USE_SPI_CRC != 0U)
   3886              if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   3887              {
   3888                /* Enable CRC Transmission */
   3889                SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   3890              }
   3891          #endif /* USE_SPI_CRC */
   3892              SPI_CloseTx_ISR(hspi);
   3893            }
   3894          }
   3895          
   3896          /**
   3897            * @brief  Handle SPI Communication Timeout.
   3898            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3899            *              the configuration information for SPI module.
   3900            * @param  Flag SPI flag to check
   3901            * @param  State flag state to check
   3902            * @param  Timeout Timeout duration
   3903            * @param  Tickstart tick start value
   3904            * @retval HAL status
   3905            */
   3906          static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, FlagStatus State,
   3907                                                                 uint32_t Timeout, uint32_t Tickstart)
   3908          {
   3909            __IO uint32_t count;
   3910            uint32_t tmp_timeout;
   3911            uint32_t tmp_tickstart;
   3912          
   3913            /* Adjust Timeout value  in case of end of transfer */
   3914            tmp_timeout   = Timeout - (HAL_GetTick() - Tickstart);
   3915            tmp_tickstart = HAL_GetTick();
   3916          
   3917            /* Calculate Timeout based on a software loop to avoid blocking issue if Systick is disabled */
   3918            count = tmp_timeout * ((SystemCoreClock * 32U) >> 20U);
   3919          
   3920            while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
   3921            {
   3922              if (Timeout != HAL_MAX_DELAY)
   3923              {
   3924                if (((HAL_GetTick() - tmp_tickstart) >= tmp_timeout) || (tmp_timeout == 0U))
   3925                {
   3926                  /* Disable the SPI and reset the CRC: the CRC value should be cleared
   3927                     on both master and slave sides in order to resynchronize the master
   3928                     and slave for their respective CRC calculation */
   3929          
   3930                  /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
   3931                  __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
   3932          
   3933                  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
   3934                                                               || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
   3935                  {
   3936                    /* Disable SPI peripheral */
   3937                    __HAL_SPI_DISABLE(hspi);
   3938                  }
   3939          
   3940                  /* Reset CRC Calculation */
   3941                  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   3942                  {
   3943                    SPI_RESET_CRC(hspi);
   3944                  }
   3945          
   3946                  hspi->State = HAL_SPI_STATE_READY;
   3947          
   3948                  /* Process Unlocked */
   3949                  __HAL_UNLOCK(hspi);
   3950          
   3951                  return HAL_TIMEOUT;
   3952                }
   3953                /* If Systick is disabled or not incremented, deactivate timeout to go in disable loop procedure */
   3954                if (count == 0U)
   3955                {
   3956                  tmp_timeout = 0U;
   3957                }
   3958                count--;
   3959              }
   3960            }
   3961          
   3962            return HAL_OK;
   3963          }
   3964          
   3965          /**
   3966            * @brief  Handle SPI FIFO Communication Timeout.
   3967            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3968            *              the configuration information for SPI module.
   3969            * @param  Fifo Fifo to check
   3970            * @param  State Fifo state to check
   3971            * @param  Timeout Timeout duration
   3972            * @param  Tickstart tick start value
   3973            * @retval HAL status
   3974            */
   3975          static HAL_StatusTypeDef SPI_WaitFifoStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Fifo, uint32_t State,
   3976                                                                 uint32_t Timeout, uint32_t Tickstart)
   3977          {
   3978            __IO uint32_t count;
   3979            uint32_t tmp_timeout;
   3980            uint32_t tmp_tickstart;
   3981            __IO uint8_t  *ptmpreg8;
   3982            __IO uint8_t  tmpreg8 = 0;
   3983          
   3984            /* Adjust Timeout value  in case of end of transfer */
   3985            tmp_timeout = Timeout - (HAL_GetTick() - Tickstart);
   3986            tmp_tickstart = HAL_GetTick();
   3987          
   3988            /* Initialize the 8bit temporary pointer */
   3989            ptmpreg8 = (__IO uint8_t *)&hspi->Instance->DR;
   3990          
   3991            /* Calculate Timeout based on a software loop to avoid blocking issue if Systick is disabled */
   3992            count = tmp_timeout * ((SystemCoreClock * 35U) >> 20U);
   3993          
   3994            while ((hspi->Instance->SR & Fifo) != State)
   3995            {
   3996              if ((Fifo == SPI_SR_FRLVL) && (State == SPI_FRLVL_EMPTY))
   3997              {
   3998                /* Flush Data Register by a blank read */
   3999                tmpreg8 = *ptmpreg8;
   4000                /* To avoid GCC warning */
   4001                UNUSED(tmpreg8);
   4002              }
   4003          
   4004              if (Timeout != HAL_MAX_DELAY)
   4005              {
   4006                if (((HAL_GetTick() - tmp_tickstart) >= tmp_timeout) || (tmp_timeout == 0U))
   4007                {
   4008                  /* Disable the SPI and reset the CRC: the CRC value should be cleared
   4009                     on both master and slave sides in order to resynchronize the master
   4010                     and slave for their respective CRC calculation */
   4011          
   4012                  /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
   4013                  __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
   4014          
   4015                  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
   4016                                                               || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
   4017                  {
   4018                    /* Disable SPI peripheral */
   4019                    __HAL_SPI_DISABLE(hspi);
   4020                  }
   4021          
   4022                  /* Reset CRC Calculation */
   4023                  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   4024                  {
   4025                    SPI_RESET_CRC(hspi);
   4026                  }
   4027          
   4028                  hspi->State = HAL_SPI_STATE_READY;
   4029          
   4030                  /* Process Unlocked */
   4031                  __HAL_UNLOCK(hspi);
   4032          
   4033                  return HAL_TIMEOUT;
   4034                }
   4035                /* If Systick is disabled or not incremented, deactivate timeout to go in disable loop procedure */
   4036                if (count == 0U)
   4037                {
   4038                  tmp_timeout = 0U;
   4039                }
   4040                count--;
   4041              }
   4042            }
   4043          
   4044            return HAL_OK;
   4045          }
   4046          
   4047          /**
   4048            * @brief  Handle the check of the RX transaction complete.
   4049            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   4050            *               the configuration information for SPI module.
   4051            * @param  Timeout Timeout duration
   4052            * @param  Tickstart tick start value
   4053            * @retval HAL status
   4054            */
   4055          static HAL_StatusTypeDef SPI_EndRxTransaction(SPI_HandleTypeDef *hspi,  uint32_t Timeout, uint32_t Tickstart)
   4056          {
   4057            if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
   4058                                                         || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
   4059            {
   4060              /* Disable SPI peripheral */
   4061              __HAL_SPI_DISABLE(hspi);
   4062            }
   4063          
   4064            /* Control the BSY flag */
   4065            if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
   4066            {
   4067              SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   4068              return HAL_TIMEOUT;
   4069            }
   4070          
   4071            if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
   4072                                                         || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
   4073            {
   4074              /* Empty the FRLVL fifo */
   4075              if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
   4076              {
   4077                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   4078                return HAL_TIMEOUT;
   4079              }
   4080            }
   4081            return HAL_OK;
   4082          }
   4083          
   4084          /**
   4085            * @brief  Handle the check of the RXTX or TX transaction complete.
   4086            * @param  hspi SPI handle
   4087            * @param  Timeout Timeout duration
   4088            * @param  Tickstart tick start value
   4089            * @retval HAL status
   4090            */
   4091          static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
   4092          {
   4093            /* Control if the TX fifo is empty */
   4094            if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
   4095            {
   4096              SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   4097              return HAL_TIMEOUT;
   4098            }
   4099          
   4100            /* Control the BSY flag */
   4101            if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
   4102            {
   4103              SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   4104              return HAL_TIMEOUT;
   4105            }
   4106          
   4107            /* Control if the RX fifo is empty */
   4108            if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
   4109            {
   4110              SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   4111              return HAL_TIMEOUT;
   4112            }
   4113          
   4114            return HAL_OK;
   4115          }
   4116          
   4117          /**
   4118            * @brief  Handle the end of the RXTX transaction.
   4119            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   4120            *               the configuration information for SPI module.
   4121            * @retval None
   4122            */
   4123          static void SPI_CloseRxTx_ISR(SPI_HandleTypeDef *hspi)
   4124          {
   4125            uint32_t tickstart;
   4126          
   4127            /* Init tickstart for timeout management */
   4128            tickstart = HAL_GetTick();
   4129          
   4130            /* Disable ERR interrupt */
   4131            __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
   4132          
   4133            /* Check the end of the transaction */
   4134            if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
   4135            {
   4136              SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   4137            }
   4138          
   4139          #if (USE_SPI_CRC != 0U)
   4140            /* Check if CRC error occurred */
   4141            if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
   4142            {
   4143              hspi->State = HAL_SPI_STATE_READY;
   4144              SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   4145              __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
   4146              /* Call user error callback */
   4147          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   4148              hspi->ErrorCallback(hspi);
   4149          #else
   4150              HAL_SPI_ErrorCallback(hspi);
   4151          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   4152            }
   4153            else
   4154            {
   4155          #endif /* USE_SPI_CRC */
   4156              if (hspi->ErrorCode == HAL_SPI_ERROR_NONE)
   4157              {
   4158                if (hspi->State == HAL_SPI_STATE_BUSY_RX)
   4159                {
   4160                  hspi->State = HAL_SPI_STATE_READY;
   4161                  /* Call user Rx complete callback */
   4162          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   4163                  hspi->RxCpltCallback(hspi);
   4164          #else
   4165                  HAL_SPI_RxCpltCallback(hspi);
   4166          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   4167                }
   4168                else
   4169                {
   4170                  hspi->State = HAL_SPI_STATE_READY;
   4171                  /* Call user TxRx complete callback */
   4172          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   4173                  hspi->TxRxCpltCallback(hspi);
   4174          #else
   4175                  HAL_SPI_TxRxCpltCallback(hspi);
   4176          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   4177                }
   4178              }
   4179              else
   4180              {
   4181                hspi->State = HAL_SPI_STATE_READY;
   4182                /* Call user error callback */
   4183          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   4184                hspi->ErrorCallback(hspi);
   4185          #else
   4186                HAL_SPI_ErrorCallback(hspi);
   4187          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   4188              }
   4189          #if (USE_SPI_CRC != 0U)
   4190            }
   4191          #endif /* USE_SPI_CRC */
   4192          }
   4193          
   4194          /**
   4195            * @brief  Handle the end of the RX transaction.
   4196            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   4197            *               the configuration information for SPI module.
   4198            * @retval None
   4199            */
   4200          static void SPI_CloseRx_ISR(SPI_HandleTypeDef *hspi)
   4201          {
   4202            /* Disable RXNE and ERR interrupt */
   4203            __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
   4204          
   4205            /* Check the end of the transaction */
   4206            if (SPI_EndRxTransaction(hspi, SPI_DEFAULT_TIMEOUT, HAL_GetTick()) != HAL_OK)
   4207            {
   4208              SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   4209            }
   4210            hspi->State = HAL_SPI_STATE_READY;
   4211          
   4212          #if (USE_SPI_CRC != 0U)
   4213            /* Check if CRC error occurred */
   4214            if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
   4215            {
   4216              SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   4217              __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
   4218              /* Call user error callback */
   4219          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   4220              hspi->ErrorCallback(hspi);
   4221          #else
   4222              HAL_SPI_ErrorCallback(hspi);
   4223          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   4224            }
   4225            else
   4226            {
   4227          #endif /* USE_SPI_CRC */
   4228              if (hspi->ErrorCode == HAL_SPI_ERROR_NONE)
   4229              {
   4230                /* Call user Rx complete callback */
   4231          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   4232                hspi->RxCpltCallback(hspi);
   4233          #else
   4234                HAL_SPI_RxCpltCallback(hspi);
   4235          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   4236              }
   4237              else
   4238              {
   4239                /* Call user error callback */
   4240          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   4241                hspi->ErrorCallback(hspi);
   4242          #else
   4243                HAL_SPI_ErrorCallback(hspi);
   4244          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   4245              }
   4246          #if (USE_SPI_CRC != 0U)
   4247            }
   4248          #endif /* USE_SPI_CRC */
   4249          }
   4250          
   4251          /**
   4252            * @brief  Handle the end of the TX transaction.
   4253            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   4254            *               the configuration information for SPI module.
   4255            * @retval None
   4256            */
   4257          static void SPI_CloseTx_ISR(SPI_HandleTypeDef *hspi)
   4258          {
   4259            uint32_t tickstart;
   4260          
   4261            /* Init tickstart for timeout management*/
   4262            tickstart = HAL_GetTick();
   4263          
   4264            /* Disable TXE and ERR interrupt */
   4265            __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_ERR));
   4266          
   4267            /* Check the end of the transaction */
   4268            if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
   4269            {
   4270              SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   4271            }
   4272          
   4273            /* Clear overrun flag in 2 Lines communication mode because received is not read */
   4274            if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
   4275            {
   4276              __HAL_SPI_CLEAR_OVRFLAG(hspi);
   4277            }
   4278          
   4279            hspi->State = HAL_SPI_STATE_READY;
   4280            if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
   4281            {
   4282              /* Call user error callback */
   4283          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   4284              hspi->ErrorCallback(hspi);
   4285          #else
   4286              HAL_SPI_ErrorCallback(hspi);
   4287          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   4288            }
   4289            else
   4290            {
   4291              /* Call user Rx complete callback */
   4292          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   4293              hspi->TxCpltCallback(hspi);
   4294          #else
   4295              HAL_SPI_TxCpltCallback(hspi);
   4296          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   4297            }
   4298          }
   4299          
   4300          /**
   4301            * @brief  Handle abort a Rx transaction.
   4302            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   4303            *               the configuration information for SPI module.
   4304            * @retval None
   4305            */
   4306          static void SPI_AbortRx_ISR(SPI_HandleTypeDef *hspi)
   4307          {
   4308            __IO uint32_t count;
   4309          
   4310            /* Disable SPI Peripheral */
   4311            __HAL_SPI_DISABLE(hspi);
   4312          
   4313            count = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
   4314          
   4315            /* Disable RXNEIE interrupt */
   4316            CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_RXNEIE));
   4317          
   4318            /* Check RXNEIE is disabled */
   4319            do
   4320            {
   4321              if (count == 0U)
   4322              {
   4323                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
   4324                break;
   4325              }
   4326              count--;
   4327            } while (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXNEIE));
   4328          
   4329            /* Control the BSY flag */
   4330            if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, SPI_DEFAULT_TIMEOUT, HAL_GetTick()) != HAL_OK)
   4331            {
   4332              hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
   4333            }
   4334          
   4335            /* Empty the FRLVL fifo */
   4336            if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, SPI_DEFAULT_TIMEOUT, HAL_GetTick()) != HAL_OK)
   4337            {
   4338              hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
   4339            }
   4340          
   4341            hspi->State = HAL_SPI_STATE_ABORT;
   4342          }
   4343          
   4344          /**
   4345            * @brief  Handle abort a Tx or Rx/Tx transaction.
   4346            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   4347            *               the configuration information for SPI module.
   4348            * @retval None
   4349            */
   4350          static void SPI_AbortTx_ISR(SPI_HandleTypeDef *hspi)
   4351          {
   4352            __IO uint32_t count;
   4353          
   4354            count = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
   4355          
   4356            /* Disable TXEIE interrupt */
   4357            CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXEIE));
   4358          
   4359            /* Check TXEIE is disabled */
   4360            do
   4361            {
   4362              if (count == 0U)
   4363              {
   4364                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
   4365                break;
   4366              }
   4367              count--;
   4368            } while (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXEIE));
   4369          
   4370            if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, HAL_GetTick()) != HAL_OK)
   4371            {
   4372              hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
   4373            }
   4374          
   4375            /* Disable SPI Peripheral */
   4376            __HAL_SPI_DISABLE(hspi);
   4377          
   4378            /* Empty the FRLVL fifo */
   4379            if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, SPI_DEFAULT_TIMEOUT, HAL_GetTick()) != HAL_OK)
   4380            {
   4381              hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
   4382            }
   4383          
   4384            /* Check case of Full-Duplex Mode and disable directly RXNEIE interrupt */
   4385            if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXNEIE))
   4386            {
   4387              /* Disable RXNEIE interrupt */
   4388              CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_RXNEIE));
   4389          
   4390              /* Check RXNEIE is disabled */
   4391              do
   4392              {
   4393                if (count == 0U)
   4394                {
   4395                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
   4396                  break;
   4397                }
   4398                count--;
   4399              } while (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXNEIE));
   4400          
   4401              /* Control the BSY flag */
   4402              if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, SPI_DEFAULT_TIMEOUT, HAL_GetTick()) != HAL_OK)
   4403              {
   4404                hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
   4405              }
   4406          
   4407              /* Empty the FRLVL fifo */
   4408              if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, SPI_DEFAULT_TIMEOUT, HAL_GetTick()) != HAL_OK)
   4409              {
   4410                hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
   4411              }
   4412            }
   4413            hspi->State = HAL_SPI_STATE_ABORT;
   4414          }
   4415          
   4416          /**
   4417            * @}
   4418            */
   4419          
   4420          #endif /* HAL_SPI_MODULE_ENABLED */
   4421          
   4422          /**
   4423            * @}
   4424            */
   4425          
   4426          /**
   4427            * @}
   4428            */
   4429          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   HAL_SPI_Abort
        32   -> HAL_DMA_Abort
        32   -> HAL_GetTick
        32   -> SPI_EndRxTxTransaction
        32   -> SPI_WaitFifoStateUntilTimeout
        32   -> SPI_WaitFlagStateUntilTimeout
        32 __aeabi_uidiv
       0   HAL_SPI_AbortCpltCallback
      40   HAL_SPI_Abort_IT
        40   -> HAL_DMA_Abort_IT
        40   -> HAL_SPI_AbortCpltCallback
        40 __aeabi_uidiv
       0   HAL_SPI_DMAPause
       0   HAL_SPI_DMAResume
      24   HAL_SPI_DMAStop
        24   -> HAL_DMA_Abort
       8   HAL_SPI_DeInit
         8   -> HAL_SPI_MspDeInit
       0   HAL_SPI_ErrorCallback
       0   HAL_SPI_GetError
       0   HAL_SPI_GetState
      32   HAL_SPI_IRQHandler
        32   -- Indirect call
        32   -> HAL_DMA_Abort_IT
        32   -> HAL_SPI_ErrorCallback
      24   HAL_SPI_Init
        24   -> HAL_SPI_MspInit
       0   HAL_SPI_MspDeInit
       0   HAL_SPI_MspInit
      40   HAL_SPI_Receive
        40   -> HAL_GetTick
        40   -> HAL_SPI_TransmitReceive
        40   -> SPI_EndRxTransaction
      32   HAL_SPI_Receive_DMA
        32   -> HAL_DMA_Start_IT
        32   -> HAL_SPI_TransmitReceive_DMA
      24   HAL_SPI_Receive_IT
        24   -> HAL_SPI_TransmitReceive_IT
       0   HAL_SPI_RxCpltCallback
       0   HAL_SPI_RxHalfCpltCallback
      40   HAL_SPI_Transmit
        40   -> HAL_GetTick
        40   -> SPI_EndRxTxTransaction
      40   HAL_SPI_TransmitReceive
        40   -> HAL_GetTick
        40   -> SPI_EndRxTxTransaction
      32   HAL_SPI_TransmitReceive_DMA
        32   -> HAL_DMA_Start_IT
      32   HAL_SPI_TransmitReceive_IT
      24   HAL_SPI_Transmit_DMA
        24   -> HAL_DMA_Start_IT
      20   HAL_SPI_Transmit_IT
       0   HAL_SPI_TxCpltCallback
       0   HAL_SPI_TxHalfCpltCallback
       0   HAL_SPI_TxRxCpltCallback
       0   HAL_SPI_TxRxHalfCpltCallback
       8   SPI_2linesRxISR_16BIT
         8   -> SPI_CloseRxTx_ISR
       8   SPI_2linesRxISR_8BIT
         8   -> SPI_CloseRxTx_ISR
       8   SPI_2linesTxISR_16BIT
         8   -> SPI_CloseRxTx_ISR
       8   SPI_2linesTxISR_8BIT
         8   -> SPI_CloseRxTx_ISR
      16   SPI_AbortRx_ISR
        16   -> HAL_GetTick
        16   -> SPI_WaitFifoStateUntilTimeout
        16   -> SPI_WaitFlagStateUntilTimeout
        16 __aeabi_uidiv
      32   SPI_AbortTx_ISR
        32   -> HAL_GetTick
        32   -> SPI_EndRxTxTransaction
        32   -> SPI_WaitFifoStateUntilTimeout
        32   -> SPI_WaitFlagStateUntilTimeout
        32 __aeabi_uidiv
       8   SPI_CloseRxTx_ISR
         8   -> HAL_GetTick
         8   -> HAL_SPI_ErrorCallback
         8   -> HAL_SPI_RxCpltCallback
         8   -> HAL_SPI_TxRxCpltCallback
         8   -> SPI_EndRxTxTransaction
       8   SPI_CloseRx_ISR
         8   -> HAL_GetTick
         8   -> HAL_SPI_ErrorCallback
         8   -> HAL_SPI_RxCpltCallback
         8   -> SPI_EndRxTransaction
      16   SPI_CloseTx_ISR
        16   -> HAL_GetTick
        16   -> HAL_SPI_ErrorCallback
        16   -> HAL_SPI_TxCpltCallback
        16   -> SPI_EndRxTxTransaction
       8   SPI_DMAAbortOnError
         8   -> HAL_SPI_ErrorCallback
       8   SPI_DMAError
         8   -> HAL_SPI_ErrorCallback
       8   SPI_DMAHalfReceiveCplt
         8   -> HAL_SPI_RxHalfCpltCallback
       8   SPI_DMAHalfTransmitCplt
         8   -> HAL_SPI_TxHalfCpltCallback
       8   SPI_DMAHalfTransmitReceiveCplt
         8   -> HAL_SPI_TxRxHalfCpltCallback
      16   SPI_DMAReceiveCplt
        16   -> HAL_GetTick
        16   -> HAL_SPI_ErrorCallback
        16   -> HAL_SPI_RxCpltCallback
        16   -> SPI_EndRxTransaction
      24   SPI_DMARxAbortCallback
        24   -> HAL_GetTick
        24   -> HAL_SPI_AbortCpltCallback
        24   -> SPI_WaitFifoStateUntilTimeout
        24   -> SPI_WaitFlagStateUntilTimeout
      24   SPI_DMATransmitCplt
        24   -> HAL_GetTick
        24   -> HAL_SPI_ErrorCallback
        24   -> HAL_SPI_TxCpltCallback
        24   -> SPI_EndRxTxTransaction
      16   SPI_DMATransmitReceiveCplt
        16   -> HAL_GetTick
        16   -> HAL_SPI_ErrorCallback
        16   -> HAL_SPI_TxRxCpltCallback
        16   -> SPI_EndRxTxTransaction
      24   SPI_DMATxAbortCallback
        24   -> HAL_GetTick
        24   -> HAL_SPI_AbortCpltCallback
        24   -> SPI_EndRxTxTransaction
        24   -> SPI_WaitFifoStateUntilTimeout
      32   SPI_EndRxTransaction
        32   -> SPI_WaitFifoStateUntilTimeout
        32   -> SPI_WaitFlagStateUntilTimeout
      24   SPI_EndRxTxTransaction
        24   -> SPI_WaitFifoStateUntilTimeout
        24   -> SPI_WaitFlagStateUntilTimeout
       8   SPI_RxISR_16BIT
         8   -> SPI_CloseRx_ISR
       8   SPI_RxISR_8BIT
         8   -> SPI_CloseRx_ISR
       8   SPI_TxISR_16BIT
         8   -> SPI_CloseTx_ISR
       8   SPI_TxISR_8BIT
         8   -> SPI_CloseTx_ISR
      48   SPI_WaitFifoStateUntilTimeout
        48   -> HAL_GetTick
      40   SPI_WaitFlagStateUntilTimeout
        40   -> HAL_GetTick


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_2
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable16
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable4
       4  ??DataTable5
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       8  ?Subroutine0
       8  ?Subroutine1
      10  ?Subroutine2
       8  ?Subroutine3
      10  ?Subroutine4
      60  ?Subroutine5
     376  HAL_SPI_Abort
       2  HAL_SPI_AbortCpltCallback
     326  HAL_SPI_Abort_IT
      30  HAL_SPI_DMAPause
      28  HAL_SPI_DMAResume
      72  HAL_SPI_DMAStop
      44  HAL_SPI_DeInit
       2  HAL_SPI_ErrorCallback
       4  HAL_SPI_GetError
       6  HAL_SPI_GetState
     266  HAL_SPI_IRQHandler
     260  HAL_SPI_Init
       2  HAL_SPI_MspDeInit
       2  HAL_SPI_MspInit
     416  HAL_SPI_Receive
     326  HAL_SPI_Receive_DMA
     200  HAL_SPI_Receive_IT
       2  HAL_SPI_RxCpltCallback
       2  HAL_SPI_RxHalfCpltCallback
     456  HAL_SPI_Transmit
     584  HAL_SPI_TransmitReceive
     402  HAL_SPI_TransmitReceive_DMA
     192  HAL_SPI_TransmitReceive_IT
     254  HAL_SPI_Transmit_DMA
     148  HAL_SPI_Transmit_IT
       2  HAL_SPI_TxCpltCallback
       2  HAL_SPI_TxHalfCpltCallback
       2  HAL_SPI_TxRxCpltCallback
       2  HAL_SPI_TxRxHalfCpltCallback
      50  SPI_2linesRxISR_16BIT
     106  SPI_2linesRxISR_8BIT
      44  SPI_2linesTxISR_16BIT
      74  SPI_2linesTxISR_8BIT
     136  SPI_AbortRx_ISR
     228  SPI_AbortTx_ISR
      80  SPI_CloseRxTx_ISR
      56  SPI_CloseRx_ISR
      88  SPI_CloseTx_ISR
      18  SPI_DMAAbortOnError
      34  SPI_DMAError
      10  SPI_DMAHalfReceiveCplt
      10  SPI_DMAHalfTransmitCplt
      10  SPI_DMAHalfTransmitReceiveCplt
     106  SPI_DMAReceiveCplt
      88  SPI_DMARxAbortCallback
     110  SPI_DMATransmitCplt
      90  SPI_DMATransmitReceiveCplt
      84  SPI_DMATxAbortCallback
     120  SPI_EndRxTransaction
      76  SPI_EndRxTxTransaction
      42  SPI_RxISR_16BIT
      42  SPI_RxISR_8BIT
      36  SPI_TxISR_16BIT
      36  SPI_TxISR_8BIT
     244  SPI_WaitFifoStateUntilTimeout
     198  SPI_WaitFlagStateUntilTimeout

 
 6'890 bytes in section .text
 
 6'870 bytes of CODE memory (+ 20 bytes shared)

Errors: none
Warnings: none
