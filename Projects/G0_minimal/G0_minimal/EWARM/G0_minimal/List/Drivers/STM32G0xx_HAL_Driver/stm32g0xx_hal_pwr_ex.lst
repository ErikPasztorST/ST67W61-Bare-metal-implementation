###############################################################################
#
# IAR ANSI C/C++ Compiler V9.20.1.318/W64 for ARM         20/Aug/2025  15:41:46
# Copyright 1999-2021 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\Drivers\STM32G0xx_HAL_Driver\Src\stm32g0xx_hal_pwr_ex.c
#    Command line      =
#        -f
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM\G0_minimal\Obj\Drivers\STM32G0xx_HAL_Driver\stm32g0xx_hal_pwr_ex.o.rsp
#        (C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\Drivers\STM32G0xx_HAL_Driver\Src\stm32g0xx_hal_pwr_ex.c
#        -D USE_HAL_DRIVER -D STM32G0B1xx -lcN
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM\G0_minimal\List\Drivers\STM32G0xx_HAL_Driver
#        -o
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM\G0_minimal\Obj\Drivers\STM32G0xx_HAL_Driver
#        --debug --endian=little --cpu=Cortex-M0+ -e --fpu=None --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.0\arm\inc\c\DLib_Config_Full.h" -I
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM/../Core/Inc\ -I
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM/../ST67W6X/Target\
#        -I
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM/../ST67W6X/Drivers\
#        -I
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM/../Drivers/STM32G0xx_HAL_Driver/Inc\
#        -I
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM/../Drivers/STM32G0xx_HAL_Driver/Inc/Legacy\
#        -I
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM/../Drivers/CMSIS/Device/ST/STM32G0xx/Include\
#        -I
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM/../Drivers/CMSIS/Include\
#        -Ohz) --dependencies=n
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM\G0_minimal\Obj\Drivers\STM32G0xx_HAL_Driver\stm32g0xx_hal_pwr_ex.o.d
#    Locale            =  C
#    List file         =
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM\G0_minimal\List\Drivers\STM32G0xx_HAL_Driver\stm32g0xx_hal_pwr_ex.lst
#    Object file       =
#        C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\EWARM\G0_minimal\Obj\Drivers\STM32G0xx_HAL_Driver\stm32g0xx_hal_pwr_ex.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\X-CUBE-ST67\Projects\G0_minimal\G0_minimal\Drivers\STM32G0xx_HAL_Driver\Src\stm32g0xx_hal_pwr_ex.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32g0xx_hal_pwr_ex.c
      4            * @author  MCD Application Team
      5            * @brief   Extended PWR HAL module driver.
      6            *          This file provides firmware functions to manage the following
      7            *          functionalities of the Power Controller (PWR) peripheral:
      8            *           + Extended Initialization and de-initialization functions
      9            *           + Extended Peripheral Control functions
     10            *
     11            ******************************************************************************
     12            * @attention
     13            *
     14            * Copyright (c) 2018 STMicroelectronics.
     15            * All rights reserved.
     16            *
     17            * This software is licensed under terms that can be found in the LICENSE file
     18            * in the root directory of this software component.
     19            * If no LICENSE file comes with this software, it is provided AS-IS.
     20            *
     21            ******************************************************************************
     22            */
     23          
     24          /* Includes ------------------------------------------------------------------*/
     25          #include "stm32g0xx_hal.h"
     26          
     27          /** @addtogroup STM32G0xx_HAL_Driver
     28            * @{
     29            */
     30          
     31          /** @addtogroup PWREx
     32            * @{
     33            */
     34          
     35          #ifdef HAL_PWR_MODULE_ENABLED
     36          
     37          /* Private typedef -----------------------------------------------------------*/
     38          /* Private define ------------------------------------------------------------*/
     39          /** @defgroup PWR_Extended_Private_Defines PWR Extended Private Defines
     40            * @{
     41            */
     42          
     43          #if defined(PWR_PVD_SUPPORT)
     44          /** @defgroup PWR_PVD_Mode_Mask PWR PVD Mode Mask
     45            * @{
     46            */
     47          #define PVD_MODE_IT           0x00010000U  /*!< Mask for interruption yielded
     48                                                          by PVD threshold crossing     */
     49          #define PVD_MODE_EVT          0x00020000U  /*!< Mask for event yielded
     50                                                          by PVD threshold crossing     */
     51          #define PVD_RISING_EDGE       0x00000001U  /*!< Mask for rising edge set as
     52                                                          PVD trigger                   */
     53          #define PVD_FALLING_EDGE      0x00000002U  /*!< Mask for falling edge set as
     54                                                          PVD trigger                   */
     55          /**
     56            * @}
     57            */
     58          #endif /* PWR_PVD_SUPPORT */
     59          
     60          /** @defgroup PWREx_TimeOut_Value  PWREx Flag Setting Time Out Value
     61            * @{
     62            */
     63          #define PWR_REGLPF_SETTING_DELAY_6_US       6u  /*!< REGLPF should rise in about 5 us plus
     64                                                               2 APB clock. Taking in account max Sysclk at
     65                                                               2 MHz, and rounded to upper value */
     66          
     67          #define PWR_VOSF_SETTING_DELAY_6_US         6u  /*!< VOSF should rise in about 5 us plus
     68                                                               2 APB clock. Taking in account max Sysclk at
     69                                                               16 MHz, and rounded to upper value */
     70          /**
     71            * @}
     72            */
     73          
     74          /** @defgroup PWREx_Gpio_Pin_Number  PWREx Gpio Pin Number
     75            * @{
     76            */
     77          #define PWR_GPIO_PIN_NB                     16u  /*!< Number of gpio pin in bank */
     78          /**
     79            * @}
     80            */
     81          
     82          /**
     83            * @}
     84            */
     85          
     86          /* Private macro -------------------------------------------------------------*/
     87          /* Private variables ---------------------------------------------------------*/
     88          /* Private function prototypes -----------------------------------------------*/
     89          /* Exported functions --------------------------------------------------------*/
     90          /** @addtogroup PWREx_Exported_Functions PWR Extended Exported Functions
     91            * @{
     92            */
     93          
     94          /** @addtogroup PWREx_Exported_Functions_Group1 Extended Peripheral Control functions
     95            *  @brief   Extended Peripheral Control functions
     96            *
     97          @verbatim
     98           ===============================================================================
     99            ##### Extended Peripheral Initialization and de-initialization functions #####
    100           ===============================================================================
    101              [..]
    102               *** PVD configuration ***
    103              =========================
    104              [..]
    105                (+) The PVD is used to monitor the VDD power supply by comparing it to a
    106                    threshold selected by the PVD Level (PVDRT[2:0] & PVDFT[2:0] bits in
    107                    PWR CR2 register).
    108                (+) PVDO flag is available to indicate if VDD/VDDA is higher or lower
    109                    than the PVD threshold. This event is internally connected to the EXTI
    110                    line 16 and can generate an interrupt if enabled.
    111                (+) The PVD is stopped in Standby & Shutdown mode.
    112          
    113               *** PVM configuration ***
    114              =========================
    115              [..]
    116          
    117          @endverbatim
    118            * @{
    119            */
    120          
    121          /**
    122            * @brief  Enable battery charging.
    123            * @note   When VDD is present, charge the external battery on VBAT through an
    124            *         internal resistor.
    125            * @param  ResistorSelection specifies the resistor impedance.
    126            *         This parameter can be one of the following values:
    127            *           @arg @ref PWR_BATTERY_CHARGING_RESISTOR_5     5 kOhms resistor
    128            *           @arg @ref PWR_BATTERY_CHARGING_RESISTOR_1_5 1.5 kOhms resistor
    129            * @retval None
    130            */
    131          void HAL_PWREx_EnableBatteryCharging(uint32_t ResistorSelection)
    132          {
    133            uint32_t tmpreg;
    134            assert_param(IS_PWR_BATTERY_RESISTOR_SELECT(ResistorSelection));
    135          
    136            /* Specify resistor selection and enable battery charging */
    137            tmpreg = (PWR->CR4 & ~PWR_CR4_VBRS);
    138            PWR->CR4 = (tmpreg | ResistorSelection | PWR_CR4_VBE);
    139          }
    140          
    141          
    142          /**
    143            * @brief Disable battery charging.
    144            * @retval None
    145            */
    146          void HAL_PWREx_DisableBatteryCharging(void)
    147          {
    148            CLEAR_BIT(PWR->CR4, PWR_CR4_VBE);
    149          }
    150          
    151          #if defined(PWR_CR3_ENB_ULP)
    152          /**
    153            * @brief  Enable POR Monitor sampling mode.
    154            * @note   When entering ultra low power modes (standby, shutdown) this feature
    155            *         can be enabled to reduce further consumption: Power On Reset monitor
    156            *         is then set in sampling mode, and no more in always on mode.
    157            * @retval None
    158            */
    159          void HAL_PWREx_EnablePORMonitorSampling(void)
    160          {
    161            PWR->CR3 |= PWR_CR3_ENB_ULP;
    162          }
    163          
    164          
    165          /**
    166            * @brief  Disable POR Monitor sampling mode.
    167            * @retval None
    168            */
    169          void HAL_PWREx_DisablePORMonitorSampling(void)
    170          {
    171            PWR->CR3 &= ~PWR_CR3_ENB_ULP;
    172          }
    173          #endif /* PWR_CR3_ENB_ULP */
    174          
    175          #if defined(PWR_PVD_SUPPORT)
    176          /**
    177            * @brief  Configure the Power Voltage Detector (PVD).
    178            * @param  sConfigPVD pointer to a PWR_PVDTypeDef structure that contains the
    179                      PVD configuration information: threshold levels, operating mode.
    180            * @note   Refer to the electrical characteristics of your device datasheet for
    181            *         more details about the voltage thresholds corresponding to each
    182            *         detection level.
    183            * @note   User should take care that rising threshold is higher than falling
    184            *         one in order to avoid having always PVDO output set.
    185            * @retval HAL_OK
    186            */
    187          HAL_StatusTypeDef HAL_PWREx_ConfigPVD(PWR_PVDTypeDef *sConfigPVD)
    188          {
    189            /* Check the parameters */
    190            assert_param(IS_PWR_PVD_LEVEL(sConfigPVD->PVDLevel));
    191            assert_param(IS_PWR_PVD_MODE(sConfigPVD->Mode));
    192          
    193            /* Set PVD level bits only according to PVDLevel value */
    194            MODIFY_REG(PWR->CR2, (PWR_CR2_PVDFT | PWR_CR2_PVDRT), sConfigPVD->PVDLevel);
    195          
    196            /* Clear any previous config, in case no event or IT mode is selected */
    197            __HAL_PWR_PVD_EXTI_DISABLE_EVENT();
    198            __HAL_PWR_PVD_EXTI_DISABLE_IT();
    199            __HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE();
    200            __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE();
    201          
    202            /* Configure interrupt mode */
    203            if ((sConfigPVD->Mode & PVD_MODE_IT) == PVD_MODE_IT)
    204            {
    205              __HAL_PWR_PVD_EXTI_ENABLE_IT();
    206            }
    207          
    208            /* Configure event mode */
    209            if ((sConfigPVD->Mode & PVD_MODE_EVT) == PVD_MODE_EVT)
    210            {
    211              __HAL_PWR_PVD_EXTI_ENABLE_EVENT();
    212            }
    213          
    214            /* Configure the edge */
    215            if ((sConfigPVD->Mode & PVD_RISING_EDGE) == PVD_RISING_EDGE)
    216            {
    217              __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE();
    218            }
    219          
    220            if ((sConfigPVD->Mode & PVD_FALLING_EDGE) == PVD_FALLING_EDGE)
    221            {
    222              __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE();
    223            }
    224          
    225            return HAL_OK;
    226          }
    227          
    228          
    229          /**
    230            * @brief  Enable the Power Voltage Detector (PVD).
    231            * @retval None
    232            */
    233          void HAL_PWREx_EnablePVD(void)
    234          {
    235            SET_BIT(PWR->CR2, PWR_CR2_PVDE);
    236          }
    237          
    238          
    239          /**
    240            * @brief  Disable the Power Voltage Detector (PVD).
    241            * @retval None
    242            */
    243          void HAL_PWREx_DisablePVD(void)
    244          {
    245            CLEAR_BIT(PWR->CR2, PWR_CR2_PVDE);
    246          }
    247          #endif /* PWR_PVD_SUPPORT */
    248          
    249          #if defined(PWR_CR2_USV)
    250          /**
    251            * @brief Enable VDDUSB supply.
    252            * @note  Remove VDDUSB electrical and logical isolation, once VDDUSB supply is present.
    253            * @retval None
    254            */
    255          void HAL_PWREx_EnableVddUSB(void)
    256          {
    257            SET_BIT(PWR->CR2, PWR_CR2_USV);
    258          }
    259          
    260          /**
    261            * @brief Disable VDDUSB supply.
    262            * @retval None
    263            */
    264          void HAL_PWREx_DisableVddUSB(void)
    265          {
    266            CLEAR_BIT(PWR->CR2, PWR_CR2_USV);
    267          }
    268          #endif /* PWR_CR2_USV */
    269          
    270          #if defined(PWR_CR2_IOSV)
    271          /**
    272            * @brief Enable VDDIO2 supply.
    273            * @note  Remove VDDIO2 electrical and logical isolation, once VDDIO2 supply is present.
    274            * @retval None
    275            */
    276          void HAL_PWREx_EnableVddIO2(void)
    277          {
    278            SET_BIT(PWR->CR2, PWR_CR2_IOSV);
    279          }
    280          
    281          
    282          /**
    283            * @brief Disable VDDIO2 supply.
    284            * @retval None
    285            */
    286          void HAL_PWREx_DisableVddIO2(void)
    287          {
    288            CLEAR_BIT(PWR->CR2, PWR_CR2_IOSV);
    289          }
    290          #endif /* PWR_CR2_IOSV */
    291          
    292          #if defined (PWR_PVM_SUPPORT)
    293          /**
    294            * @brief Enable the Power Voltage Monitoring for USB peripheral (power domain Vddio2)
    295            * @retval None
    296            */
    297          void HAL_PWREx_EnablePVMUSB(void)
    298          {
    299            SET_BIT(PWR->CR2, PWR_PVM_USB);
    300          }
    301          
    302          /**
    303            * @brief Disable the Power Voltage Monitoring for USB peripheral (power domain Vddio2)
    304            * @retval None
    305            */
    306          void HAL_PWREx_DisablePVMUSB(void)
    307          {
    308            CLEAR_BIT(PWR->CR2, PWR_PVM_USB);
    309          }
    310          #endif /* PWR_PVM_SUPPORT */
    311          
    312          #if defined(PWR_PVM_SUPPORT)
    313          /**
    314            * @brief Configure the Peripheral Voltage Monitoring (PVM).
    315            * @param sConfigPVM: pointer to a PWR_PVMTypeDef structure that contains the
    316            *        PVM configuration information.
    317            * @note The API configures a single PVM according to the information contained
    318            *       in the input structure. To configure several PVMs, the API must be singly
    319            *       called for each PVM used.
    320            * @note Refer to the electrical characteristics of your device datasheet for
    321            *         more details about the voltage thresholds corresponding to each
    322            *         detection level and to each monitored supply.
    323            * @retval HAL status
    324            */
    325          HAL_StatusTypeDef HAL_PWREx_ConfigPVM(PWR_PVMTypeDef *sConfigPVM)
    326          {
    327            HAL_StatusTypeDef status = HAL_OK;
    328          
    329            /* Check the parameters */
    330            assert_param(IS_PWR_PVM_TYPE(sConfigPVM->PVMType));
    331            assert_param(IS_PWR_PVM_MODE(sConfigPVM->Mode));
    332          
    333            /* Configure EXTI 34 interrupts if so required:
    334               scan through PVMType to detect which PVMx is set and
    335               configure the corresponding EXTI line accordingly. */
    336            switch (sConfigPVM->PVMType)
    337            {
    338              case PWR_PVM_USB:
    339                /* Clear any previous config. Keep it clear if no event or IT mode is selected */
    340                __HAL_PWR_PVM_EXTI_DISABLE_EVENT();
    341                __HAL_PWR_PVM_EXTI_DISABLE_IT();
    342                __HAL_PWR_PVM_EXTI_DISABLE_FALLING_EDGE();
    343                __HAL_PWR_PVM_EXTI_DISABLE_RISING_EDGE();
    344          
    345                /* Configure interrupt mode */
    346                if ((sConfigPVM->Mode & PVM_MODE_IT) == PVM_MODE_IT)
    347                {
    348                  __HAL_PWR_PVM_EXTI_ENABLE_IT();
    349                }
    350          
    351                /* Configure event mode */
    352                if ((sConfigPVM->Mode & PVM_MODE_EVT) == PVM_MODE_EVT)
    353                {
    354                  __HAL_PWR_PVM_EXTI_ENABLE_EVENT();
    355                }
    356          
    357                /* Configure the edge */
    358                if ((sConfigPVM->Mode & PVM_RISING_EDGE) == PVM_RISING_EDGE)
    359                {
    360                  __HAL_PWR_PVM_EXTI_ENABLE_RISING_EDGE();
    361                }
    362          
    363                if ((sConfigPVM->Mode & PVM_FALLING_EDGE) == PVM_FALLING_EDGE)
    364                {
    365                  __HAL_PWR_PVM_EXTI_ENABLE_FALLING_EDGE();
    366                }
    367                break;
    368          
    369              default:
    370                status = HAL_ERROR;
    371                break;
    372            }
    373          
    374            return status;
    375          }
    376          #endif /* PWR_PVM_SUPPORT */
    377          /**
    378            * @brief  Enable Internal Wake-up Line.
    379            * @retval None
    380            */
    381          void HAL_PWREx_EnableInternalWakeUpLine(void)
    382          {
    383            SET_BIT(PWR->CR3, PWR_CR3_EIWUL);
    384          }
    385          
    386          /**
    387            * @brief  Disable Internal Wake-up Line.
    388            * @retval None
    389            */
    390          void HAL_PWREx_DisableInternalWakeUpLine(void)
    391          {
    392            CLEAR_BIT(PWR->CR3, PWR_CR3_EIWUL);
    393          }
    394          
    395          /**
    396            * @brief  Enable GPIO pull-up state in Standby and Shutdown modes.
    397            * @note   Set the relevant PUy bit of PWR_PUCRx register to configure the I/O in
    398            *         pull-up state in Standby and Shutdown modes.
    399            * @note   This state is effective in Standby and Shutdown modes only if APC bit
    400            *         is set through HAL_PWREx_EnablePullUpPullDownConfig() API.
    401            * @note   The configuration is lost when exiting the Shutdown mode due to the
    402            *         power-on reset, maintained when exiting the Standby mode.
    403            * @note   To avoid any conflict at Standby and Shutdown modes exits, the corresponding
    404            *         PDy bit of PWR_PDCRx register is cleared unless it is reserved.
    405            * @param  GPIO Specify the IO port. This parameter can be PWR_GPIO_A, ..., PWR_GPIO_F
    406            *         to select the GPIO peripheral.
    407            * @param  GPIONumber Specify the I/O pins numbers.
    408            *         This parameter can be one of the following values:
    409            *         PWR_GPIO_BIT_0, ..., PWR_GPIO_BIT_15 (except for ports where less
    410            *         I/O pins are available) or the logical OR of several of them to set
    411            *         several bits for a given port in a single API call.
    412            * @retval HAL Status
    413            */
    414          HAL_StatusTypeDef HAL_PWREx_EnableGPIOPullUp(uint32_t GPIO, uint32_t GPIONumber)
    415          {
    416            HAL_StatusTypeDef status = HAL_OK;
    417          
    418            assert_param(IS_PWR_GPIO(GPIO));
    419            assert_param(IS_PWR_GPIO_BIT_NUMBER(GPIONumber));
    420          
    421            switch (GPIO)
    422            {
    423              case PWR_GPIO_A:
    424                SET_BIT(PWR->PUCRA, (GPIONumber & ~PWR_GPIO_BIT_14));
    425                CLEAR_BIT(PWR->PDCRA, (GPIONumber & ~PWR_GPIO_BIT_13));
    426                break;
    427          
    428              case PWR_GPIO_B:
    429                SET_BIT(PWR->PUCRB, GPIONumber);
    430                CLEAR_BIT(PWR->PDCRB, GPIONumber);
    431                break;
    432          
    433              case PWR_GPIO_C:
    434                SET_BIT(PWR->PUCRC, GPIONumber);
    435                CLEAR_BIT(PWR->PDCRC, GPIONumber);
    436                break;
    437          
    438              case PWR_GPIO_D:
    439                SET_BIT(PWR->PUCRD, GPIONumber);
    440                CLEAR_BIT(PWR->PDCRD, GPIONumber);
    441                break;
    442          
    443          #if defined(GPI0E)
    444              case PWR_GPIO_E:
    445                SET_BIT(PWR->PUCRE, GPIONumber);
    446                CLEAR_BIT(PWR->PDCRE, GPIONumber);
    447                break;
    448          #endif /* GPI0E */
    449              case PWR_GPIO_F:
    450                SET_BIT(PWR->PUCRF, GPIONumber);
    451                CLEAR_BIT(PWR->PDCRF, GPIONumber);
    452                break;
    453          
    454              default:
    455                status = HAL_ERROR;
    456                break;
    457            }
    458          
    459            return status;
    460          }
    461          
    462          
    463          /**
    464            * @brief  Disable GPIO pull-up state in Standby mode and Shutdown modes.
    465            * @note   Reset the relevant PUy bit of PWR_PUCRx register used to configure the I/O
    466            *         in pull-up state in Standby and Shutdown modes.
    467            * @param  GPIO Specifies the IO port. This parameter can be PWR_GPIO_A, ..., PWR_GPIO_F
    468            *         to select the GPIO peripheral.
    469            * @param  GPIONumber Specify the I/O pins numbers.
    470            *         This parameter can be one of the following values:
    471            *         PWR_GPIO_BIT_0, ..., PWR_GPIO_BIT_15 (except for ports where less
    472            *         I/O pins are available) or the logical OR of several of them to reset
    473            *         several bits for a given port in a single API call.
    474            * @retval HAL Status
    475            */
    476          HAL_StatusTypeDef HAL_PWREx_DisableGPIOPullUp(uint32_t GPIO, uint32_t GPIONumber)
    477          {
    478            HAL_StatusTypeDef status = HAL_OK;
    479          
    480            assert_param(IS_PWR_GPIO(GPIO));
    481            assert_param(IS_PWR_GPIO_BIT_NUMBER(GPIONumber));
    482          
    483            switch (GPIO)
    484            {
    485              case PWR_GPIO_A:
    486                CLEAR_BIT(PWR->PUCRA, (GPIONumber & ~PWR_GPIO_BIT_14));
    487                break;
    488          
    489              case PWR_GPIO_B:
    490                CLEAR_BIT(PWR->PUCRB, GPIONumber);
    491                break;
    492          
    493              case PWR_GPIO_C:
    494                CLEAR_BIT(PWR->PUCRC, GPIONumber);
    495                break;
    496          
    497              case PWR_GPIO_D:
    498                CLEAR_BIT(PWR->PUCRD, GPIONumber);
    499                break;
    500          
    501          #if defined(GPI0E)
    502              case PWR_GPIO_E:
    503                CLEAR_BIT(PWR->PUCRE, GPIONumber);
    504                break;
    505          #endif /* GPI0E */
    506              case PWR_GPIO_F:
    507                CLEAR_BIT(PWR->PUCRF, GPIONumber);
    508                break;
    509          
    510              default:
    511                status = HAL_ERROR;
    512                break;
    513            }
    514          
    515            return status;
    516          }
    517          
    518          
    519          /**
    520            * @brief  Enable GPIO pull-down state in Standby and Shutdown modes.
    521            * @note   Set the relevant PDy bit of PWR_PDCRx register to configure the I/O in
    522            *         pull-down state in Standby and Shutdown modes.
    523            * @note   This state is effective in Standby and Shutdown modes only if APC bit
    524            *         is set through HAL_PWREx_EnablePullUpPullDownConfig() API.
    525            * @note   The configuration is lost when exiting the Shutdown mode due to the
    526            *         power-on reset, maintained when exiting the Standby mode.
    527            * @note   To avoid any conflict at Standby and Shutdown modes exits, the corresponding
    528            *         PUy bit of PWR_PUCRx register is cleared unless it is reserved.
    529            * @param  GPIO Specify the IO port. This parameter can be PWR_GPIO_A..PWR_GPIO_F
    530            *         to select the GPIO peripheral.
    531            * @param  GPIONumber Specify the I/O pins numbers.
    532            *         This parameter can be one of the following values:
    533            *         PWR_GPIO_BIT_0, ..., PWR_GPIO_BIT_15 (except for ports where less
    534            *         I/O pins are available) or the logical OR of several of them to set
    535            *         several bits for a given port in a single API call.
    536            * @retval HAL Status
    537            */
    538          HAL_StatusTypeDef HAL_PWREx_EnableGPIOPullDown(uint32_t GPIO, uint32_t GPIONumber)
    539          {
    540            HAL_StatusTypeDef status = HAL_OK;
    541          
    542            assert_param(IS_PWR_GPIO(GPIO));
    543            assert_param(IS_PWR_GPIO_BIT_NUMBER(GPIONumber));
    544          
    545            switch (GPIO)
    546            {
    547              case PWR_GPIO_A:
    548                SET_BIT(PWR->PDCRA, (GPIONumber & ~PWR_GPIO_BIT_13));
    549                CLEAR_BIT(PWR->PUCRA, (GPIONumber & ~PWR_GPIO_BIT_14));
    550                break;
    551          
    552              case PWR_GPIO_B:
    553                SET_BIT(PWR->PDCRB, GPIONumber);
    554                CLEAR_BIT(PWR->PUCRB, GPIONumber);
    555                break;
    556          
    557              case PWR_GPIO_C:
    558                SET_BIT(PWR->PDCRC, GPIONumber);
    559                CLEAR_BIT(PWR->PUCRC, GPIONumber);
    560                break;
    561          
    562              case PWR_GPIO_D:
    563                SET_BIT(PWR->PDCRD, GPIONumber);
    564                CLEAR_BIT(PWR->PUCRD, GPIONumber);
    565                break;
    566          
    567          #if defined(GPIOE)
    568              case PWR_GPIO_E:
    569                SET_BIT(PWR->PDCRE, GPIONumber);
    570                CLEAR_BIT(PWR->PUCRE, GPIONumber);
    571                break;
    572          #endif /* GPI0E */
    573              case PWR_GPIO_F:
    574                SET_BIT(PWR->PDCRF, GPIONumber);
    575                CLEAR_BIT(PWR->PUCRF, GPIONumber);
    576                break;
    577          
    578              default:
    579                status = HAL_ERROR;
    580                break;
    581            }
    582          
    583            return status;
    584          }
    585          
    586          
    587          /**
    588            * @brief  Disable GPIO pull-down state in Standby and Shutdown modes.
    589            * @note   Reset the relevant PDy bit of PWR_PDCRx register used to configure the I/O
    590            *         in pull-down state in Standby and Shutdown modes.
    591            * @param  GPIO Specifies the IO port. This parameter can be PWR_GPIO_A..PWR_GPIO_F
    592            *         to select the GPIO peripheral.
    593            * @param  GPIONumber Specify the I/O pins numbers.
    594            *         This parameter can be one of the following values:
    595            *         PWR_GPIO_BIT_0, ..., PWR_GPIO_BIT_15 (except for ports where less
    596            *         I/O pins are available) or the logical OR of several of them to reset
    597            *         several bits for a given port in a single API call.
    598            * @retval HAL Status
    599            */
    600          HAL_StatusTypeDef HAL_PWREx_DisableGPIOPullDown(uint32_t GPIO, uint32_t GPIONumber)
    601          {
    602            HAL_StatusTypeDef status = HAL_OK;
    603          
    604            assert_param(IS_PWR_GPIO(GPIO));
    605            assert_param(IS_PWR_GPIO_BIT_NUMBER(GPIONumber));
    606          
    607            switch (GPIO)
    608            {
    609              case PWR_GPIO_A:
    610                CLEAR_BIT(PWR->PDCRA, (GPIONumber & ~PWR_GPIO_BIT_13));
    611                break;
    612          
    613              case PWR_GPIO_B:
    614                CLEAR_BIT(PWR->PDCRB, GPIONumber);
    615                break;
    616          
    617              case PWR_GPIO_C:
    618                CLEAR_BIT(PWR->PDCRC, GPIONumber);
    619                break;
    620          
    621              case PWR_GPIO_D:
    622                CLEAR_BIT(PWR->PDCRD, GPIONumber);
    623                break;
    624          
    625          #if defined(GPIOE)
    626              case PWR_GPIO_E:
    627                CLEAR_BIT(PWR->PDCRE, GPIONumber);
    628                break;
    629          #endif /* GPI0E */
    630              case PWR_GPIO_F:
    631                CLEAR_BIT(PWR->PDCRF, GPIONumber);
    632                break;
    633          
    634              default:
    635                status = HAL_ERROR;
    636                break;
    637            }
    638          
    639            return status;
    640          }
    641          
    642          
    643          /**
    644            * @brief  Enable pull-up and pull-down configuration.
    645            * @note   When APC bit is set, the I/O pull-up and pull-down configurations defined in
    646            *         PWR_PUCRx and PWR_PDCRx registers are applied in Standby and Shutdown modes.
    647            * @note   Pull-up set by PUy bit of PWR_PUCRx register is not activated if the corresponding
    648            *         PDy bit of PWR_PDCRx register is also set (pull-down configuration priority is higher).
    649            *         HAL_PWREx_EnableGPIOPullUp() and HAL_PWREx_EnableGPIOPullDown() APIs ensure there
    650            *         is no conflict when setting PUy or PDy bit.
    651            * @retval None
    652            */
    653          void HAL_PWREx_EnablePullUpPullDownConfig(void)
    654          {
    655            SET_BIT(PWR->CR3, PWR_CR3_APC);
    656          }
    657          
    658          /**
    659            * @brief  Disable pull-up and pull-down configuration.
    660            * @note   When APC bit is cleared, the I/O pull-up and pull-down configurations defined in
    661            *         PWR_PUCRx and PWR_PDCRx registers are not applied in Standby and Shutdown modes.
    662            * @retval None
    663            */
    664          void HAL_PWREx_DisablePullUpPullDownConfig(void)
    665          {
    666            CLEAR_BIT(PWR->CR3, PWR_CR3_APC);
    667          }
    668          
    669          #if defined(PWR_CR3_RRS)
    670          /**
    671            * @brief Enable SRAM content retention in Standby mode.
    672            * @note  When RRS bit is set, SRAM is powered by the low-power regulator in
    673            *         Standby mode and its content is kept.
    674            * @retval None
    675            */
    676          void HAL_PWREx_EnableSRAMRetention(void)
    677          {
    678            SET_BIT(PWR->CR3, PWR_CR3_RRS);
    679          }
    680          
    681          
    682          /**
    683            * @brief Disable SRAM content retention in Standby mode.
    684            * @note  When RRS bit is reset, SRAM is powered off in Standby mode
    685            *        and its content is lost.
    686            * @retval None
    687            */
    688          void HAL_PWREx_DisableSRAMRetention(void)
    689          {
    690            CLEAR_BIT(PWR->CR3, PWR_CR3_RRS);
    691          }
    692          #endif /* PWR_CR3_RRS */
    693          
    694          /**
    695            * @brief  Enable Flash Power Down.
    696            * @note   This API allows to enable flash power down capabilities in low power
    697            *         run, low power sleep and stop modes.
    698            * @param  PowerMode this can be a combination of following values:
    699            *           @arg @ref PWR_FLASHPD_LPRUN
    700            *           @arg @ref PWR_FLASHPD_LPSLEEP
    701            *           @arg @ref PWR_FLASHPD_STOP
    702            * @retval None
    703            */
    704          void HAL_PWREx_EnableFlashPowerDown(uint32_t PowerMode)
    705          {
    706            assert_param(IS_PWR_FLASH_POWERDOWN(PowerMode));
    707          
    708            PWR->CR1 |= PowerMode;
    709          }
    710          
    711          
    712          /**
    713            * @brief  Disable Flash Power Down.
    714            * @note   This API allows to disable flash power down capabilities in low power
    715            *         run, low power sleep and stop modes.
    716            * @param  PowerMode this can be a combination of following values:
    717            *           @arg @ref PWR_FLASHPD_LPRUN
    718            *           @arg @ref PWR_FLASHPD_LPSLEEP
    719            *           @arg @ref PWR_FLASHPD_STOP
    720            * @retval None
    721            */
    722          void HAL_PWREx_DisableFlashPowerDown(uint32_t PowerMode)
    723          {
    724            assert_param(IS_PWR_FLASH_POWERDOWN(PowerMode));
    725          
    726            PWR->CR1 &= ~PowerMode;
    727          }
    728          
    729          
    730          /**
    731            * @brief   Return Voltage Scaling Range.
    732            * @retval  VOS bit field:
    733            *         @arg @ref PWR_REGULATOR_VOLTAGE_SCALE1
    734            *         @arg @ref PWR_REGULATOR_VOLTAGE_SCALE2
    735            */
    736          uint32_t HAL_PWREx_GetVoltageRange(void)
    737          {
    738            return (PWR->CR1 & PWR_CR1_VOS);
    739          }
    740          
    741          
    742          /**
    743            * @brief Configure the main regulator output voltage.
    744            * @param  VoltageScaling specifies the regulator output voltage to achieve
    745            *         a tradeoff between performance and power consumption.
    746            *         This parameter can be one of the following values:
    747            *          @arg @ref PWR_REGULATOR_VOLTAGE_SCALE1 Regulator voltage output range 1 mode,
    748            *                                                typical output voltage at 1.2 V,
    749            *                                                system frequency up to 64 MHz.
    750            *          @arg @ref PWR_REGULATOR_VOLTAGE_SCALE2 Regulator voltage output range 2 mode,
    751            *                                                typical output voltage at 1.0 V,
    752            *                                                system frequency up to 16 MHz.
    753            * @note  When moving from Range 1 to Range 2, the system frequency must be decreased to
    754            *        a value below 16 MHz before calling HAL_PWREx_ControlVoltageScaling() API.
    755            *        When moving from Range 2 to Range 1, the system frequency can be increased to
    756            *        a value up to 64 MHz after calling HAL_PWREx_ControlVoltageScaling() API.
    757            * @note  When moving from Range 2 to Range 1, the API waits for VOSF flag to be
    758            *        cleared before returning the status. If the flag is not cleared within
    759            *        6 microseconds, HAL_TIMEOUT status is reported.
    760            * @retval HAL Status
    761            */
    762          HAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling(uint32_t VoltageScaling)
    763          {
    764            uint32_t wait_loop_index;
    765          
    766            assert_param(IS_PWR_VOLTAGE_SCALING_RANGE(VoltageScaling));
    767          
    768            /* Modify voltage scaling range */
    769            MODIFY_REG(PWR->CR1, PWR_CR1_VOS, VoltageScaling);
    770          
    771            /* In case of Range 1 selected, we need to ensure that main regulator reaches new value */
    772            if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1)
    773            {
    774              /* Set timeout value */
    775              wait_loop_index = ((PWR_VOSF_SETTING_DELAY_6_US * SystemCoreClock) / 1000000U) + 1U;
    776          
    777              /* Wait until VOSF is reset */
    778              while (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF))
    779              {
    780                if (wait_loop_index != 0U)
    781                {
    782                  wait_loop_index--;
    783                }
    784                else
    785                {
    786                  return HAL_TIMEOUT;
    787                }
    788              }
    789            }
    790          
    791            return HAL_OK;
    792          }
    793          
    794          
    795          
    796          /**
    797            * @brief Enter Low-power Run mode
    798            * @note  System clock frequency has to be decreased below 2 MHz before entering
    799            *        low power run mode
    800            * @note  In Low-power Run mode, all I/O pins keep the same state as in Run mode.
    801            * @retval None
    802            */
    803          void HAL_PWREx_EnableLowPowerRunMode(void)
    804          {
    805            /* Set Regulator parameter */
    806            SET_BIT(PWR->CR1, PWR_CR1_LPR);
    807          }
    808          
    809          
    810          /**
    811            * @brief Exit Low-power Run mode.
    812            * @note  Before HAL_PWREx_DisableLowPowerRunMode() completion, the function checks that
    813            *        REGLPF has been properly reset (otherwise, HAL_PWREx_DisableLowPowerRunMode
    814            *        returns HAL_TIMEOUT status). The system clock frequency can then be
    815            *        increased above 2 MHz.
    816            * @retval HAL Status
    817            */
    818          HAL_StatusTypeDef HAL_PWREx_DisableLowPowerRunMode(void)
    819          {
    820            uint32_t wait_loop_index = ((PWR_REGLPF_SETTING_DELAY_6_US * SystemCoreClock) / 1000000U) + 1U;
    821          
    822            /* Clear LPR bit */
    823            CLEAR_BIT(PWR->CR1, PWR_CR1_LPR);
    824          
    825            /* Wait until REGLPF is reset */
    826            while (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_REGLPF))
    827            {
    828              if (wait_loop_index != 0U)
    829              {
    830                wait_loop_index--;
    831              }
    832              else
    833              {
    834                return HAL_TIMEOUT;
    835              }
    836            }
    837          
    838            return HAL_OK;
    839          }
    840          
    841          
    842          #if defined(PWR_SHDW_SUPPORT)
    843          /**
    844            * @brief  Enter Shutdown mode.
    845            * @note   In Shutdown mode, the PLL, the HSI, the LSI and the HSE oscillators are switched
    846            *         off. The voltage regulator is disabled and Vcore domain is powered off.
    847            *         SRAM and registers contents are lost except for registers in the Backup domain.
    848            *         The BOR is not available.
    849            * @note   The I/Os can be configured either with a pull-up or pull-down or can
    850            *         be kept in analog state.
    851            *         HAL_PWREx_EnableGPIOPullUp() and HAL_PWREx_EnableGPIOPullDown()
    852            *         respectively enable Pull Up and PullDown state.
    853            *         HAL_PWREx_DisableGPIOPullUp() & HAL_PWREx_DisableGPIOPullDown()
    854            *         disable the same. These states are effective in Standby mode only if
    855            *         APC bit is set through HAL_PWREx_EnablePullUpPullDownConfig() API.
    856            * @retval None
    857          
    858            * @retval None
    859            */
    860          void HAL_PWREx_EnterSHUTDOWNMode(void)
    861          {
    862            /* Set Shutdown mode */
    863            MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_LOWPOWERMODE_SHUTDOWN);
    864          
    865            /* Set SLEEPDEEP bit of Cortex System Control Register */
    866            SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
    867          
    868            /* This option is used to ensure that store operations are completed */
    869          #if defined ( __CC_ARM)
    870            __force_stores();
    871          #endif /* __CC_ARM */
    872          
    873            /* Request Wait For Interrupt */
    874            __WFI();
    875          }
    876          #endif /* PWR_SHDW_SUPPORT */
    877          
    878          #if defined(PWR_PVD_SUPPORT) && defined(PWR_PVM_SUPPORT)
    879          /**
    880            * @brief  This function handles the PWR PVD interrupt request.
    881            * @note   This API should be called under the PVD_IRQHandler().
    882            * @retval None
    883            */
    884          void HAL_PWREx_PVD_PVM_IRQHandler(void)
    885          {
    886            /* Check PWR PVD exti Rising flag */
    887            if (__HAL_PWR_PVD_EXTI_GET_RISING_FLAG() != 0x0U)
    888            {
    889              /* Clear PVD exti pending bit */
    890              __HAL_PWR_PVD_EXTI_CLEAR_RISING_FLAG();
    891          
    892              /* PWR PVD interrupt rising user callback */
    893              HAL_PWREx_PVD_PVM_Rising_Callback();
    894            }
    895          
    896            /* Check PWR exti fallling flag */
    897            if (__HAL_PWR_PVD_EXTI_GET_FALLING_FLAG() != 0x0U)
    898            {
    899              /* Clear PVD exti pending bit */
    900              __HAL_PWR_PVD_EXTI_CLEAR_FALLING_FLAG();
    901          
    902              /* PWR PVD interrupt falling user callback */
    903              HAL_PWREx_PVD_PVM_Falling_Callback();
    904            }
    905          
    906            /* Check PWR PVM exti Rising flag */
    907            if (__HAL_PWR_PVM_EXTI_GET_RISING_FLAG() != 0x0U)
    908            {
    909              /* Clear PVM exti pending bit */
    910              __HAL_PWR_PVM_EXTI_CLEAR_RISING_FLAG();
    911          
    912              /* PWR PVD PVM interrupt rising user callback */
    913              HAL_PWREx_PVD_PVM_Rising_Callback();
    914            }
    915          
    916            /* Check PWR PVM exti fallling flag */
    917            if (__HAL_PWR_PVM_EXTI_GET_FALLING_FLAG() != 0x0U)
    918            {
    919              /* Clear PVM exti pending bit */
    920              __HAL_PWR_PVM_EXTI_CLEAR_FALLING_FLAG();
    921          
    922              /* PWR PVM interrupt falling user callback */
    923              HAL_PWREx_PVD_PVM_Falling_Callback();
    924            }
    925          }
    926          
    927          /**
    928            * @brief  PWR PVD interrupt rising callback
    929            * @retval None
    930            */
    931          __weak void HAL_PWREx_PVD_PVM_Rising_Callback(void)
    932          {
    933            /* NOTE : This function should not be modified; when the callback is needed,
    934                      the HAL_PWR_PVD_Rising_Callback can be implemented in the user file
    935            */
    936          }
    937          
    938          /**
    939            * @brief  PWR PVD interrupt Falling callback
    940            * @retval None
    941            */
    942          __weak void HAL_PWREx_PVD_PVM_Falling_Callback(void)
    943          {
    944            /* NOTE : This function should not be modified; when the callback is needed,
    945                      the HAL_PWR_PVD_Falling_Callback can be implemented in the user file
    946            */
    947          }
    948          #elif defined(PWR_PVD_SUPPORT)
    949          /**
    950            * @brief  This function handles the PWR PVD interrupt request.
    951            * @note   This API should be called under the PVD_IRQHandler().
    952            * @retval None
    953            */
    954          void HAL_PWREx_PVD_IRQHandler(void)
    955          {
    956            /* Check PWR exti Rising flag */
    957            if (__HAL_PWR_PVD_EXTI_GET_RISING_FLAG() != 0x0U)
    958            {
    959              /* Clear PVD exti pending bit */
    960              __HAL_PWR_PVD_EXTI_CLEAR_RISING_FLAG();
    961          
    962              /* PWR PVD interrupt rising user callback */
    963              HAL_PWREx_PVD_Rising_Callback();
    964            }
    965          
    966            /* Check PWR exti fallling flag */
    967            if (__HAL_PWR_PVD_EXTI_GET_FALLING_FLAG() != 0x0U)
    968            {
    969              /* Clear PVD exti pending bit */
    970              __HAL_PWR_PVD_EXTI_CLEAR_FALLING_FLAG();
    971          
    972              /* PWR PVD interrupt falling user callback */
    973              HAL_PWREx_PVD_Falling_Callback();
    974            }
    975          }
    976          
    977          /**
    978            * @brief  PWR PVD interrupt rising callback
    979            * @retval None
    980            */
    981          __weak void HAL_PWREx_PVD_Rising_Callback(void)
    982          {
    983            /* NOTE : This function should not be modified; when the callback is needed,
    984                      the HAL_PWR_PVD_Rising_Callback can be implemented in the user file
    985            */
    986          }
    987          
    988          /**
    989            * @brief  PWR PVD interrupt Falling callback
    990            * @retval None
    991            */
    992          __weak void HAL_PWREx_PVD_Falling_Callback(void)
    993          {
    994            /* NOTE : This function should not be modified; when the callback is needed,
    995                      the HAL_PWR_PVD_Falling_Callback can be implemented in the user file
    996            */
    997          }
    998          
    999          #endif /* PWR_PVD_SUPPORT && PWR_PVM_SUPPORT */
   1000          
   1001          /**
   1002            * @}
   1003            */
   1004          
   1005          /**
   1006            * @}
   1007            */
   1008          
   1009          #endif /* HAL_PWR_MODULE_ENABLED */
   1010          /**
   1011            * @}
   1012            */
   1013          
   1014          /**
   1015            * @}
   1016            */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   HAL_PWREx_ConfigPVD
      12   HAL_PWREx_ConfigPVM
       8   HAL_PWREx_ControlVoltageScaling
         8 __aeabi_uidiv
       0   HAL_PWREx_DisableBatteryCharging
       0   HAL_PWREx_DisableFlashPowerDown
      12   HAL_PWREx_DisableGPIOPullDown
      12   HAL_PWREx_DisableGPIOPullUp
       0   HAL_PWREx_DisableInternalWakeUpLine
       4   HAL_PWREx_DisableLowPowerRunMode
         4 __aeabi_uidiv
       0   HAL_PWREx_DisablePORMonitorSampling
       0   HAL_PWREx_DisablePVD
       0   HAL_PWREx_DisablePVMUSB
       0   HAL_PWREx_DisablePullUpPullDownConfig
       0   HAL_PWREx_DisableSRAMRetention
       0   HAL_PWREx_DisableVddIO2
       0   HAL_PWREx_DisableVddUSB
       0   HAL_PWREx_EnableBatteryCharging
       0   HAL_PWREx_EnableFlashPowerDown
      12   HAL_PWREx_EnableGPIOPullDown
      12   HAL_PWREx_EnableGPIOPullUp
       0   HAL_PWREx_EnableInternalWakeUpLine
       0   HAL_PWREx_EnableLowPowerRunMode
       0   HAL_PWREx_EnablePORMonitorSampling
       0   HAL_PWREx_EnablePVD
       0   HAL_PWREx_EnablePVMUSB
       0   HAL_PWREx_EnablePullUpPullDownConfig
       0   HAL_PWREx_EnableSRAMRetention
       0   HAL_PWREx_EnableVddIO2
       0   HAL_PWREx_EnableVddUSB
       0   HAL_PWREx_EnterSHUTDOWNMode
       0   HAL_PWREx_GetVoltageRange
       0   HAL_PWREx_PVD_PVM_Falling_Callback
      16   HAL_PWREx_PVD_PVM_IRQHandler
        16   -> HAL_PWREx_PVD_PVM_Falling_Callback
        16   -> HAL_PWREx_PVD_PVM_Rising_Callback
       0   HAL_PWREx_PVD_PVM_Rising_Callback


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable20
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable22
       4  ??DataTable27
       4  ??DataTable30
       4  ??DataTable31
       4  ??DataTable31_1
       4  ??DataTable32
       4  ??DataTable32_1
       4  ??DataTable32_10
       4  ??DataTable32_11
       4  ??DataTable32_2
       4  ??DataTable32_3
       4  ??DataTable32_4
       4  ??DataTable32_5
       4  ??DataTable32_6
       4  ??DataTable32_7
       4  ??DataTable32_8
       4  ??DataTable32_9
      10  ?Subroutine0
      10  ?Subroutine1
      12  ?Subroutine2
       8  ?Subroutine3
       8  ?Subroutine4
       8  ?Subroutine5
       8  ?Subroutine6
       8  ?Subroutine7
     102  HAL_PWREx_ConfigPVD
     102  HAL_PWREx_ConfigPVM
      58  HAL_PWREx_ControlVoltageScaling
       4  HAL_PWREx_DisableBatteryCharging
      10  HAL_PWREx_DisableFlashPowerDown
      46  HAL_PWREx_DisableGPIOPullDown
      40  HAL_PWREx_DisableGPIOPullUp
       8  HAL_PWREx_DisableInternalWakeUpLine
      50  HAL_PWREx_DisableLowPowerRunMode
       8  HAL_PWREx_DisablePORMonitorSampling
      12  HAL_PWREx_DisablePVD
       2  HAL_PWREx_DisablePVMUSB
       8  HAL_PWREx_DisablePullUpPullDownConfig
       4  HAL_PWREx_DisableSRAMRetention
       8  HAL_PWREx_DisableVddIO2
       8  HAL_PWREx_DisableVddUSB
      18  HAL_PWREx_EnableBatteryCharging
      10  HAL_PWREx_EnableFlashPowerDown
      82  HAL_PWREx_EnableGPIOPullDown
     108  HAL_PWREx_EnableGPIOPullUp
       8  HAL_PWREx_EnableInternalWakeUpLine
       8  HAL_PWREx_EnableLowPowerRunMode
       4  HAL_PWREx_EnablePORMonitorSampling
       8  HAL_PWREx_EnablePVD
       8  HAL_PWREx_EnablePVMUSB
       8  HAL_PWREx_EnablePullUpPullDownConfig
       8  HAL_PWREx_EnableSRAMRetention
       2  HAL_PWREx_EnableVddIO2
       8  HAL_PWREx_EnableVddUSB
      26  HAL_PWREx_EnterSHUTDOWNMode
      12  HAL_PWREx_GetVoltageRange
       2  HAL_PWREx_PVD_PVM_Falling_Callback
      60  HAL_PWREx_PVD_PVM_IRQHandler
       2  HAL_PWREx_PVD_PVM_Rising_Callback

 
 1'012 bytes in section .text
 
 1'008 bytes of CODE memory (+ 4 bytes shared)

Errors: none
Warnings: none
